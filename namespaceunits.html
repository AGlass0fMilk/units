<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>Unit Conversion and Dimensional Analysis Library: units Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Unit Conversion and Dimensional Analysis Library
   &#160;<span id="projectnumber">2.0.0</span>
   </div>
   <div id="projectbrief">A compile-time c++14 unit conversion library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>Namespace&#160;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">units Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Unit Conversion Library namespace.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespaceunits_1_1acceleration"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceunits_1_1acceleration.html">acceleration</a></td></tr>
<tr class="memdesc:namespaceunits_1_1acceleration"><td class="mdescLeft">&#160;</td><td class="mdescRight">namespace for unit types and containers representing acceleration values <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceunits_1_1angle"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceunits_1_1angle.html">angle</a></td></tr>
<tr class="memdesc:namespaceunits_1_1angle"><td class="mdescLeft">&#160;</td><td class="mdescRight">namespace for unit types and containers representing angle values <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceunits_1_1angular__velocity"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceunits_1_1angular__velocity.html">angular_velocity</a></td></tr>
<tr class="memdesc:namespaceunits_1_1angular__velocity"><td class="mdescLeft">&#160;</td><td class="mdescRight">namespace for unit types and containers representing angular velocity values <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceunits_1_1area"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceunits_1_1area.html">area</a></td></tr>
<tr class="memdesc:namespaceunits_1_1area"><td class="mdescLeft">&#160;</td><td class="mdescRight">namespace for unit types and containers representing area values <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceunits_1_1capacitance"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceunits_1_1capacitance.html">capacitance</a></td></tr>
<tr class="memdesc:namespaceunits_1_1capacitance"><td class="mdescLeft">&#160;</td><td class="mdescRight">namespace for unit types and containers representing capacitance values <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceunits_1_1category"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceunits_1_1category.html">category</a></td></tr>
<tr class="memdesc:namespaceunits_1_1category"><td class="mdescLeft">&#160;</td><td class="mdescRight">namespace representing the implemented base and derived unit types. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceunits_1_1charge"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceunits_1_1charge.html">charge</a></td></tr>
<tr class="memdesc:namespaceunits_1_1charge"><td class="mdescLeft">&#160;</td><td class="mdescRight">namespace for unit types and containers representing charge values <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceunits_1_1concentration"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceunits_1_1concentration.html">concentration</a></td></tr>
<tr class="memdesc:namespaceunits_1_1concentration"><td class="mdescLeft">&#160;</td><td class="mdescRight">namespace for unit types and containers representing concentration values <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceunits_1_1conductance"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceunits_1_1conductance.html">conductance</a></td></tr>
<tr class="memdesc:namespaceunits_1_1conductance"><td class="mdescLeft">&#160;</td><td class="mdescRight">namespace for unit types and containers representing conductance values <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceunits_1_1constants"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceunits_1_1constants.html">constants</a></td></tr>
<tr class="memdesc:namespaceunits_1_1constants"><td class="mdescLeft">&#160;</td><td class="mdescRight">namespace for physical constants like PI and Avogadro's Number. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceunits_1_1current"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceunits_1_1current.html">current</a></td></tr>
<tr class="memdesc:namespaceunits_1_1current"><td class="mdescLeft">&#160;</td><td class="mdescRight">namespace for unit types and containers representing current values <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceunits_1_1density"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceunits_1_1density.html">density</a></td></tr>
<tr class="memdesc:namespaceunits_1_1density"><td class="mdescLeft">&#160;</td><td class="mdescRight">namespace for unit types and containers representing density values <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceunits_1_1dimensionless"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceunits_1_1dimensionless.html">dimensionless</a></td></tr>
<tr class="memdesc:namespaceunits_1_1dimensionless"><td class="mdescLeft">&#160;</td><td class="mdescRight">namespace for unit types and containers for units that have no dimension (scalar units) <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceunits_1_1energy"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceunits_1_1energy.html">energy</a></td></tr>
<tr class="memdesc:namespaceunits_1_1energy"><td class="mdescLeft">&#160;</td><td class="mdescRight">namespace for unit types and containers representing energy values <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceunits_1_1force"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceunits_1_1force.html">force</a></td></tr>
<tr class="memdesc:namespaceunits_1_1force"><td class="mdescLeft">&#160;</td><td class="mdescRight">namespace for unit types and containers representing force values <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceunits_1_1frequency"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceunits_1_1frequency.html">frequency</a></td></tr>
<tr class="memdesc:namespaceunits_1_1frequency"><td class="mdescLeft">&#160;</td><td class="mdescRight">namespace for unit types and containers representing frequency values <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceunits_1_1illuminance"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceunits_1_1illuminance.html">illuminance</a></td></tr>
<tr class="memdesc:namespaceunits_1_1illuminance"><td class="mdescLeft">&#160;</td><td class="mdescRight">namespace for unit types and containers representing illuminance values <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceunits_1_1impedance"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceunits_1_1impedance.html">impedance</a></td></tr>
<tr class="memdesc:namespaceunits_1_1impedance"><td class="mdescLeft">&#160;</td><td class="mdescRight">namespace for unit types and containers representing impedance values <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceunits_1_1inductance"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceunits_1_1inductance.html">inductance</a></td></tr>
<tr class="memdesc:namespaceunits_1_1inductance"><td class="mdescLeft">&#160;</td><td class="mdescRight">namespace for unit types and containers representing inductance values <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceunits_1_1length"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceunits_1_1length.html">length</a></td></tr>
<tr class="memdesc:namespaceunits_1_1length"><td class="mdescLeft">&#160;</td><td class="mdescRight">namespace for unit types and containers representing length values <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceunits_1_1luminous__flux"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceunits_1_1luminous__flux.html">luminous_flux</a></td></tr>
<tr class="memdesc:namespaceunits_1_1luminous__flux"><td class="mdescLeft">&#160;</td><td class="mdescRight">namespace for unit types and containers representing <a class="el" href="namespaceunits_1_1luminous__flux.html" title="namespace for unit types and containers representing luminous_flux values ">luminous_flux</a> values <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceunits_1_1luminous__intensity"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceunits_1_1luminous__intensity.html">luminous_intensity</a></td></tr>
<tr class="memdesc:namespaceunits_1_1luminous__intensity"><td class="mdescLeft">&#160;</td><td class="mdescRight">namespace for unit types and containers representing <a class="el" href="namespaceunits_1_1luminous__intensity.html" title="namespace for unit types and containers representing luminous_intensity values ">luminous_intensity</a> values <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceunits_1_1magnetic__field__strength"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceunits_1_1magnetic__field__strength.html">magnetic_field_strength</a></td></tr>
<tr class="memdesc:namespaceunits_1_1magnetic__field__strength"><td class="mdescLeft">&#160;</td><td class="mdescRight">namespace for unit types and containers representing <a class="el" href="namespaceunits_1_1magnetic__field__strength.html" title="namespace for unit types and containers representing magnetic_field_strength values ...">magnetic_field_strength</a> values <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceunits_1_1magnetic__flux"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceunits_1_1magnetic__flux.html">magnetic_flux</a></td></tr>
<tr class="memdesc:namespaceunits_1_1magnetic__flux"><td class="mdescLeft">&#160;</td><td class="mdescRight">namespace for unit types and containers representing <a class="el" href="namespaceunits_1_1magnetic__flux.html" title="namespace for unit types and containers representing magnetic_flux values ">magnetic_flux</a> values <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceunits_1_1mass"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceunits_1_1mass.html">mass</a></td></tr>
<tr class="memdesc:namespaceunits_1_1mass"><td class="mdescLeft">&#160;</td><td class="mdescRight">namespace for unit types and containers representing mass values <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceunits_1_1math"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceunits_1_1math.html">math</a></td></tr>
<tr class="memdesc:namespaceunits_1_1math"><td class="mdescLeft">&#160;</td><td class="mdescRight">namespace for unit-enabled versions of the <code>&lt;cmath&gt;</code> library <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceunits_1_1power"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceunits_1_1power.html">power</a></td></tr>
<tr class="memdesc:namespaceunits_1_1power"><td class="mdescLeft">&#160;</td><td class="mdescRight">namespace for unit types and containers representing power values <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceunits_1_1pressure"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceunits_1_1pressure.html">pressure</a></td></tr>
<tr class="memdesc:namespaceunits_1_1pressure"><td class="mdescLeft">&#160;</td><td class="mdescRight">namespace for unit types and containers representing pressure values <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceunits_1_1radiation"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceunits_1_1radiation.html">radiation</a></td></tr>
<tr class="memdesc:namespaceunits_1_1radiation"><td class="mdescLeft">&#160;</td><td class="mdescRight">namespace for unit types and containers representing radiation values <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceunits_1_1solid__angle"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceunits_1_1solid__angle.html">solid_angle</a></td></tr>
<tr class="memdesc:namespaceunits_1_1solid__angle"><td class="mdescLeft">&#160;</td><td class="mdescRight">namespace for unit types and containers representing <a class="el" href="namespaceunits_1_1solid__angle.html" title="namespace for unit types and containers representing solid_angle values ">solid_angle</a> values <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceunits_1_1substance"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceunits_1_1substance.html">substance</a></td></tr>
<tr class="memdesc:namespaceunits_1_1substance"><td class="mdescLeft">&#160;</td><td class="mdescRight">namespace for unit types and containers representing substance values <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceunits_1_1temperature"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceunits_1_1temperature.html">temperature</a></td></tr>
<tr class="memdesc:namespaceunits_1_1temperature"><td class="mdescLeft">&#160;</td><td class="mdescRight">namespace for unit types and containers representing temperature values <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceunits_1_1time"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceunits_1_1time.html">time</a></td></tr>
<tr class="memdesc:namespaceunits_1_1time"><td class="mdescLeft">&#160;</td><td class="mdescRight">namespace for unit types and containers representing time values <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceunits_1_1torque"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceunits_1_1torque.html">torque</a></td></tr>
<tr class="memdesc:namespaceunits_1_1torque"><td class="mdescLeft">&#160;</td><td class="mdescRight">namespace for unit types and containers representing torque values <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceunits_1_1traits"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceunits_1_1traits.html">traits</a></td></tr>
<tr class="memdesc:namespaceunits_1_1traits"><td class="mdescLeft">&#160;</td><td class="mdescRight">namespace representing type traits which can access the properties of types provided by the units library. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceunits_1_1velocity"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceunits_1_1velocity.html">velocity</a></td></tr>
<tr class="memdesc:namespaceunits_1_1velocity"><td class="mdescLeft">&#160;</td><td class="mdescRight">namespace for unit types and containers representing velocity values <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceunits_1_1voltage"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceunits_1_1voltage.html">voltage</a></td></tr>
<tr class="memdesc:namespaceunits_1_1voltage"><td class="mdescLeft">&#160;</td><td class="mdescRight">namespace for unit types and containers representing voltage values <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceunits_1_1volume"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceunits_1_1volume.html">volume</a></td></tr>
<tr class="memdesc:namespaceunits_1_1volume"><td class="mdescLeft">&#160;</td><td class="mdescRight">namespace for unit types and containers representing volume values <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structunits_1_1base__unit.html">base_unit</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class representing SI base unit types.  <a href="structunits_1_1base__unit.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structunits_1_1decibel__scale.html">decibel_scale</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classunits_1_1unit__t.html" title="Container for values which represent quantities of a given unit. ">unit_t</a> scale for representing decibel values.  <a href="structunits_1_1decibel__scale.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structunits_1_1linear__scale.html">linear_scale</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classunits_1_1unit__t.html" title="Container for values which represent quantities of a given unit. ">unit_t</a> scale which is linear  <a href="structunits_1_1linear__scale.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structunits_1_1unit.html">unit</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type representing an arbitrary unit.  <a href="structunits_1_1unit.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classunits_1_1unit__t.html">unit_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Container for values which represent quantities of a given unit.  <a href="classunits_1_1unit__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structunits_1_1unit__value__add.html">unit_value_add</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">adds two <a class="el" href="structunits_1_1unit__value__t.html" title="Stores a rational unit value as a compile-time constant. ">unit_value_t</a> types at compile-time  <a href="structunits_1_1unit__value__add.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structunits_1_1unit__value__divide.html">unit_value_divide</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">divides two <a class="el" href="structunits_1_1unit__value__t.html" title="Stores a rational unit value as a compile-time constant. ">unit_value_t</a> types at compile-time  <a href="structunits_1_1unit__value__divide.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structunits_1_1unit__value__multiply.html">unit_value_multiply</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">multiplies two <a class="el" href="structunits_1_1unit__value__t.html" title="Stores a rational unit value as a compile-time constant. ">unit_value_t</a> types at compile-time  <a href="structunits_1_1unit__value__multiply.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structunits_1_1unit__value__power.html">unit_value_power</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">raises unit_value_to a power at compile-time  <a href="structunits_1_1unit__value__power.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structunits_1_1unit__value__sqrt.html">unit_value_sqrt</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">calculates square root of <a class="el" href="structunits_1_1unit__value__t.html" title="Stores a rational unit value as a compile-time constant. ">unit_value_t</a> at compile-time  <a href="structunits_1_1unit__value__sqrt.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structunits_1_1unit__value__subtract.html">unit_value_subtract</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">subtracts two <a class="el" href="structunits_1_1unit__value__t.html" title="Stores a rational unit value as a compile-time constant. ">unit_value_t</a> types at compile-time  <a href="structunits_1_1unit__value__subtract.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structunits_1_1unit__value__t.html">unit_value_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores a rational unit value as a compile-time constant.  <a href="structunits_1_1unit__value__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga18b87c9f4576fb72ddc0b2a516a42d41"><td class="memTemplParams" colspan="2">template&lt;class U &gt; </td></tr>
<tr class="memitem:ga18b87c9f4576fb72ddc0b2a516a42d41"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___unit_manipulators.html#ga18b87c9f4576fb72ddc0b2a516a42d41">inverse</a> = typename units::detail::inverse_impl&lt; U &gt;::type</td></tr>
<tr class="memdesc:ga18b87c9f4576fb72ddc0b2a516a42d41"><td class="mdescLeft">&#160;</td><td class="mdescRight">represents the inverse unit type of <code>class U</code>.  <a href="group___unit_manipulators.html#ga18b87c9f4576fb72ddc0b2a516a42d41">More...</a><br /></td></tr>
<tr class="separator:ga18b87c9f4576fb72ddc0b2a516a42d41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga38048bc5246636a5eb0007262475dc38"><td class="memTemplParams" colspan="2">template&lt;class U &gt; </td></tr>
<tr class="memitem:ga38048bc5246636a5eb0007262475dc38"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___unit_manipulators.html#ga38048bc5246636a5eb0007262475dc38">squared</a> = typename units::detail::squared_impl&lt; U &gt;::type</td></tr>
<tr class="memdesc:ga38048bc5246636a5eb0007262475dc38"><td class="mdescLeft">&#160;</td><td class="mdescRight">represents the unit type of <code>class U</code> squared  <a href="group___unit_manipulators.html#ga38048bc5246636a5eb0007262475dc38">More...</a><br /></td></tr>
<tr class="separator:ga38048bc5246636a5eb0007262475dc38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4278ee8cb796f22534570134325a4d52"><td class="memTemplParams" colspan="2">template&lt;class U &gt; </td></tr>
<tr class="memitem:ga4278ee8cb796f22534570134325a4d52"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___unit_manipulators.html#ga4278ee8cb796f22534570134325a4d52">cubed</a> = typename units::detail::cubed_impl&lt; U &gt;::type</td></tr>
<tr class="memdesc:ga4278ee8cb796f22534570134325a4d52"><td class="mdescLeft">&#160;</td><td class="mdescRight">represents the type of <code>class U</code> cubed.  <a href="group___unit_manipulators.html#ga4278ee8cb796f22534570134325a4d52">More...</a><br /></td></tr>
<tr class="separator:ga4278ee8cb796f22534570134325a4d52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae4fc0fa9574c73dd4c8828a6b6f5fd5d"><td class="memTemplParams" colspan="2">template&lt;typename Ratio , std::intmax_t Eps = 10000000000&gt; </td></tr>
<tr class="memitem:gae4fc0fa9574c73dd4c8828a6b6f5fd5d"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___type_traits.html#gae4fc0fa9574c73dd4c8828a6b6f5fd5d">ratio_sqrt</a> = typename units::detail::Sqrt&lt; Ratio, std::ratio&lt; 1, Eps &gt;&gt;::type</td></tr>
<tr class="memdesc:gae4fc0fa9574c73dd4c8828a6b6f5fd5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate square root of a ratio at compile-time.  <a href="group___type_traits.html#gae4fc0fa9574c73dd4c8828a6b6f5fd5d">More...</a><br /></td></tr>
<tr class="separator:gae4fc0fa9574c73dd4c8828a6b6f5fd5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad6fb385c468a9f9956d23ebc7c38523a"><td class="memTemplParams" colspan="2">template&lt;class U , std::intmax_t Eps = 10000000000&gt; </td></tr>
<tr class="memitem:gad6fb385c468a9f9956d23ebc7c38523a"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___unit_manipulators.html#gad6fb385c468a9f9956d23ebc7c38523a">square_root</a> = typename units::detail::sqrt_impl&lt; U, Eps &gt;::type</td></tr>
<tr class="memdesc:gad6fb385c468a9f9956d23ebc7c38523a"><td class="mdescLeft">&#160;</td><td class="mdescRight">represents the square root of type <code>class U</code>.  <a href="group___unit_manipulators.html#gad6fb385c468a9f9956d23ebc7c38523a">More...</a><br /></td></tr>
<tr class="separator:gad6fb385c468a9f9956d23ebc7c38523a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga36d8b8cf508bd5ac7854d15f6eaf2d7c"><td class="memTemplParams" colspan="2">template&lt;class U , class... Us&gt; </td></tr>
<tr class="memitem:ga36d8b8cf508bd5ac7854d15f6eaf2d7c"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___unit_types.html#ga36d8b8cf508bd5ac7854d15f6eaf2d7c">compound_unit</a> = typename units::detail::compound_impl&lt; U, Us... &gt;::type</td></tr>
<tr class="memdesc:ga36d8b8cf508bd5ac7854d15f6eaf2d7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a unit type made up from other units.  <a href="group___unit_types.html#ga36d8b8cf508bd5ac7854d15f6eaf2d7c">More...</a><br /></td></tr>
<tr class="separator:ga36d8b8cf508bd5ac7854d15f6eaf2d7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:gaae513fa68478da5ffc6dd1b739da560f"><td class="memTemplParams" colspan="2">template&lt;class U &gt; </td></tr>
<tr class="memitem:gaae513fa68478da5ffc6dd1b739da560f"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___unit_manipulators.html#gaae513fa68478da5ffc6dd1b739da560f">atto</a> = typename units::detail::prefix&lt; std::atto, U &gt;::type</td></tr>
<tr class="memdesc:gaae513fa68478da5ffc6dd1b739da560f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the type of <code>class U</code> with the metric 'atto' prefix appended.  <a href="group___unit_manipulators.html#gaae513fa68478da5ffc6dd1b739da560f">More...</a><br /></td></tr>
<tr class="separator:gaae513fa68478da5ffc6dd1b739da560f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad3c0a87809bff5cd9fdb2863082d9f7f"><td class="memTemplParams" colspan="2">template&lt;class U &gt; </td></tr>
<tr class="memitem:gad3c0a87809bff5cd9fdb2863082d9f7f"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___unit_manipulators.html#gad3c0a87809bff5cd9fdb2863082d9f7f">femto</a> = typename units::detail::prefix&lt; std::femto, U &gt;::type</td></tr>
<tr class="memdesc:gad3c0a87809bff5cd9fdb2863082d9f7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the type of <code>class U</code> with the metric 'atto' prefix appended.  <a href="group___unit_manipulators.html#gad3c0a87809bff5cd9fdb2863082d9f7f">More...</a><br /></td></tr>
<tr class="separator:gad3c0a87809bff5cd9fdb2863082d9f7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga85526b34ae64aa914711e963006c2ac7"><td class="memTemplParams" colspan="2">template&lt;class U &gt; </td></tr>
<tr class="memitem:ga85526b34ae64aa914711e963006c2ac7"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___unit_manipulators.html#ga85526b34ae64aa914711e963006c2ac7">pico</a> = typename units::detail::prefix&lt; std::pico, U &gt;::type</td></tr>
<tr class="memdesc:ga85526b34ae64aa914711e963006c2ac7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the type of <code>class U</code> with the metric 'femto' prefix appended.  <a href="group___unit_manipulators.html#ga85526b34ae64aa914711e963006c2ac7">More...</a><br /></td></tr>
<tr class="separator:ga85526b34ae64aa914711e963006c2ac7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae66a8996b06be0e044209702a4ff9aac"><td class="memTemplParams" colspan="2">template&lt;class U &gt; </td></tr>
<tr class="memitem:gae66a8996b06be0e044209702a4ff9aac"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___unit_manipulators.html#gae66a8996b06be0e044209702a4ff9aac">nano</a> = typename units::detail::prefix&lt; std::nano, U &gt;::type</td></tr>
<tr class="memdesc:gae66a8996b06be0e044209702a4ff9aac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the type of <code>class U</code> with the metric 'pico' prefix appended.  <a href="group___unit_manipulators.html#gae66a8996b06be0e044209702a4ff9aac">More...</a><br /></td></tr>
<tr class="separator:gae66a8996b06be0e044209702a4ff9aac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5266808e7ad1882baac351dba6c443d7"><td class="memTemplParams" colspan="2">template&lt;class U &gt; </td></tr>
<tr class="memitem:ga5266808e7ad1882baac351dba6c443d7"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___unit_manipulators.html#ga5266808e7ad1882baac351dba6c443d7">micro</a> = typename units::detail::prefix&lt; std::micro, U &gt;::type</td></tr>
<tr class="memdesc:ga5266808e7ad1882baac351dba6c443d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the type of <code>class U</code> with the metric 'nano' prefix appended.  <a href="group___unit_manipulators.html#ga5266808e7ad1882baac351dba6c443d7">More...</a><br /></td></tr>
<tr class="separator:ga5266808e7ad1882baac351dba6c443d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gace59b4cdcdae38d875f55f9d62945a4b"><td class="memTemplParams" colspan="2">template&lt;class U &gt; </td></tr>
<tr class="memitem:gace59b4cdcdae38d875f55f9d62945a4b"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___unit_manipulators.html#gace59b4cdcdae38d875f55f9d62945a4b">milli</a> = typename units::detail::prefix&lt; std::milli, U &gt;::type</td></tr>
<tr class="memdesc:gace59b4cdcdae38d875f55f9d62945a4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the type of <code>class U</code> with the metric 'micro' prefix appended.  <a href="group___unit_manipulators.html#gace59b4cdcdae38d875f55f9d62945a4b">More...</a><br /></td></tr>
<tr class="separator:gace59b4cdcdae38d875f55f9d62945a4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1247489aac9ea51d13a9065d8bb66ccd"><td class="memTemplParams" colspan="2">template&lt;class U &gt; </td></tr>
<tr class="memitem:ga1247489aac9ea51d13a9065d8bb66ccd"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___unit_manipulators.html#ga1247489aac9ea51d13a9065d8bb66ccd">centi</a> = typename units::detail::prefix&lt; std::centi, U &gt;::type</td></tr>
<tr class="memdesc:ga1247489aac9ea51d13a9065d8bb66ccd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the type of <code>class U</code> with the metric 'milli' prefix appended.  <a href="group___unit_manipulators.html#ga1247489aac9ea51d13a9065d8bb66ccd">More...</a><br /></td></tr>
<tr class="separator:ga1247489aac9ea51d13a9065d8bb66ccd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3af81695b9701ebe2db4f058f082a615"><td class="memTemplParams" colspan="2">template&lt;class U &gt; </td></tr>
<tr class="memitem:ga3af81695b9701ebe2db4f058f082a615"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___unit_manipulators.html#ga3af81695b9701ebe2db4f058f082a615">deci</a> = typename units::detail::prefix&lt; std::deci, U &gt;::type</td></tr>
<tr class="memdesc:ga3af81695b9701ebe2db4f058f082a615"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the type of <code>class U</code> with the metric 'centi' prefix appended.  <a href="group___unit_manipulators.html#ga3af81695b9701ebe2db4f058f082a615">More...</a><br /></td></tr>
<tr class="separator:ga3af81695b9701ebe2db4f058f082a615"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga38a0917f3f85a5eac09b31f774931490"><td class="memTemplParams" colspan="2">template&lt;class U &gt; </td></tr>
<tr class="memitem:ga38a0917f3f85a5eac09b31f774931490"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___unit_manipulators.html#ga38a0917f3f85a5eac09b31f774931490">deca</a> = typename units::detail::prefix&lt; std::deca, U &gt;::type</td></tr>
<tr class="memdesc:ga38a0917f3f85a5eac09b31f774931490"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the type of <code>class U</code> with the metric 'deci' prefix appended.  <a href="group___unit_manipulators.html#ga38a0917f3f85a5eac09b31f774931490">More...</a><br /></td></tr>
<tr class="separator:ga38a0917f3f85a5eac09b31f774931490"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6ac60b79fb1908be8f5a27b43ca7a32f"><td class="memTemplParams" colspan="2">template&lt;class U &gt; </td></tr>
<tr class="memitem:ga6ac60b79fb1908be8f5a27b43ca7a32f"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___unit_manipulators.html#ga6ac60b79fb1908be8f5a27b43ca7a32f">hecto</a> = typename units::detail::prefix&lt; std::hecto, U &gt;::type</td></tr>
<tr class="memdesc:ga6ac60b79fb1908be8f5a27b43ca7a32f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the type of <code>class U</code> with the metric 'deca' prefix appended.  <a href="group___unit_manipulators.html#ga6ac60b79fb1908be8f5a27b43ca7a32f">More...</a><br /></td></tr>
<tr class="separator:ga6ac60b79fb1908be8f5a27b43ca7a32f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf1b5108a86458a17f2a28245e52018ca"><td class="memTemplParams" colspan="2">template&lt;class U &gt; </td></tr>
<tr class="memitem:gaf1b5108a86458a17f2a28245e52018ca"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___unit_manipulators.html#gaf1b5108a86458a17f2a28245e52018ca">kilo</a> = typename units::detail::prefix&lt; std::kilo, U &gt;::type</td></tr>
<tr class="memdesc:gaf1b5108a86458a17f2a28245e52018ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the type of <code>class U</code> with the metric 'hecto' prefix appended.  <a href="group___unit_manipulators.html#gaf1b5108a86458a17f2a28245e52018ca">More...</a><br /></td></tr>
<tr class="separator:gaf1b5108a86458a17f2a28245e52018ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaee8f573df6e966667e59aef6be3d1ac3"><td class="memTemplParams" colspan="2">template&lt;class U &gt; </td></tr>
<tr class="memitem:gaee8f573df6e966667e59aef6be3d1ac3"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___unit_manipulators.html#gaee8f573df6e966667e59aef6be3d1ac3">mega</a> = typename units::detail::prefix&lt; std::mega, U &gt;::type</td></tr>
<tr class="memdesc:gaee8f573df6e966667e59aef6be3d1ac3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the type of <code>class U</code> with the metric 'kilo' prefix appended.  <a href="group___unit_manipulators.html#gaee8f573df6e966667e59aef6be3d1ac3">More...</a><br /></td></tr>
<tr class="separator:gaee8f573df6e966667e59aef6be3d1ac3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga33f0f9ced3598a431c4e2c91ded7ad24"><td class="memTemplParams" colspan="2">template&lt;class U &gt; </td></tr>
<tr class="memitem:ga33f0f9ced3598a431c4e2c91ded7ad24"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___unit_manipulators.html#ga33f0f9ced3598a431c4e2c91ded7ad24">giga</a> = typename units::detail::prefix&lt; std::giga, U &gt;::type</td></tr>
<tr class="memdesc:ga33f0f9ced3598a431c4e2c91ded7ad24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the type of <code>class U</code> with the metric 'mega' prefix appended.  <a href="group___unit_manipulators.html#ga33f0f9ced3598a431c4e2c91ded7ad24">More...</a><br /></td></tr>
<tr class="separator:ga33f0f9ced3598a431c4e2c91ded7ad24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga86f4dc14b9068dd50b2f3a51219139f1"><td class="memTemplParams" colspan="2">template&lt;class U &gt; </td></tr>
<tr class="memitem:ga86f4dc14b9068dd50b2f3a51219139f1"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___unit_manipulators.html#ga86f4dc14b9068dd50b2f3a51219139f1">tera</a> = typename units::detail::prefix&lt; std::tera, U &gt;::type</td></tr>
<tr class="memdesc:ga86f4dc14b9068dd50b2f3a51219139f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the type of <code>class U</code> with the metric 'giga' prefix appended.  <a href="group___unit_manipulators.html#ga86f4dc14b9068dd50b2f3a51219139f1">More...</a><br /></td></tr>
<tr class="separator:ga86f4dc14b9068dd50b2f3a51219139f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0161cd30954b20e7c7bc5043d428acf2"><td class="memTemplParams" colspan="2">template&lt;class U &gt; </td></tr>
<tr class="memitem:ga0161cd30954b20e7c7bc5043d428acf2"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___unit_manipulators.html#ga0161cd30954b20e7c7bc5043d428acf2">peta</a> = typename units::detail::prefix&lt; std::peta, U &gt;::type</td></tr>
<tr class="memdesc:ga0161cd30954b20e7c7bc5043d428acf2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the type of <code>class U</code> with the metric 'tera' prefix appended.  <a href="group___unit_manipulators.html#ga0161cd30954b20e7c7bc5043d428acf2">More...</a><br /></td></tr>
<tr class="separator:ga0161cd30954b20e7c7bc5043d428acf2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gace72ca1410a8c171eafe012f152e8926"><td class="memTemplParams" colspan="2">template&lt;class U &gt; </td></tr>
<tr class="memitem:gace72ca1410a8c171eafe012f152e8926"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___unit_manipulators.html#gace72ca1410a8c171eafe012f152e8926">exa</a> = typename units::detail::prefix&lt; std::exa, U &gt;::type</td></tr>
<tr class="memdesc:gace72ca1410a8c171eafe012f152e8926"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the type of <code>class U</code> with the metric 'peta' prefix appended.  <a href="group___unit_manipulators.html#gace72ca1410a8c171eafe012f152e8926">More...</a><br /></td></tr>
<tr class="separator:gace72ca1410a8c171eafe012f152e8926"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gae7541dbcd66420e011c82ac58ef7723c"><td class="memTemplParams" colspan="2">template&lt;class UnitFrom , class UnitTo , typename T  = double&gt; </td></tr>
<tr class="memitem:gae7541dbcd66420e011c82ac58ef7723c"><td class="memTemplItemLeft" align="right" valign="top">static T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___conversion.html#gae7541dbcd66420e011c82ac58ef7723c">convert</a> (const T &amp;value)</td></tr>
<tr class="memdesc:gae7541dbcd66420e011c82ac58ef7723c"><td class="mdescLeft">&#160;</td><td class="mdescRight">converts a <em>value</em> from one type to another.  <a href="group___conversion.html#gae7541dbcd66420e011c82ac58ef7723c">More...</a><br /></td></tr>
<tr class="separator:gae7541dbcd66420e011c82ac58ef7723c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86c838bed1ec47df6357e611aca1ca6a"><td class="memTemplParams" colspan="2"><a class="anchor" id="a86c838bed1ec47df6357e611aca1ca6a"></a>
template&lt;class Units , typename T , template&lt; typename &gt; class NonLinearScale&gt; </td></tr>
<tr class="memitem:a86c838bed1ec47df6357e611aca1ca6a"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;&lt;</b> (std::ostream &amp;os, const <a class="el" href="classunits_1_1unit__t.html">unit_t</a>&lt; Units, T, NonLinearScale &gt; &amp;obj)</td></tr>
<tr class="separator:a86c838bed1ec47df6357e611aca1ca6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4166f90759abc03883a0e10541451eb1"><td class="memTemplParams" colspan="2"><a class="anchor" id="a4166f90759abc03883a0e10541451eb1"></a>
template&lt;class Units , typename T , template&lt; typename &gt; class NonLinearScale&gt; </td></tr>
<tr class="memitem:a4166f90759abc03883a0e10541451eb1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classunits_1_1unit__t.html">unit_t</a>&lt; Units, T, NonLinearScale &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator-</b> (const <a class="el" href="classunits_1_1unit__t.html">unit_t</a>&lt; Units, T, NonLinearScale &gt; &amp;val)</td></tr>
<tr class="separator:a4166f90759abc03883a0e10541451eb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d28d681e2cb80d41ee4b4ca0e851f9c"><td class="memTemplParams" colspan="2"><a class="anchor" id="a4d28d681e2cb80d41ee4b4ca0e851f9c"></a>
template&lt;class UnitTypeLhs , class UnitTypeRhs , typename std::enable_if&lt;!traits::is_same_scale&lt; UnitTypeLhs, UnitTypeRhs &gt;::value, int &gt;::type  = 0&gt; </td></tr>
<tr class="memitem:a4d28d681e2cb80d41ee4b4ca0e851f9c"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator+</b> (const UnitTypeLhs &amp;lhs, const UnitTypeRhs &amp;rhs)</td></tr>
<tr class="separator:a4d28d681e2cb80d41ee4b4ca0e851f9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67b2fe0b52dd4cbcee76610289d76ae0"><td class="memTemplParams" colspan="2"><a class="anchor" id="a67b2fe0b52dd4cbcee76610289d76ae0"></a>
template&lt;class UnitTypeLhs , class UnitTypeRhs , typename std::enable_if&lt; traits::has_linear_scale&lt; UnitTypeLhs, UnitTypeRhs &gt;::value, int &gt;::type  = 0&gt; </td></tr>
<tr class="memitem:a67b2fe0b52dd4cbcee76610289d76ae0"><td class="memTemplItemLeft" align="right" valign="top">UnitTypeLhs&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceunits.html#a67b2fe0b52dd4cbcee76610289d76ae0">operator+</a> (const UnitTypeLhs &amp;lhs, const UnitTypeRhs &amp;rhs)</td></tr>
<tr class="memdesc:a67b2fe0b52dd4cbcee76610289d76ae0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Addition operator for <a class="el" href="classunits_1_1unit__t.html" title="Container for values which represent quantities of a given unit. ">unit_t</a> types with a <a class="el" href="structunits_1_1linear__scale.html" title="unit_t scale which is linear ">linear_scale</a>. <br /></td></tr>
<tr class="separator:a67b2fe0b52dd4cbcee76610289d76ae0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab37cafc17a3e78f576c4641015be1f5e"><td class="memTemplParams" colspan="2"><a class="anchor" id="ab37cafc17a3e78f576c4641015be1f5e"></a>
template&lt;typename T , typename std::enable_if&lt; std::is_arithmetic&lt; T &gt;::value, int &gt;::type  = 0&gt; </td></tr>
<tr class="memitem:ab37cafc17a3e78f576c4641015be1f5e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classunits_1_1unit__t.html">dimensionless::scalar_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceunits.html#ab37cafc17a3e78f576c4641015be1f5e">operator+</a> (const <a class="el" href="classunits_1_1unit__t.html">dimensionless::scalar_t</a> &amp;lhs, T rhs)</td></tr>
<tr class="memdesc:ab37cafc17a3e78f576c4641015be1f5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Addition operator for scalar <a class="el" href="classunits_1_1unit__t.html" title="Container for values which represent quantities of a given unit. ">unit_t</a> types with a <a class="el" href="structunits_1_1linear__scale.html" title="unit_t scale which is linear ">linear_scale</a>. Scalar types can be implicitly converted to built-in types. <br /></td></tr>
<tr class="separator:ab37cafc17a3e78f576c4641015be1f5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a185958a6c867e29f7fca92d28922addd"><td class="memTemplParams" colspan="2"><a class="anchor" id="a185958a6c867e29f7fca92d28922addd"></a>
template&lt;typename T , typename std::enable_if&lt; std::is_arithmetic&lt; T &gt;::value, int &gt;::type  = 0&gt; </td></tr>
<tr class="memitem:a185958a6c867e29f7fca92d28922addd"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classunits_1_1unit__t.html">dimensionless::scalar_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceunits.html#a185958a6c867e29f7fca92d28922addd">operator+</a> (T lhs, const <a class="el" href="classunits_1_1unit__t.html">dimensionless::scalar_t</a> &amp;rhs)</td></tr>
<tr class="memdesc:a185958a6c867e29f7fca92d28922addd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Addition operator for scalar <a class="el" href="classunits_1_1unit__t.html" title="Container for values which represent quantities of a given unit. ">unit_t</a> types with a <a class="el" href="structunits_1_1linear__scale.html" title="unit_t scale which is linear ">linear_scale</a>. Scalar types can be implicitly converted to built-in types. <br /></td></tr>
<tr class="separator:a185958a6c867e29f7fca92d28922addd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad741c4cf191609a83e6301dcab5af401"><td class="memTemplParams" colspan="2"><a class="anchor" id="ad741c4cf191609a83e6301dcab5af401"></a>
template&lt;class UnitTypeLhs , class UnitTypeRhs , typename std::enable_if&lt; traits::has_linear_scale&lt; UnitTypeLhs, UnitTypeRhs &gt;::value, int &gt;::type  = 0&gt; </td></tr>
<tr class="memitem:ad741c4cf191609a83e6301dcab5af401"><td class="memTemplItemLeft" align="right" valign="top">UnitTypeLhs&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceunits.html#ad741c4cf191609a83e6301dcab5af401">operator-</a> (const UnitTypeLhs &amp;lhs, const UnitTypeRhs &amp;rhs)</td></tr>
<tr class="memdesc:ad741c4cf191609a83e6301dcab5af401"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtraction operator for <a class="el" href="classunits_1_1unit__t.html" title="Container for values which represent quantities of a given unit. ">unit_t</a> types with a <a class="el" href="structunits_1_1linear__scale.html" title="unit_t scale which is linear ">linear_scale</a>. <br /></td></tr>
<tr class="separator:ad741c4cf191609a83e6301dcab5af401"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7e9eb5238fdd174f781e07982a5b1e5"><td class="memTemplParams" colspan="2"><a class="anchor" id="ab7e9eb5238fdd174f781e07982a5b1e5"></a>
template&lt;typename T , typename std::enable_if&lt; std::is_arithmetic&lt; T &gt;::value, int &gt;::type  = 0&gt; </td></tr>
<tr class="memitem:ab7e9eb5238fdd174f781e07982a5b1e5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classunits_1_1unit__t.html">dimensionless::scalar_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceunits.html#ab7e9eb5238fdd174f781e07982a5b1e5">operator-</a> (const <a class="el" href="classunits_1_1unit__t.html">dimensionless::scalar_t</a> &amp;lhs, T rhs)</td></tr>
<tr class="memdesc:ab7e9eb5238fdd174f781e07982a5b1e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtraction operator for scalar <a class="el" href="classunits_1_1unit__t.html" title="Container for values which represent quantities of a given unit. ">unit_t</a> types with a <a class="el" href="structunits_1_1linear__scale.html" title="unit_t scale which is linear ">linear_scale</a>. Scalar types can be implicitly converted to built-in types. <br /></td></tr>
<tr class="separator:ab7e9eb5238fdd174f781e07982a5b1e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60fc90c20e60aed63820ef98427785d6"><td class="memTemplParams" colspan="2"><a class="anchor" id="a60fc90c20e60aed63820ef98427785d6"></a>
template&lt;typename T , typename std::enable_if&lt; std::is_arithmetic&lt; T &gt;::value, int &gt;::type  = 0&gt; </td></tr>
<tr class="memitem:a60fc90c20e60aed63820ef98427785d6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classunits_1_1unit__t.html">dimensionless::scalar_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceunits.html#a60fc90c20e60aed63820ef98427785d6">operator-</a> (T lhs, const <a class="el" href="classunits_1_1unit__t.html">dimensionless::scalar_t</a> &amp;rhs)</td></tr>
<tr class="memdesc:a60fc90c20e60aed63820ef98427785d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtraction operator for scalar <a class="el" href="classunits_1_1unit__t.html" title="Container for values which represent quantities of a given unit. ">unit_t</a> types with a <a class="el" href="structunits_1_1linear__scale.html" title="unit_t scale which is linear ">linear_scale</a>. Scalar types can be implicitly converted to built-in types. <br /></td></tr>
<tr class="separator:a60fc90c20e60aed63820ef98427785d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecb0676083bca2ce81ec8f415879a446"><td class="memTemplParams" colspan="2">template&lt;class UnitTypeLhs , class UnitTypeRhs , typename std::enable_if&lt; traits::is_convertible_unit_t&lt; UnitTypeLhs, UnitTypeRhs &gt;::value &amp;&amp;traits::has_linear_scale&lt; UnitTypeLhs, UnitTypeRhs &gt;::value, int &gt;::type  = 0&gt; </td></tr>
<tr class="memitem:aecb0676083bca2ce81ec8f415879a446"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceunits.html#aecb0676083bca2ce81ec8f415879a446">operator*</a> (const UnitTypeLhs &amp;lhs, const UnitTypeRhs &amp;rhs) -&gt; <a class="el" href="classunits_1_1unit__t.html">unit_t</a>&lt; <a class="el" href="group___unit_types.html#ga36d8b8cf508bd5ac7854d15f6eaf2d7c">compound_unit</a>&lt; <a class="el" href="group___unit_manipulators.html#ga38048bc5246636a5eb0007262475dc38">squared</a>&lt; typename <a class="el" href="structunits_1_1traits_1_1unit__t__traits.html">units::traits::unit_t_traits</a>&lt; UnitTypeLhs &gt;::unit_type &gt;&gt;&gt;</td></tr>
<tr class="memdesc:aecb0676083bca2ce81ec8f415879a446"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication type for convertible <a class="el" href="classunits_1_1unit__t.html" title="Container for values which represent quantities of a given unit. ">unit_t</a> types with a linear scale.  <a href="#aecb0676083bca2ce81ec8f415879a446">More...</a><br /></td></tr>
<tr class="separator:aecb0676083bca2ce81ec8f415879a446"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1331b4001873d72d2720c91c9466f62f"><td class="memTemplParams" colspan="2"><a class="anchor" id="a1331b4001873d72d2720c91c9466f62f"></a>
template&lt;class UnitTypeLhs , typename T , typename std::enable_if&lt; std::is_arithmetic&lt; T &gt;::value &amp;&amp;traits::has_linear_scale&lt; UnitTypeLhs &gt;::value, int &gt;::type  = 0&gt; </td></tr>
<tr class="memitem:a1331b4001873d72d2720c91c9466f62f"><td class="memTemplItemLeft" align="right" valign="top">UnitTypeLhs&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceunits.html#a1331b4001873d72d2720c91c9466f62f">operator*</a> (const UnitTypeLhs &amp;lhs, T rhs)</td></tr>
<tr class="memdesc:a1331b4001873d72d2720c91c9466f62f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication by a scalar for <a class="el" href="classunits_1_1unit__t.html" title="Container for values which represent quantities of a given unit. ">unit_t</a> types with a linear scale. <br /></td></tr>
<tr class="separator:a1331b4001873d72d2720c91c9466f62f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89703f136d140a037e83d384b868e326"><td class="memTemplParams" colspan="2"><a class="anchor" id="a89703f136d140a037e83d384b868e326"></a>
template&lt;class UnitTypeRhs , typename T , typename std::enable_if&lt; std::is_arithmetic&lt; T &gt;::value &amp;&amp;traits::has_linear_scale&lt; UnitTypeRhs &gt;::value, int &gt;::type  = 0&gt; </td></tr>
<tr class="memitem:a89703f136d140a037e83d384b868e326"><td class="memTemplItemLeft" align="right" valign="top">UnitTypeRhs&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceunits.html#a89703f136d140a037e83d384b868e326">operator*</a> (T lhs, const UnitTypeRhs &amp;rhs)</td></tr>
<tr class="memdesc:a89703f136d140a037e83d384b868e326"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication by a scalar for <a class="el" href="classunits_1_1unit__t.html" title="Container for values which represent quantities of a given unit. ">unit_t</a> types with a linear scale. <br /></td></tr>
<tr class="separator:a89703f136d140a037e83d384b868e326"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab25fd921bcae7ad360270801b38ebeaa"><td class="memTemplParams" colspan="2">template&lt;class UnitTypeLhs , class UnitTypeRhs , typename std::enable_if&lt; traits::is_convertible_unit_t&lt; UnitTypeLhs, UnitTypeRhs &gt;::value &amp;&amp;traits::has_linear_scale&lt; UnitTypeLhs, UnitTypeRhs &gt;::value, int &gt;::type  = 0&gt; </td></tr>
<tr class="memitem:ab25fd921bcae7ad360270801b38ebeaa"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classunits_1_1unit__t.html">dimensionless::scalar_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceunits.html#ab25fd921bcae7ad360270801b38ebeaa">operator/</a> (const UnitTypeLhs &amp;lhs, const UnitTypeRhs &amp;rhs)</td></tr>
<tr class="memdesc:ab25fd921bcae7ad360270801b38ebeaa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Division for convertible <a class="el" href="classunits_1_1unit__t.html" title="Container for values which represent quantities of a given unit. ">unit_t</a> types with a linear scale.  <a href="#ab25fd921bcae7ad360270801b38ebeaa">More...</a><br /></td></tr>
<tr class="separator:ab25fd921bcae7ad360270801b38ebeaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39125a4f93db2dba1b0a753ccdb26123"><td class="memTemplParams" colspan="2">template&lt;class UnitTypeLhs , class UnitTypeRhs , typename std::enable_if&lt;!traits::is_convertible_unit_t&lt; UnitTypeLhs, UnitTypeRhs &gt;::value &amp;&amp;traits::has_linear_scale&lt; UnitTypeLhs, UnitTypeRhs &gt;::value, int &gt;::type  = 0&gt; </td></tr>
<tr class="memitem:a39125a4f93db2dba1b0a753ccdb26123"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceunits.html#a39125a4f93db2dba1b0a753ccdb26123">operator/</a> (const UnitTypeLhs &amp;lhs, const UnitTypeRhs &amp;rhs) -&gt; <a class="el" href="classunits_1_1unit__t.html">unit_t</a>&lt; <a class="el" href="group___unit_types.html#ga36d8b8cf508bd5ac7854d15f6eaf2d7c">compound_unit</a>&lt; typename <a class="el" href="structunits_1_1traits_1_1unit__t__traits.html">units::traits::unit_t_traits</a>&lt; UnitTypeLhs &gt;::unit_type, <a class="el" href="group___unit_manipulators.html#ga18b87c9f4576fb72ddc0b2a516a42d41">inverse</a>&lt; typename <a class="el" href="structunits_1_1traits_1_1unit__t__traits.html">units::traits::unit_t_traits</a>&lt; UnitTypeRhs &gt;::unit_type &gt;&gt;&gt;</td></tr>
<tr class="memdesc:a39125a4f93db2dba1b0a753ccdb26123"><td class="mdescLeft">&#160;</td><td class="mdescRight">Division for non-convertible <a class="el" href="classunits_1_1unit__t.html" title="Container for values which represent quantities of a given unit. ">unit_t</a> types with a linear scale.  <a href="#a39125a4f93db2dba1b0a753ccdb26123">More...</a><br /></td></tr>
<tr class="separator:a39125a4f93db2dba1b0a753ccdb26123"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b5aa610729119d0758f529ce5f24518"><td class="memTemplParams" colspan="2"><a class="anchor" id="a4b5aa610729119d0758f529ce5f24518"></a>
template&lt;class UnitTypeLhs , typename T , typename std::enable_if&lt; std::is_arithmetic&lt; T &gt;::value &amp;&amp;traits::has_linear_scale&lt; UnitTypeLhs &gt;::value, int &gt;::type  = 0&gt; </td></tr>
<tr class="memitem:a4b5aa610729119d0758f529ce5f24518"><td class="memTemplItemLeft" align="right" valign="top">UnitTypeLhs&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceunits.html#a4b5aa610729119d0758f529ce5f24518">operator/</a> (const UnitTypeLhs &amp;lhs, T rhs)</td></tr>
<tr class="memdesc:a4b5aa610729119d0758f529ce5f24518"><td class="mdescLeft">&#160;</td><td class="mdescRight">Division by a scalar for <a class="el" href="classunits_1_1unit__t.html" title="Container for values which represent quantities of a given unit. ">unit_t</a> types with a linear scale. <br /></td></tr>
<tr class="separator:a4b5aa610729119d0758f529ce5f24518"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac27861c80b392d271ab08dbbe96fa86b"><td class="memTemplParams" colspan="2"><a class="anchor" id="ac27861c80b392d271ab08dbbe96fa86b"></a>
template&lt;class UnitTypeRhs , typename T , typename std::enable_if&lt; std::is_arithmetic&lt; T &gt;::value &amp;&amp;traits::has_linear_scale&lt; UnitTypeRhs &gt;::value, int &gt;::type  = 0&gt; </td></tr>
<tr class="memitem:ac27861c80b392d271ab08dbbe96fa86b"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceunits.html#ac27861c80b392d271ab08dbbe96fa86b">operator/</a> (T lhs, const UnitTypeRhs &amp;rhs) -&gt; <a class="el" href="classunits_1_1unit__t.html">unit_t</a>&lt; <a class="el" href="group___unit_manipulators.html#ga18b87c9f4576fb72ddc0b2a516a42d41">inverse</a>&lt; typename <a class="el" href="structunits_1_1traits_1_1unit__t__traits.html">units::traits::unit_t_traits</a>&lt; UnitTypeRhs &gt;::unit_type &gt;&gt;</td></tr>
<tr class="memdesc:ac27861c80b392d271ab08dbbe96fa86b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Division of a scalar by a <a class="el" href="classunits_1_1unit__t.html" title="Container for values which represent quantities of a given unit. ">unit_t</a> type with a linear scale. <br /></td></tr>
<tr class="separator:ac27861c80b392d271ab08dbbe96fa86b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac62e642ede02f2aa778328427297a374"><td class="memTemplParams" colspan="2"><a class="anchor" id="ac62e642ede02f2aa778328427297a374"></a>
template&lt;typename Units , class  = typename std::enable_if&lt;units::traits::is_scalar_unit&lt;Units&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:ac62e642ede02f2aa778328427297a374"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator==</b> (double lhs, const Units &amp;rhs)</td></tr>
<tr class="separator:ac62e642ede02f2aa778328427297a374"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd15085873584fd7e9555a6b206d3a17"><td class="memTemplParams" colspan="2"><a class="anchor" id="acd15085873584fd7e9555a6b206d3a17"></a>
template&lt;typename Units , class  = typename std::enable_if&lt;units::traits::is_scalar_unit&lt;Units&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:acd15085873584fd7e9555a6b206d3a17"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator==</b> (const Units &amp;lhs, double rhs)</td></tr>
<tr class="separator:acd15085873584fd7e9555a6b206d3a17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a792a71f859154098ca3c931c4622281c"><td class="memTemplParams" colspan="2"><a class="anchor" id="a792a71f859154098ca3c931c4622281c"></a>
template&lt;typename Units , class  = typename std::enable_if&lt;units::traits::is_scalar_unit&lt;Units&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:a792a71f859154098ca3c931c4622281c"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator!=</b> (double lhs, const Units &amp;rhs)</td></tr>
<tr class="separator:a792a71f859154098ca3c931c4622281c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66755145539d113bc92a347371f0bd87"><td class="memTemplParams" colspan="2"><a class="anchor" id="a66755145539d113bc92a347371f0bd87"></a>
template&lt;typename Units , class  = typename std::enable_if&lt;units::traits::is_scalar_unit&lt;Units&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:a66755145539d113bc92a347371f0bd87"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator!=</b> (const Units &amp;lhs, double rhs)</td></tr>
<tr class="separator:a66755145539d113bc92a347371f0bd87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6628ac508b8d7f013505d14db7fe5ab"><td class="memTemplParams" colspan="2"><a class="anchor" id="af6628ac508b8d7f013505d14db7fe5ab"></a>
template&lt;typename Units , class  = typename std::enable_if&lt;units::traits::is_scalar_unit&lt;Units&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:af6628ac508b8d7f013505d14db7fe5ab"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;=</b> (double lhs, const Units &amp;rhs)</td></tr>
<tr class="separator:af6628ac508b8d7f013505d14db7fe5ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab09a2be15a5ed7adb84f58bd9bf873e7"><td class="memTemplParams" colspan="2"><a class="anchor" id="ab09a2be15a5ed7adb84f58bd9bf873e7"></a>
template&lt;typename Units , class  = typename std::enable_if&lt;units::traits::is_scalar_unit&lt;Units&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:ab09a2be15a5ed7adb84f58bd9bf873e7"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;=</b> (const Units &amp;lhs, double rhs)</td></tr>
<tr class="separator:ab09a2be15a5ed7adb84f58bd9bf873e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e32fceb33a81432b9b2bacf35b64ba9"><td class="memTemplParams" colspan="2"><a class="anchor" id="a0e32fceb33a81432b9b2bacf35b64ba9"></a>
template&lt;typename Units , class  = typename std::enable_if&lt;units::traits::is_scalar_unit&lt;Units&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:a0e32fceb33a81432b9b2bacf35b64ba9"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;</b> (double lhs, const Units &amp;rhs)</td></tr>
<tr class="separator:a0e32fceb33a81432b9b2bacf35b64ba9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20be492756d18fb60917f9f3a6fa2462"><td class="memTemplParams" colspan="2"><a class="anchor" id="a20be492756d18fb60917f9f3a6fa2462"></a>
template&lt;typename Units , class  = typename std::enable_if&lt;units::traits::is_scalar_unit&lt;Units&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:a20be492756d18fb60917f9f3a6fa2462"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;</b> (const Units &amp;lhs, double rhs)</td></tr>
<tr class="separator:a20be492756d18fb60917f9f3a6fa2462"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a437f198232fb4984592a8b15954b0e9c"><td class="memTemplParams" colspan="2"><a class="anchor" id="a437f198232fb4984592a8b15954b0e9c"></a>
template&lt;typename Units , class  = typename std::enable_if&lt;units::traits::is_scalar_unit&lt;Units&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:a437f198232fb4984592a8b15954b0e9c"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;=</b> (double lhs, const Units &amp;rhs)</td></tr>
<tr class="separator:a437f198232fb4984592a8b15954b0e9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a20233fbc43c7f5cc4cce44b254ff8d"><td class="memTemplParams" colspan="2"><a class="anchor" id="a3a20233fbc43c7f5cc4cce44b254ff8d"></a>
template&lt;typename Units , class  = typename std::enable_if&lt;units::traits::is_scalar_unit&lt;Units&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:a3a20233fbc43c7f5cc4cce44b254ff8d"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;=</b> (const Units &amp;lhs, double rhs)</td></tr>
<tr class="separator:a3a20233fbc43c7f5cc4cce44b254ff8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e08df5d9973eed8065f05f5481c00a5"><td class="memTemplParams" colspan="2"><a class="anchor" id="a0e08df5d9973eed8065f05f5481c00a5"></a>
template&lt;typename Units , class  = typename std::enable_if&lt;units::traits::is_scalar_unit&lt;Units&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:a0e08df5d9973eed8065f05f5481c00a5"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;</b> (double lhs, const Units &amp;rhs)</td></tr>
<tr class="separator:a0e08df5d9973eed8065f05f5481c00a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95d4a41bcef0e1a9c8eb288f37241bff"><td class="memTemplParams" colspan="2"><a class="anchor" id="a95d4a41bcef0e1a9c8eb288f37241bff"></a>
template&lt;typename Units , class  = typename std::enable_if&lt;units::traits::is_scalar_unit&lt;Units&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:a95d4a41bcef0e1a9c8eb288f37241bff"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;</b> (const Units &amp;lhs, double rhs)</td></tr>
<tr class="separator:a95d4a41bcef0e1a9c8eb288f37241bff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae899f3525c0257aec8ae05e88d7ed9ce"><td class="memTemplParams" colspan="2"><a class="anchor" id="ae899f3525c0257aec8ae05e88d7ed9ce"></a>
template&lt;class UnitTypeLhs , class UnitTypeRhs , typename std::enable_if&lt; traits::has_decibel_scale&lt; UnitTypeLhs, UnitTypeRhs &gt;::value, int &gt;::type  = 0&gt; </td></tr>
<tr class="memitem:ae899f3525c0257aec8ae05e88d7ed9ce"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceunits.html#ae899f3525c0257aec8ae05e88d7ed9ce">operator+</a> (const UnitTypeLhs &amp;lhs, const UnitTypeRhs &amp;rhs) -&gt; <a class="el" href="classunits_1_1unit__t.html">unit_t</a>&lt; <a class="el" href="group___unit_types.html#ga36d8b8cf508bd5ac7854d15f6eaf2d7c">compound_unit</a>&lt; <a class="el" href="group___unit_manipulators.html#ga38048bc5246636a5eb0007262475dc38">squared</a>&lt; typename <a class="el" href="structunits_1_1traits_1_1unit__t__traits.html">units::traits::unit_t_traits</a>&lt; UnitTypeLhs &gt;::unit_type &gt;&gt;, typename <a class="el" href="structunits_1_1traits_1_1unit__t__traits.html">units::traits::unit_t_traits</a>&lt; UnitTypeLhs &gt;::underlying_type, <a class="el" href="structunits_1_1decibel__scale.html">decibel_scale</a> &gt;</td></tr>
<tr class="memdesc:ae899f3525c0257aec8ae05e88d7ed9ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Addition for convertible <a class="el" href="classunits_1_1unit__t.html" title="Container for values which represent quantities of a given unit. ">unit_t</a> types with a <a class="el" href="structunits_1_1decibel__scale.html" title="unit_t scale for representing decibel values. ">decibel_scale</a>. <br /></td></tr>
<tr class="separator:ae899f3525c0257aec8ae05e88d7ed9ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf06dd60e06ef1eed7a1bb57cb548ecb"><td class="memTemplParams" colspan="2"><a class="anchor" id="adf06dd60e06ef1eed7a1bb57cb548ecb"></a>
template&lt;class UnitTypeLhs , typename std::enable_if&lt; traits::has_decibel_scale&lt; UnitTypeLhs &gt;::value &amp;&amp;!traits::is_scalar_unit&lt; UnitTypeLhs &gt;::value, int &gt;::type  = 0&gt; </td></tr>
<tr class="memitem:adf06dd60e06ef1eed7a1bb57cb548ecb"><td class="memTemplItemLeft" align="right" valign="top">UnitTypeLhs&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceunits.html#adf06dd60e06ef1eed7a1bb57cb548ecb">operator+</a> (const UnitTypeLhs &amp;lhs, const <a class="el" href="classunits_1_1unit__t.html">dimensionless::dB_t</a> &amp;rhs)</td></tr>
<tr class="memdesc:adf06dd60e06ef1eed7a1bb57cb548ecb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Addition between <a class="el" href="classunits_1_1unit__t.html" title="Container for values which represent quantities of a given unit. ">unit_t</a> types with a <a class="el" href="structunits_1_1decibel__scale.html" title="unit_t scale for representing decibel values. ">decibel_scale</a> and dimensionless dB units. <br /></td></tr>
<tr class="separator:adf06dd60e06ef1eed7a1bb57cb548ecb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae865c6df51af18fed561ca9b3c270202"><td class="memTemplParams" colspan="2"><a class="anchor" id="ae865c6df51af18fed561ca9b3c270202"></a>
template&lt;class UnitTypeRhs , typename std::enable_if&lt; traits::has_decibel_scale&lt; UnitTypeRhs &gt;::value &amp;&amp;!traits::is_scalar_unit&lt; UnitTypeRhs &gt;::value, int &gt;::type  = 0&gt; </td></tr>
<tr class="memitem:ae865c6df51af18fed561ca9b3c270202"><td class="memTemplItemLeft" align="right" valign="top">UnitTypeRhs&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceunits.html#ae865c6df51af18fed561ca9b3c270202">operator+</a> (const <a class="el" href="classunits_1_1unit__t.html">dimensionless::dB_t</a> &amp;lhs, const UnitTypeRhs &amp;rhs)</td></tr>
<tr class="memdesc:ae865c6df51af18fed561ca9b3c270202"><td class="mdescLeft">&#160;</td><td class="mdescRight">Addition between <a class="el" href="classunits_1_1unit__t.html" title="Container for values which represent quantities of a given unit. ">unit_t</a> types with a <a class="el" href="structunits_1_1decibel__scale.html" title="unit_t scale for representing decibel values. ">decibel_scale</a> and dimensionless dB units. <br /></td></tr>
<tr class="separator:ae865c6df51af18fed561ca9b3c270202"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d01ca2163d9808e6be0f670739a56d9"><td class="memTemplParams" colspan="2"><a class="anchor" id="a8d01ca2163d9808e6be0f670739a56d9"></a>
template&lt;class UnitTypeLhs , class UnitTypeRhs , typename std::enable_if&lt; traits::has_decibel_scale&lt; UnitTypeLhs, UnitTypeRhs &gt;::value, int &gt;::type  = 0&gt; </td></tr>
<tr class="memitem:a8d01ca2163d9808e6be0f670739a56d9"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceunits.html#a8d01ca2163d9808e6be0f670739a56d9">operator-</a> (const UnitTypeLhs &amp;lhs, const UnitTypeRhs &amp;rhs) -&gt; <a class="el" href="classunits_1_1unit__t.html">unit_t</a>&lt; <a class="el" href="group___unit_types.html#ga36d8b8cf508bd5ac7854d15f6eaf2d7c">compound_unit</a>&lt; typename <a class="el" href="structunits_1_1traits_1_1unit__t__traits.html">units::traits::unit_t_traits</a>&lt; UnitTypeLhs &gt;::unit_type, <a class="el" href="group___unit_manipulators.html#ga18b87c9f4576fb72ddc0b2a516a42d41">inverse</a>&lt; typename <a class="el" href="structunits_1_1traits_1_1unit__t__traits.html">units::traits::unit_t_traits</a>&lt; UnitTypeRhs &gt;::unit_type &gt;&gt;, typename <a class="el" href="structunits_1_1traits_1_1unit__t__traits.html">units::traits::unit_t_traits</a>&lt; UnitTypeLhs &gt;::underlying_type, <a class="el" href="structunits_1_1decibel__scale.html">decibel_scale</a> &gt;</td></tr>
<tr class="memdesc:a8d01ca2163d9808e6be0f670739a56d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtraction for convertible <a class="el" href="classunits_1_1unit__t.html" title="Container for values which represent quantities of a given unit. ">unit_t</a> types with a <a class="el" href="structunits_1_1decibel__scale.html" title="unit_t scale for representing decibel values. ">decibel_scale</a>. <br /></td></tr>
<tr class="separator:a8d01ca2163d9808e6be0f670739a56d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38f54d23ecf931ee73d810e1bbace48b"><td class="memTemplParams" colspan="2"><a class="anchor" id="a38f54d23ecf931ee73d810e1bbace48b"></a>
template&lt;class UnitTypeLhs , typename std::enable_if&lt; traits::has_decibel_scale&lt; UnitTypeLhs &gt;::value &amp;&amp;!traits::is_scalar_unit&lt; UnitTypeLhs &gt;::value, int &gt;::type  = 0&gt; </td></tr>
<tr class="memitem:a38f54d23ecf931ee73d810e1bbace48b"><td class="memTemplItemLeft" align="right" valign="top">UnitTypeLhs&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceunits.html#a38f54d23ecf931ee73d810e1bbace48b">operator-</a> (const UnitTypeLhs &amp;lhs, const <a class="el" href="classunits_1_1unit__t.html">dimensionless::dB_t</a> &amp;rhs)</td></tr>
<tr class="memdesc:a38f54d23ecf931ee73d810e1bbace48b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtraction between <a class="el" href="classunits_1_1unit__t.html" title="Container for values which represent quantities of a given unit. ">unit_t</a> types with a <a class="el" href="structunits_1_1decibel__scale.html" title="unit_t scale for representing decibel values. ">decibel_scale</a> and dimensionless dB units. <br /></td></tr>
<tr class="separator:a38f54d23ecf931ee73d810e1bbace48b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a566615d5e2ee82e45e0d3521bc3699bf"><td class="memTemplParams" colspan="2"><a class="anchor" id="a566615d5e2ee82e45e0d3521bc3699bf"></a>
template&lt;class UnitTypeRhs , typename std::enable_if&lt; traits::has_decibel_scale&lt; UnitTypeRhs &gt;::value &amp;&amp;!traits::is_scalar_unit&lt; UnitTypeRhs &gt;::value, int &gt;::type  = 0&gt; </td></tr>
<tr class="memitem:a566615d5e2ee82e45e0d3521bc3699bf"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceunits.html#a566615d5e2ee82e45e0d3521bc3699bf">operator-</a> (const <a class="el" href="classunits_1_1unit__t.html">dimensionless::dB_t</a> &amp;lhs, const UnitTypeRhs &amp;rhs) -&gt; <a class="el" href="classunits_1_1unit__t.html">unit_t</a>&lt; <a class="el" href="group___unit_manipulators.html#ga18b87c9f4576fb72ddc0b2a516a42d41">inverse</a>&lt; typename <a class="el" href="structunits_1_1traits_1_1unit__t__traits.html">units::traits::unit_t_traits</a>&lt; UnitTypeRhs &gt;::unit_type &gt;, typename <a class="el" href="structunits_1_1traits_1_1unit__t__traits.html">units::traits::unit_t_traits</a>&lt; UnitTypeRhs &gt;::underlying_type, <a class="el" href="structunits_1_1decibel__scale.html">decibel_scale</a> &gt;</td></tr>
<tr class="memdesc:a566615d5e2ee82e45e0d3521bc3699bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtraction between <a class="el" href="classunits_1_1unit__t.html" title="Container for values which represent quantities of a given unit. ">unit_t</a> types with a <a class="el" href="structunits_1_1decibel__scale.html" title="unit_t scale for representing decibel values. ">decibel_scale</a> and dimensionless dB units. <br /></td></tr>
<tr class="separator:a566615d5e2ee82e45e0d3521bc3699bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Unit Conversion Library namespace. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="aecb0676083bca2ce81ec8f415879a446"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class UnitTypeLhs , class UnitTypeRhs , typename std::enable_if&lt; traits::is_convertible_unit_t&lt; UnitTypeLhs, UnitTypeRhs &gt;::value &amp;&amp;traits::has_linear_scale&lt; UnitTypeLhs, UnitTypeRhs &gt;::value, int &gt;::type  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto units::operator* </td>
          <td>(</td>
          <td class="paramtype">const UnitTypeLhs &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const UnitTypeRhs &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="classunits_1_1unit__t.html">unit_t</a>&lt;<a class="el" href="group___unit_types.html#ga36d8b8cf508bd5ac7854d15f6eaf2d7c">compound_unit</a>&lt;<a class="el" href="group___unit_manipulators.html#ga38048bc5246636a5eb0007262475dc38">squared</a>&lt;typename <a class="el" href="structunits_1_1traits_1_1unit__t__traits.html">units::traits::unit_t_traits</a>&lt;UnitTypeLhs&gt;::unit_type&gt;&gt;&gt;
	</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplication type for convertible <a class="el" href="classunits_1_1unit__t.html" title="Container for values which represent quantities of a given unit. ">unit_t</a> types with a linear scale. </p>
<dl class="section return"><dt>Returns</dt><dd>the multiplied value, with the same type as left-hand side unit.</dd>
<dd>
the multiplied value, whose type is a compound unit of the left and right hand side values. </dd></dl>

</div>
</div>
<a class="anchor" id="ab25fd921bcae7ad360270801b38ebeaa"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class UnitTypeLhs , class UnitTypeRhs , typename std::enable_if&lt; traits::is_convertible_unit_t&lt; UnitTypeLhs, UnitTypeRhs &gt;::value &amp;&amp;traits::has_linear_scale&lt; UnitTypeLhs, UnitTypeRhs &gt;::value, int &gt;::type  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classunits_1_1unit__t.html">dimensionless::scalar_t</a> units::operator/ </td>
          <td>(</td>
          <td class="paramtype">const UnitTypeLhs &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const UnitTypeRhs &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Division for convertible <a class="el" href="classunits_1_1unit__t.html" title="Container for values which represent quantities of a given unit. ">unit_t</a> types with a linear scale. </p>
<dl class="section return"><dt>Returns</dt><dd>the lhs divided by rhs value, whose type is a scalar </dd></dl>

</div>
</div>
<a class="anchor" id="a39125a4f93db2dba1b0a753ccdb26123"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class UnitTypeLhs , class UnitTypeRhs , typename std::enable_if&lt;!traits::is_convertible_unit_t&lt; UnitTypeLhs, UnitTypeRhs &gt;::value &amp;&amp;traits::has_linear_scale&lt; UnitTypeLhs, UnitTypeRhs &gt;::value, int &gt;::type  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto units::operator/ </td>
          <td>(</td>
          <td class="paramtype">const UnitTypeLhs &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const UnitTypeRhs &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="classunits_1_1unit__t.html">unit_t</a>&lt;<a class="el" href="group___unit_types.html#ga36d8b8cf508bd5ac7854d15f6eaf2d7c">compound_unit</a>&lt;typename <a class="el" href="structunits_1_1traits_1_1unit__t__traits.html">units::traits::unit_t_traits</a>&lt;UnitTypeLhs&gt;::unit_type, <a class="el" href="group___unit_manipulators.html#ga18b87c9f4576fb72ddc0b2a516a42d41">inverse</a>&lt;typename <a class="el" href="structunits_1_1traits_1_1unit__t__traits.html">units::traits::unit_t_traits</a>&lt;UnitTypeRhs&gt;::unit_type&gt;&gt;&gt;
	</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Division for non-convertible <a class="el" href="classunits_1_1unit__t.html" title="Container for values which represent quantities of a given unit. ">unit_t</a> types with a linear scale. </p>
<dl class="section return"><dt>Returns</dt><dd>the lhs divided by the rhs, with a compound unit type of lhs/rhs </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Apr 15 2016 16:49:14 for Unit Conversion and Dimensional Analysis Library by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
