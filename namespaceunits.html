<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.9.1"/>
<title>Unit Conversion and Dimensional Analysis Library: units Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Unit Conversion and Dimensional Analysis Library
   &#160;<span id="projectnumber">2.0.0</span>
   </div>
   <div id="projectbrief">A compile-time c++14 unit conversion library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.9.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>Namespace&#160;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">units Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Unit Conversion Library namespace.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespaceunits_1_1acceleration"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceunits_1_1acceleration.html">acceleration</a></td></tr>
<tr class="memdesc:namespaceunits_1_1acceleration"><td class="mdescLeft">&#160;</td><td class="mdescRight">namespace for unit types and containers representing acceleration values <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceunits_1_1angle"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceunits_1_1angle.html">angle</a></td></tr>
<tr class="memdesc:namespaceunits_1_1angle"><td class="mdescLeft">&#160;</td><td class="mdescRight">namespace for unit types and containers representing angle values <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceunits_1_1angular__velocity"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceunits_1_1angular__velocity.html">angular_velocity</a></td></tr>
<tr class="memdesc:namespaceunits_1_1angular__velocity"><td class="mdescLeft">&#160;</td><td class="mdescRight">namespace for unit types and containers representing angular velocity values <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceunits_1_1area"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceunits_1_1area.html">area</a></td></tr>
<tr class="memdesc:namespaceunits_1_1area"><td class="mdescLeft">&#160;</td><td class="mdescRight">namespace for unit types and containers representing area values <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceunits_1_1capacitance"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceunits_1_1capacitance.html">capacitance</a></td></tr>
<tr class="memdesc:namespaceunits_1_1capacitance"><td class="mdescLeft">&#160;</td><td class="mdescRight">namespace for unit types and containers representing capacitance values <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceunits_1_1category"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceunits_1_1category.html">category</a></td></tr>
<tr class="memdesc:namespaceunits_1_1category"><td class="mdescLeft">&#160;</td><td class="mdescRight">namespace representing the implemented base and derived unit types. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceunits_1_1charge"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceunits_1_1charge.html">charge</a></td></tr>
<tr class="memdesc:namespaceunits_1_1charge"><td class="mdescLeft">&#160;</td><td class="mdescRight">namespace for unit types and containers representing charge values <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceunits_1_1concentration"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceunits_1_1concentration.html">concentration</a></td></tr>
<tr class="memdesc:namespaceunits_1_1concentration"><td class="mdescLeft">&#160;</td><td class="mdescRight">namespace for unit types and containers representing concentration values <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceunits_1_1conductance"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceunits_1_1conductance.html">conductance</a></td></tr>
<tr class="memdesc:namespaceunits_1_1conductance"><td class="mdescLeft">&#160;</td><td class="mdescRight">namespace for unit types and containers representing conductance values <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceunits_1_1constants"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceunits_1_1constants.html">constants</a></td></tr>
<tr class="memdesc:namespaceunits_1_1constants"><td class="mdescLeft">&#160;</td><td class="mdescRight">namespace for physical constants like PI and Avogadro's Number. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceunits_1_1current"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceunits_1_1current.html">current</a></td></tr>
<tr class="memdesc:namespaceunits_1_1current"><td class="mdescLeft">&#160;</td><td class="mdescRight">namespace for unit types and containers representing current values <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceunits_1_1density"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceunits_1_1density.html">density</a></td></tr>
<tr class="memdesc:namespaceunits_1_1density"><td class="mdescLeft">&#160;</td><td class="mdescRight">namespace for unit types and containers representing density values <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceunits_1_1dimensionless"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceunits_1_1dimensionless.html">dimensionless</a></td></tr>
<tr class="memdesc:namespaceunits_1_1dimensionless"><td class="mdescLeft">&#160;</td><td class="mdescRight">namespace for unit types and containers for units that have no dimension (scalar units) <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceunits_1_1energy"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceunits_1_1energy.html">energy</a></td></tr>
<tr class="memdesc:namespaceunits_1_1energy"><td class="mdescLeft">&#160;</td><td class="mdescRight">namespace for unit types and containers representing energy values <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceunits_1_1force"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceunits_1_1force.html">force</a></td></tr>
<tr class="memdesc:namespaceunits_1_1force"><td class="mdescLeft">&#160;</td><td class="mdescRight">namespace for unit types and containers representing force values <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceunits_1_1frequency"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceunits_1_1frequency.html">frequency</a></td></tr>
<tr class="memdesc:namespaceunits_1_1frequency"><td class="mdescLeft">&#160;</td><td class="mdescRight">namespace for unit types and containers representing frequency values <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceunits_1_1illuminance"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceunits_1_1illuminance.html">illuminance</a></td></tr>
<tr class="memdesc:namespaceunits_1_1illuminance"><td class="mdescLeft">&#160;</td><td class="mdescRight">namespace for unit types and containers representing illuminance values <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceunits_1_1impedance"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceunits_1_1impedance.html">impedance</a></td></tr>
<tr class="memdesc:namespaceunits_1_1impedance"><td class="mdescLeft">&#160;</td><td class="mdescRight">namespace for unit types and containers representing impedance values <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceunits_1_1inductance"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceunits_1_1inductance.html">inductance</a></td></tr>
<tr class="memdesc:namespaceunits_1_1inductance"><td class="mdescLeft">&#160;</td><td class="mdescRight">namespace for unit types and containers representing inductance values <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceunits_1_1length"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceunits_1_1length.html">length</a></td></tr>
<tr class="memdesc:namespaceunits_1_1length"><td class="mdescLeft">&#160;</td><td class="mdescRight">namespace for unit types and containers representing length values <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceunits_1_1luminous__flux"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceunits_1_1luminous__flux.html">luminous_flux</a></td></tr>
<tr class="memdesc:namespaceunits_1_1luminous__flux"><td class="mdescLeft">&#160;</td><td class="mdescRight">namespace for unit types and containers representing <a class="el" href="namespaceunits_1_1luminous__flux.html" title="namespace for unit types and containers representing luminous_flux values ">luminous_flux</a> values <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceunits_1_1luminous__intensity"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceunits_1_1luminous__intensity.html">luminous_intensity</a></td></tr>
<tr class="memdesc:namespaceunits_1_1luminous__intensity"><td class="mdescLeft">&#160;</td><td class="mdescRight">namespace for unit types and containers representing <a class="el" href="namespaceunits_1_1luminous__intensity.html" title="namespace for unit types and containers representing luminous_intensity values ">luminous_intensity</a> values <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceunits_1_1magnetic__field__strength"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceunits_1_1magnetic__field__strength.html">magnetic_field_strength</a></td></tr>
<tr class="memdesc:namespaceunits_1_1magnetic__field__strength"><td class="mdescLeft">&#160;</td><td class="mdescRight">namespace for unit types and containers representing <a class="el" href="namespaceunits_1_1magnetic__field__strength.html" title="namespace for unit types and containers representing magnetic_field_strength values ...">magnetic_field_strength</a> values <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceunits_1_1magnetic__flux"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceunits_1_1magnetic__flux.html">magnetic_flux</a></td></tr>
<tr class="memdesc:namespaceunits_1_1magnetic__flux"><td class="mdescLeft">&#160;</td><td class="mdescRight">namespace for unit types and containers representing <a class="el" href="namespaceunits_1_1magnetic__flux.html" title="namespace for unit types and containers representing magnetic_flux values ">magnetic_flux</a> values <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceunits_1_1mass"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceunits_1_1mass.html">mass</a></td></tr>
<tr class="memdesc:namespaceunits_1_1mass"><td class="mdescLeft">&#160;</td><td class="mdescRight">namespace for unit types and containers representing mass values <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceunits_1_1math"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceunits_1_1math.html">math</a></td></tr>
<tr class="memdesc:namespaceunits_1_1math"><td class="mdescLeft">&#160;</td><td class="mdescRight">namespace for unit-enabled versions of the <code>&lt;cmath&gt;</code> library <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceunits_1_1power"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceunits_1_1power.html">power</a></td></tr>
<tr class="memdesc:namespaceunits_1_1power"><td class="mdescLeft">&#160;</td><td class="mdescRight">namespace for unit types and containers representing power values <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceunits_1_1pressure"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceunits_1_1pressure.html">pressure</a></td></tr>
<tr class="memdesc:namespaceunits_1_1pressure"><td class="mdescLeft">&#160;</td><td class="mdescRight">namespace for unit types and containers representing pressure values <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceunits_1_1radiation"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceunits_1_1radiation.html">radiation</a></td></tr>
<tr class="memdesc:namespaceunits_1_1radiation"><td class="mdescLeft">&#160;</td><td class="mdescRight">namespace for unit types and containers representing radiation values <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceunits_1_1solid__angle"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceunits_1_1solid__angle.html">solid_angle</a></td></tr>
<tr class="memdesc:namespaceunits_1_1solid__angle"><td class="mdescLeft">&#160;</td><td class="mdescRight">namespace for unit types and containers representing <a class="el" href="namespaceunits_1_1solid__angle.html" title="namespace for unit types and containers representing solid_angle values ">solid_angle</a> values <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceunits_1_1substance"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceunits_1_1substance.html">substance</a></td></tr>
<tr class="memdesc:namespaceunits_1_1substance"><td class="mdescLeft">&#160;</td><td class="mdescRight">namespace for unit types and containers representing substance values <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceunits_1_1temperature"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceunits_1_1temperature.html">temperature</a></td></tr>
<tr class="memdesc:namespaceunits_1_1temperature"><td class="mdescLeft">&#160;</td><td class="mdescRight">namespace for unit types and containers representing temperature values <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceunits_1_1time"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceunits_1_1time.html">time</a></td></tr>
<tr class="memdesc:namespaceunits_1_1time"><td class="mdescLeft">&#160;</td><td class="mdescRight">namespace for unit types and containers representing time values <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceunits_1_1torque"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceunits_1_1torque.html">torque</a></td></tr>
<tr class="memdesc:namespaceunits_1_1torque"><td class="mdescLeft">&#160;</td><td class="mdescRight">namespace for unit types and containers representing torque values <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceunits_1_1traits"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceunits_1_1traits.html">traits</a></td></tr>
<tr class="memdesc:namespaceunits_1_1traits"><td class="mdescLeft">&#160;</td><td class="mdescRight">namespace representing type traits which can access the properties of types provided by the units library. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceunits_1_1velocity"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceunits_1_1velocity.html">velocity</a></td></tr>
<tr class="memdesc:namespaceunits_1_1velocity"><td class="mdescLeft">&#160;</td><td class="mdescRight">namespace for unit types and containers representing velocity values <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceunits_1_1voltage"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceunits_1_1voltage.html">voltage</a></td></tr>
<tr class="memdesc:namespaceunits_1_1voltage"><td class="mdescLeft">&#160;</td><td class="mdescRight">namespace for unit types and containers representing voltage values <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceunits_1_1volume"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceunits_1_1volume.html">volume</a></td></tr>
<tr class="memdesc:namespaceunits_1_1volume"><td class="mdescLeft">&#160;</td><td class="mdescRight">namespace for unit types and containers representing volume values <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structunits_1_1base__unit.html">base_unit</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class representing SI base unit types.  <a href="structunits_1_1base__unit.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structunits_1_1decibel__scale.html">decibel_scale</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classunits_1_1unit__t.html" title="Container for values which represent quantities of a given unit. ">unit_t</a> scale for representing decibel values.  <a href="structunits_1_1decibel__scale.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structunits_1_1linear__scale.html">linear_scale</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classunits_1_1unit__t.html" title="Container for values which represent quantities of a given unit. ">unit_t</a> scale which is linear  <a href="structunits_1_1linear__scale.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structunits_1_1unit.html">unit</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type representing an arbitrary unit.  <a href="structunits_1_1unit.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classunits_1_1unit__t.html">unit_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Container for values which represent quantities of a given unit.  <a href="classunits_1_1unit__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structunits_1_1unit__value__add.html">unit_value_add</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">adds two <a class="el" href="structunits_1_1unit__value__t.html" title="Stores a rational unit value as a compile-time constant. ">unit_value_t</a> types at compile-time  <a href="structunits_1_1unit__value__add.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structunits_1_1unit__value__divide.html">unit_value_divide</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">divides two <a class="el" href="structunits_1_1unit__value__t.html" title="Stores a rational unit value as a compile-time constant. ">unit_value_t</a> types at compile-time  <a href="structunits_1_1unit__value__divide.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structunits_1_1unit__value__multiply.html">unit_value_multiply</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">multiplies two <a class="el" href="structunits_1_1unit__value__t.html" title="Stores a rational unit value as a compile-time constant. ">unit_value_t</a> types at compile-time  <a href="structunits_1_1unit__value__multiply.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structunits_1_1unit__value__power.html">unit_value_power</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">raises unit_value_to a power at compile-time  <a href="structunits_1_1unit__value__power.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structunits_1_1unit__value__sqrt.html">unit_value_sqrt</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">calculates square root of <a class="el" href="structunits_1_1unit__value__t.html" title="Stores a rational unit value as a compile-time constant. ">unit_value_t</a> at compile-time  <a href="structunits_1_1unit__value__sqrt.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structunits_1_1unit__value__subtract.html">unit_value_subtract</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">subtracts two <a class="el" href="structunits_1_1unit__value__t.html" title="Stores a rational unit value as a compile-time constant. ">unit_value_t</a> types at compile-time  <a href="structunits_1_1unit__value__subtract.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structunits_1_1unit__value__t.html">unit_value_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores a rational unit value as a compile-time constant.  <a href="structunits_1_1unit__value__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:gaacc539ef162e24b260d023d3ff949b57"><td class="memTemplParams" colspan="2">template&lt;class U &gt; </td></tr>
<tr class="memitem:gaacc539ef162e24b260d023d3ff949b57"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___unit_manipulators.html#gaacc539ef162e24b260d023d3ff949b57">inverse</a> = typename detail::inverse_impl&lt; U &gt;::type</td></tr>
<tr class="memdesc:gaacc539ef162e24b260d023d3ff949b57"><td class="mdescLeft">&#160;</td><td class="mdescRight">represents the inverse unit type of <code>class U</code>.  <a href="group___unit_manipulators.html#gaacc539ef162e24b260d023d3ff949b57">More...</a><br /></td></tr>
<tr class="separator:gaacc539ef162e24b260d023d3ff949b57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga636346f7898c35eb98a796bec1d77fb2"><td class="memTemplParams" colspan="2">template&lt;class U &gt; </td></tr>
<tr class="memitem:ga636346f7898c35eb98a796bec1d77fb2"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___unit_manipulators.html#ga636346f7898c35eb98a796bec1d77fb2">squared</a> = typename detail::squared_impl&lt; U &gt;::type</td></tr>
<tr class="memdesc:ga636346f7898c35eb98a796bec1d77fb2"><td class="mdescLeft">&#160;</td><td class="mdescRight">represents the unit type of <code>class U</code> squared  <a href="group___unit_manipulators.html#ga636346f7898c35eb98a796bec1d77fb2">More...</a><br /></td></tr>
<tr class="separator:ga636346f7898c35eb98a796bec1d77fb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad3e94dc693fe45a580b382cb666434a1"><td class="memTemplParams" colspan="2">template&lt;class U &gt; </td></tr>
<tr class="memitem:gad3e94dc693fe45a580b382cb666434a1"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___unit_manipulators.html#gad3e94dc693fe45a580b382cb666434a1">cubed</a> = typename detail::cubed_impl&lt; U &gt;::type</td></tr>
<tr class="memdesc:gad3e94dc693fe45a580b382cb666434a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">represents the type of <code>class U</code> cubed.  <a href="group___unit_manipulators.html#gad3e94dc693fe45a580b382cb666434a1">More...</a><br /></td></tr>
<tr class="separator:gad3e94dc693fe45a580b382cb666434a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga62dd90a825a801e3e29841ed51713693"><td class="memTemplParams" colspan="2">template&lt;typename Ratio , std::intmax_t Eps = 10000000000&gt; </td></tr>
<tr class="memitem:ga62dd90a825a801e3e29841ed51713693"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___type_traits.html#ga62dd90a825a801e3e29841ed51713693">ratio_sqrt</a> = typename detail::Sqrt&lt; Ratio, std::ratio&lt; 1, Eps &gt;&gt;::type</td></tr>
<tr class="memdesc:ga62dd90a825a801e3e29841ed51713693"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate square root of a ratio at compile-time.  <a href="group___type_traits.html#ga62dd90a825a801e3e29841ed51713693">More...</a><br /></td></tr>
<tr class="separator:ga62dd90a825a801e3e29841ed51713693"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga66c5d3d0e80c7c3e56683d7df366b380"><td class="memTemplParams" colspan="2">template&lt;class U , std::intmax_t Eps = 10000000000&gt; </td></tr>
<tr class="memitem:ga66c5d3d0e80c7c3e56683d7df366b380"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___unit_manipulators.html#ga66c5d3d0e80c7c3e56683d7df366b380">square_root</a> = typename detail::sqrt_impl&lt; U, Eps &gt;::type</td></tr>
<tr class="memdesc:ga66c5d3d0e80c7c3e56683d7df366b380"><td class="mdescLeft">&#160;</td><td class="mdescRight">represents the square root of type <code>class U</code>.  <a href="group___unit_manipulators.html#ga66c5d3d0e80c7c3e56683d7df366b380">More...</a><br /></td></tr>
<tr class="separator:ga66c5d3d0e80c7c3e56683d7df366b380"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9c3f6f077dc894620e1ed8358442a8f1"><td class="memTemplParams" colspan="2">template&lt;class U , class... Us&gt; </td></tr>
<tr class="memitem:ga9c3f6f077dc894620e1ed8358442a8f1"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___unit_types.html#ga9c3f6f077dc894620e1ed8358442a8f1">compound_unit</a> = typename detail::compound_impl&lt; U, Us...&gt;::type</td></tr>
<tr class="memdesc:ga9c3f6f077dc894620e1ed8358442a8f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a unit type made up from other units.  <a href="group___unit_types.html#ga9c3f6f077dc894620e1ed8358442a8f1">More...</a><br /></td></tr>
<tr class="separator:ga9c3f6f077dc894620e1ed8358442a8f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ga8a7180c782263384a118dc8ffa5bc689"><td class="memTemplParams" colspan="2">template&lt;class U &gt; </td></tr>
<tr class="memitem:ga8a7180c782263384a118dc8ffa5bc689"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___unit_manipulators.html#ga8a7180c782263384a118dc8ffa5bc689">atto</a> = typename detail::prefix&lt; std::atto, U &gt;::type</td></tr>
<tr class="memdesc:ga8a7180c782263384a118dc8ffa5bc689"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the type of <code>class U</code> with the metric 'atto' prefix appended.  <a href="group___unit_manipulators.html#ga8a7180c782263384a118dc8ffa5bc689">More...</a><br /></td></tr>
<tr class="separator:ga8a7180c782263384a118dc8ffa5bc689"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab3c39c4b3083f6ca59ee0fd0e116f814"><td class="memTemplParams" colspan="2">template&lt;class U &gt; </td></tr>
<tr class="memitem:gab3c39c4b3083f6ca59ee0fd0e116f814"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___unit_manipulators.html#gab3c39c4b3083f6ca59ee0fd0e116f814">femto</a> = typename detail::prefix&lt; std::femto, U &gt;::type</td></tr>
<tr class="memdesc:gab3c39c4b3083f6ca59ee0fd0e116f814"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the type of <code>class U</code> with the metric 'atto' prefix appended.  <a href="group___unit_manipulators.html#gab3c39c4b3083f6ca59ee0fd0e116f814">More...</a><br /></td></tr>
<tr class="separator:gab3c39c4b3083f6ca59ee0fd0e116f814"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga82a8d14a3e0877a375a66b64c45baab9"><td class="memTemplParams" colspan="2">template&lt;class U &gt; </td></tr>
<tr class="memitem:ga82a8d14a3e0877a375a66b64c45baab9"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___unit_manipulators.html#ga82a8d14a3e0877a375a66b64c45baab9">pico</a> = typename detail::prefix&lt; std::pico, U &gt;::type</td></tr>
<tr class="memdesc:ga82a8d14a3e0877a375a66b64c45baab9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the type of <code>class U</code> with the metric 'femto' prefix appended.  <a href="group___unit_manipulators.html#ga82a8d14a3e0877a375a66b64c45baab9">More...</a><br /></td></tr>
<tr class="separator:ga82a8d14a3e0877a375a66b64c45baab9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1c25c3c1d6c1f3aed3fd1ecf043110d5"><td class="memTemplParams" colspan="2">template&lt;class U &gt; </td></tr>
<tr class="memitem:ga1c25c3c1d6c1f3aed3fd1ecf043110d5"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___unit_manipulators.html#ga1c25c3c1d6c1f3aed3fd1ecf043110d5">nano</a> = typename detail::prefix&lt; std::nano, U &gt;::type</td></tr>
<tr class="memdesc:ga1c25c3c1d6c1f3aed3fd1ecf043110d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the type of <code>class U</code> with the metric 'pico' prefix appended.  <a href="group___unit_manipulators.html#ga1c25c3c1d6c1f3aed3fd1ecf043110d5">More...</a><br /></td></tr>
<tr class="separator:ga1c25c3c1d6c1f3aed3fd1ecf043110d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaea53c906ec805110b93f02db4a961971"><td class="memTemplParams" colspan="2">template&lt;class U &gt; </td></tr>
<tr class="memitem:gaea53c906ec805110b93f02db4a961971"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___unit_manipulators.html#gaea53c906ec805110b93f02db4a961971">micro</a> = typename detail::prefix&lt; std::micro, U &gt;::type</td></tr>
<tr class="memdesc:gaea53c906ec805110b93f02db4a961971"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the type of <code>class U</code> with the metric 'nano' prefix appended.  <a href="group___unit_manipulators.html#gaea53c906ec805110b93f02db4a961971">More...</a><br /></td></tr>
<tr class="separator:gaea53c906ec805110b93f02db4a961971"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaec9d1c320e180eb59f3cb3094d8079dd"><td class="memTemplParams" colspan="2">template&lt;class U &gt; </td></tr>
<tr class="memitem:gaec9d1c320e180eb59f3cb3094d8079dd"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___unit_manipulators.html#gaec9d1c320e180eb59f3cb3094d8079dd">milli</a> = typename detail::prefix&lt; std::milli, U &gt;::type</td></tr>
<tr class="memdesc:gaec9d1c320e180eb59f3cb3094d8079dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the type of <code>class U</code> with the metric 'micro' prefix appended.  <a href="group___unit_manipulators.html#gaec9d1c320e180eb59f3cb3094d8079dd">More...</a><br /></td></tr>
<tr class="separator:gaec9d1c320e180eb59f3cb3094d8079dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga33baefb1c4e794428d7ef77467a8b13e"><td class="memTemplParams" colspan="2">template&lt;class U &gt; </td></tr>
<tr class="memitem:ga33baefb1c4e794428d7ef77467a8b13e"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___unit_manipulators.html#ga33baefb1c4e794428d7ef77467a8b13e">centi</a> = typename detail::prefix&lt; std::centi, U &gt;::type</td></tr>
<tr class="memdesc:ga33baefb1c4e794428d7ef77467a8b13e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the type of <code>class U</code> with the metric 'milli' prefix appended.  <a href="group___unit_manipulators.html#ga33baefb1c4e794428d7ef77467a8b13e">More...</a><br /></td></tr>
<tr class="separator:ga33baefb1c4e794428d7ef77467a8b13e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga21c21d358600828a0a49380d9df693b9"><td class="memTemplParams" colspan="2">template&lt;class U &gt; </td></tr>
<tr class="memitem:ga21c21d358600828a0a49380d9df693b9"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___unit_manipulators.html#ga21c21d358600828a0a49380d9df693b9">deci</a> = typename detail::prefix&lt; std::deci, U &gt;::type</td></tr>
<tr class="memdesc:ga21c21d358600828a0a49380d9df693b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the type of <code>class U</code> with the metric 'centi' prefix appended.  <a href="group___unit_manipulators.html#ga21c21d358600828a0a49380d9df693b9">More...</a><br /></td></tr>
<tr class="separator:ga21c21d358600828a0a49380d9df693b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga610922a1098c1f783d7c6972bbfe59f8"><td class="memTemplParams" colspan="2">template&lt;class U &gt; </td></tr>
<tr class="memitem:ga610922a1098c1f783d7c6972bbfe59f8"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___unit_manipulators.html#ga610922a1098c1f783d7c6972bbfe59f8">deca</a> = typename detail::prefix&lt; std::deca, U &gt;::type</td></tr>
<tr class="memdesc:ga610922a1098c1f783d7c6972bbfe59f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the type of <code>class U</code> with the metric 'deci' prefix appended.  <a href="group___unit_manipulators.html#ga610922a1098c1f783d7c6972bbfe59f8">More...</a><br /></td></tr>
<tr class="separator:ga610922a1098c1f783d7c6972bbfe59f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf3fc3cf9567ce9a93f880419c4ddac46"><td class="memTemplParams" colspan="2">template&lt;class U &gt; </td></tr>
<tr class="memitem:gaf3fc3cf9567ce9a93f880419c4ddac46"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___unit_manipulators.html#gaf3fc3cf9567ce9a93f880419c4ddac46">hecto</a> = typename detail::prefix&lt; std::hecto, U &gt;::type</td></tr>
<tr class="memdesc:gaf3fc3cf9567ce9a93f880419c4ddac46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the type of <code>class U</code> with the metric 'deca' prefix appended.  <a href="group___unit_manipulators.html#gaf3fc3cf9567ce9a93f880419c4ddac46">More...</a><br /></td></tr>
<tr class="separator:gaf3fc3cf9567ce9a93f880419c4ddac46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga89965a45aaa6689548b9c53858759c5e"><td class="memTemplParams" colspan="2">template&lt;class U &gt; </td></tr>
<tr class="memitem:ga89965a45aaa6689548b9c53858759c5e"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___unit_manipulators.html#ga89965a45aaa6689548b9c53858759c5e">kilo</a> = typename detail::prefix&lt; std::kilo, U &gt;::type</td></tr>
<tr class="memdesc:ga89965a45aaa6689548b9c53858759c5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the type of <code>class U</code> with the metric 'hecto' prefix appended.  <a href="group___unit_manipulators.html#ga89965a45aaa6689548b9c53858759c5e">More...</a><br /></td></tr>
<tr class="separator:ga89965a45aaa6689548b9c53858759c5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab1e685fcf4dd9478ed3d688f7af50842"><td class="memTemplParams" colspan="2">template&lt;class U &gt; </td></tr>
<tr class="memitem:gab1e685fcf4dd9478ed3d688f7af50842"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___unit_manipulators.html#gab1e685fcf4dd9478ed3d688f7af50842">mega</a> = typename detail::prefix&lt; std::mega, U &gt;::type</td></tr>
<tr class="memdesc:gab1e685fcf4dd9478ed3d688f7af50842"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the type of <code>class U</code> with the metric 'kilo' prefix appended.  <a href="group___unit_manipulators.html#gab1e685fcf4dd9478ed3d688f7af50842">More...</a><br /></td></tr>
<tr class="separator:gab1e685fcf4dd9478ed3d688f7af50842"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4595911f659ef61133216da15d61eb07"><td class="memTemplParams" colspan="2">template&lt;class U &gt; </td></tr>
<tr class="memitem:ga4595911f659ef61133216da15d61eb07"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___unit_manipulators.html#ga4595911f659ef61133216da15d61eb07">giga</a> = typename detail::prefix&lt; std::giga, U &gt;::type</td></tr>
<tr class="memdesc:ga4595911f659ef61133216da15d61eb07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the type of <code>class U</code> with the metric 'mega' prefix appended.  <a href="group___unit_manipulators.html#ga4595911f659ef61133216da15d61eb07">More...</a><br /></td></tr>
<tr class="separator:ga4595911f659ef61133216da15d61eb07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9f187b866f1123e65db38a5fbd745698"><td class="memTemplParams" colspan="2">template&lt;class U &gt; </td></tr>
<tr class="memitem:ga9f187b866f1123e65db38a5fbd745698"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___unit_manipulators.html#ga9f187b866f1123e65db38a5fbd745698">tera</a> = typename detail::prefix&lt; std::tera, U &gt;::type</td></tr>
<tr class="memdesc:ga9f187b866f1123e65db38a5fbd745698"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the type of <code>class U</code> with the metric 'giga' prefix appended.  <a href="group___unit_manipulators.html#ga9f187b866f1123e65db38a5fbd745698">More...</a><br /></td></tr>
<tr class="separator:ga9f187b866f1123e65db38a5fbd745698"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1a39274621859b9e6cf6e7019cd14e47"><td class="memTemplParams" colspan="2">template&lt;class U &gt; </td></tr>
<tr class="memitem:ga1a39274621859b9e6cf6e7019cd14e47"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___unit_manipulators.html#ga1a39274621859b9e6cf6e7019cd14e47">peta</a> = typename detail::prefix&lt; std::peta, U &gt;::type</td></tr>
<tr class="memdesc:ga1a39274621859b9e6cf6e7019cd14e47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the type of <code>class U</code> with the metric 'tera' prefix appended.  <a href="group___unit_manipulators.html#ga1a39274621859b9e6cf6e7019cd14e47">More...</a><br /></td></tr>
<tr class="separator:ga1a39274621859b9e6cf6e7019cd14e47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad0c18c5a47e0fe677715f0328f818515"><td class="memTemplParams" colspan="2">template&lt;class U &gt; </td></tr>
<tr class="memitem:gad0c18c5a47e0fe677715f0328f818515"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___unit_manipulators.html#gad0c18c5a47e0fe677715f0328f818515">exa</a> = typename detail::prefix&lt; std::exa, U &gt;::type</td></tr>
<tr class="memdesc:gad0c18c5a47e0fe677715f0328f818515"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the type of <code>class U</code> with the metric 'peta' prefix appended.  <a href="group___unit_manipulators.html#gad0c18c5a47e0fe677715f0328f818515">More...</a><br /></td></tr>
<tr class="separator:gad0c18c5a47e0fe677715f0328f818515"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gae7541dbcd66420e011c82ac58ef7723c"><td class="memTemplParams" colspan="2">template&lt;class UnitFrom , class UnitTo , typename T  = double&gt; </td></tr>
<tr class="memitem:gae7541dbcd66420e011c82ac58ef7723c"><td class="memTemplItemLeft" align="right" valign="top">static T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___conversion.html#gae7541dbcd66420e011c82ac58ef7723c">convert</a> (const T &amp;value)</td></tr>
<tr class="memdesc:gae7541dbcd66420e011c82ac58ef7723c"><td class="mdescLeft">&#160;</td><td class="mdescRight">converts a <em>value</em> from one type to another.  <a href="group___conversion.html#gae7541dbcd66420e011c82ac58ef7723c">More...</a><br /></td></tr>
<tr class="separator:gae7541dbcd66420e011c82ac58ef7723c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86c838bed1ec47df6357e611aca1ca6a"><td class="memTemplParams" colspan="2"><a class="anchor" id="a86c838bed1ec47df6357e611aca1ca6a"></a>
template&lt;class Units , typename T , template&lt; typename &gt; class NonLinearScale&gt; </td></tr>
<tr class="memitem:a86c838bed1ec47df6357e611aca1ca6a"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;&lt;</b> (std::ostream &amp;os, const <a class="el" href="classunits_1_1unit__t.html">unit_t</a>&lt; Units, T, NonLinearScale &gt; &amp;obj)</td></tr>
<tr class="separator:a86c838bed1ec47df6357e611aca1ca6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d28d681e2cb80d41ee4b4ca0e851f9c"><td class="memTemplParams" colspan="2"><a class="anchor" id="a4d28d681e2cb80d41ee4b4ca0e851f9c"></a>
template&lt;class UnitTypeLhs , class UnitTypeRhs , typename std::enable_if&lt;!traits::is_same_scale&lt; UnitTypeLhs, UnitTypeRhs &gt;::value, int &gt;::type  = 0&gt; </td></tr>
<tr class="memitem:a4d28d681e2cb80d41ee4b4ca0e851f9c"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator+</b> (const UnitTypeLhs &amp;lhs, const UnitTypeRhs &amp;rhs)</td></tr>
<tr class="separator:a4d28d681e2cb80d41ee4b4ca0e851f9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67b2fe0b52dd4cbcee76610289d76ae0"><td class="memTemplParams" colspan="2"><a class="anchor" id="a67b2fe0b52dd4cbcee76610289d76ae0"></a>
template&lt;class UnitTypeLhs , class UnitTypeRhs , typename std::enable_if&lt; traits::has_linear_scale&lt; UnitTypeLhs, UnitTypeRhs &gt;::value, int &gt;::type  = 0&gt; </td></tr>
<tr class="memitem:a67b2fe0b52dd4cbcee76610289d76ae0"><td class="memTemplItemLeft" align="right" valign="top">UnitTypeLhs&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceunits.html#a67b2fe0b52dd4cbcee76610289d76ae0">operator+</a> (const UnitTypeLhs &amp;lhs, const UnitTypeRhs &amp;rhs)</td></tr>
<tr class="memdesc:a67b2fe0b52dd4cbcee76610289d76ae0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Addition operator for <a class="el" href="classunits_1_1unit__t.html" title="Container for values which represent quantities of a given unit. ">unit_t</a> types with a <a class="el" href="structunits_1_1linear__scale.html" title="unit_t scale which is linear ">linear_scale</a>. <br /></td></tr>
<tr class="separator:a67b2fe0b52dd4cbcee76610289d76ae0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab37cafc17a3e78f576c4641015be1f5e"><td class="memTemplParams" colspan="2"><a class="anchor" id="ab37cafc17a3e78f576c4641015be1f5e"></a>
template&lt;typename T , typename std::enable_if&lt; std::is_arithmetic&lt; T &gt;::value, int &gt;::type  = 0&gt; </td></tr>
<tr class="memitem:ab37cafc17a3e78f576c4641015be1f5e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classunits_1_1unit__t.html">dimensionless::scalar_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceunits.html#ab37cafc17a3e78f576c4641015be1f5e">operator+</a> (const <a class="el" href="classunits_1_1unit__t.html">dimensionless::scalar_t</a> &amp;lhs, T rhs)</td></tr>
<tr class="memdesc:ab37cafc17a3e78f576c4641015be1f5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Addition operator for scalar <a class="el" href="classunits_1_1unit__t.html" title="Container for values which represent quantities of a given unit. ">unit_t</a> types with a <a class="el" href="structunits_1_1linear__scale.html" title="unit_t scale which is linear ">linear_scale</a>. Scalar types can be implicitly converted to built-in types. <br /></td></tr>
<tr class="separator:ab37cafc17a3e78f576c4641015be1f5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a185958a6c867e29f7fca92d28922addd"><td class="memTemplParams" colspan="2"><a class="anchor" id="a185958a6c867e29f7fca92d28922addd"></a>
template&lt;typename T , typename std::enable_if&lt; std::is_arithmetic&lt; T &gt;::value, int &gt;::type  = 0&gt; </td></tr>
<tr class="memitem:a185958a6c867e29f7fca92d28922addd"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classunits_1_1unit__t.html">dimensionless::scalar_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceunits.html#a185958a6c867e29f7fca92d28922addd">operator+</a> (T lhs, const <a class="el" href="classunits_1_1unit__t.html">dimensionless::scalar_t</a> &amp;rhs)</td></tr>
<tr class="memdesc:a185958a6c867e29f7fca92d28922addd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Addition operator for scalar <a class="el" href="classunits_1_1unit__t.html" title="Container for values which represent quantities of a given unit. ">unit_t</a> types with a <a class="el" href="structunits_1_1linear__scale.html" title="unit_t scale which is linear ">linear_scale</a>. Scalar types can be implicitly converted to built-in types. <br /></td></tr>
<tr class="separator:a185958a6c867e29f7fca92d28922addd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad741c4cf191609a83e6301dcab5af401"><td class="memTemplParams" colspan="2"><a class="anchor" id="ad741c4cf191609a83e6301dcab5af401"></a>
template&lt;class UnitTypeLhs , class UnitTypeRhs , typename std::enable_if&lt; traits::has_linear_scale&lt; UnitTypeLhs, UnitTypeRhs &gt;::value, int &gt;::type  = 0&gt; </td></tr>
<tr class="memitem:ad741c4cf191609a83e6301dcab5af401"><td class="memTemplItemLeft" align="right" valign="top">UnitTypeLhs&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceunits.html#ad741c4cf191609a83e6301dcab5af401">operator-</a> (const UnitTypeLhs &amp;lhs, const UnitTypeRhs &amp;rhs)</td></tr>
<tr class="memdesc:ad741c4cf191609a83e6301dcab5af401"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtraction operator for <a class="el" href="classunits_1_1unit__t.html" title="Container for values which represent quantities of a given unit. ">unit_t</a> types with a <a class="el" href="structunits_1_1linear__scale.html" title="unit_t scale which is linear ">linear_scale</a>. <br /></td></tr>
<tr class="separator:ad741c4cf191609a83e6301dcab5af401"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7e9eb5238fdd174f781e07982a5b1e5"><td class="memTemplParams" colspan="2"><a class="anchor" id="ab7e9eb5238fdd174f781e07982a5b1e5"></a>
template&lt;typename T , typename std::enable_if&lt; std::is_arithmetic&lt; T &gt;::value, int &gt;::type  = 0&gt; </td></tr>
<tr class="memitem:ab7e9eb5238fdd174f781e07982a5b1e5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classunits_1_1unit__t.html">dimensionless::scalar_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceunits.html#ab7e9eb5238fdd174f781e07982a5b1e5">operator-</a> (const <a class="el" href="classunits_1_1unit__t.html">dimensionless::scalar_t</a> &amp;lhs, T rhs)</td></tr>
<tr class="memdesc:ab7e9eb5238fdd174f781e07982a5b1e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtraction operator for scalar <a class="el" href="classunits_1_1unit__t.html" title="Container for values which represent quantities of a given unit. ">unit_t</a> types with a <a class="el" href="structunits_1_1linear__scale.html" title="unit_t scale which is linear ">linear_scale</a>. Scalar types can be implicitly converted to built-in types. <br /></td></tr>
<tr class="separator:ab7e9eb5238fdd174f781e07982a5b1e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60fc90c20e60aed63820ef98427785d6"><td class="memTemplParams" colspan="2"><a class="anchor" id="a60fc90c20e60aed63820ef98427785d6"></a>
template&lt;typename T , typename std::enable_if&lt; std::is_arithmetic&lt; T &gt;::value, int &gt;::type  = 0&gt; </td></tr>
<tr class="memitem:a60fc90c20e60aed63820ef98427785d6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classunits_1_1unit__t.html">dimensionless::scalar_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceunits.html#a60fc90c20e60aed63820ef98427785d6">operator-</a> (T lhs, const <a class="el" href="classunits_1_1unit__t.html">dimensionless::scalar_t</a> &amp;rhs)</td></tr>
<tr class="memdesc:a60fc90c20e60aed63820ef98427785d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtraction operator for scalar <a class="el" href="classunits_1_1unit__t.html" title="Container for values which represent quantities of a given unit. ">unit_t</a> types with a <a class="el" href="structunits_1_1linear__scale.html" title="unit_t scale which is linear ">linear_scale</a>. Scalar types can be implicitly converted to built-in types. <br /></td></tr>
<tr class="separator:a60fc90c20e60aed63820ef98427785d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d67221c61e6c955fb24dd97053cb0ba"><td class="memTemplParams" colspan="2">template&lt;class UnitTypeLhs , class UnitTypeRhs , typename std::enable_if&lt; traits::is_convertible_unit_t&lt; UnitTypeLhs, UnitTypeRhs &gt;::value &amp;&amp;traits::has_linear_scale&lt; UnitTypeLhs, UnitTypeRhs &gt;::value, int &gt;::type  = 0&gt; </td></tr>
<tr class="memitem:a3d67221c61e6c955fb24dd97053cb0ba"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceunits.html#a3d67221c61e6c955fb24dd97053cb0ba">operator*</a> (const UnitTypeLhs &amp;lhs, const UnitTypeRhs &amp;rhs) -&gt; <a class="el" href="classunits_1_1unit__t.html">unit_t</a>&lt; <a class="el" href="group___unit_types.html#ga9c3f6f077dc894620e1ed8358442a8f1">compound_unit</a>&lt; <a class="el" href="group___unit_manipulators.html#ga636346f7898c35eb98a796bec1d77fb2">squared</a>&lt; typename <a class="el" href="structunits_1_1traits_1_1unit__t__traits.html">traits::unit_t_traits</a>&lt; UnitTypeLhs &gt;::unit_type &gt;&gt;&gt;</td></tr>
<tr class="memdesc:a3d67221c61e6c955fb24dd97053cb0ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication type for convertible <a class="el" href="classunits_1_1unit__t.html" title="Container for values which represent quantities of a given unit. ">unit_t</a> types with a linear scale.  <a href="#a3d67221c61e6c955fb24dd97053cb0ba">More...</a><br /></td></tr>
<tr class="separator:a3d67221c61e6c955fb24dd97053cb0ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1331b4001873d72d2720c91c9466f62f"><td class="memTemplParams" colspan="2"><a class="anchor" id="a1331b4001873d72d2720c91c9466f62f"></a>
template&lt;class UnitTypeLhs , typename T , typename std::enable_if&lt; std::is_arithmetic&lt; T &gt;::value &amp;&amp;traits::has_linear_scale&lt; UnitTypeLhs &gt;::value, int &gt;::type  = 0&gt; </td></tr>
<tr class="memitem:a1331b4001873d72d2720c91c9466f62f"><td class="memTemplItemLeft" align="right" valign="top">UnitTypeLhs&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceunits.html#a1331b4001873d72d2720c91c9466f62f">operator*</a> (const UnitTypeLhs &amp;lhs, T rhs)</td></tr>
<tr class="memdesc:a1331b4001873d72d2720c91c9466f62f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication by a scalar for <a class="el" href="classunits_1_1unit__t.html" title="Container for values which represent quantities of a given unit. ">unit_t</a> types with a linear scale. <br /></td></tr>
<tr class="separator:a1331b4001873d72d2720c91c9466f62f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89703f136d140a037e83d384b868e326"><td class="memTemplParams" colspan="2"><a class="anchor" id="a89703f136d140a037e83d384b868e326"></a>
template&lt;class UnitTypeRhs , typename T , typename std::enable_if&lt; std::is_arithmetic&lt; T &gt;::value &amp;&amp;traits::has_linear_scale&lt; UnitTypeRhs &gt;::value, int &gt;::type  = 0&gt; </td></tr>
<tr class="memitem:a89703f136d140a037e83d384b868e326"><td class="memTemplItemLeft" align="right" valign="top">UnitTypeRhs&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceunits.html#a89703f136d140a037e83d384b868e326">operator*</a> (T lhs, const UnitTypeRhs &amp;rhs)</td></tr>
<tr class="memdesc:a89703f136d140a037e83d384b868e326"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication by a scalar for <a class="el" href="classunits_1_1unit__t.html" title="Container for values which represent quantities of a given unit. ">unit_t</a> types with a linear scale. <br /></td></tr>
<tr class="separator:a89703f136d140a037e83d384b868e326"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab25fd921bcae7ad360270801b38ebeaa"><td class="memTemplParams" colspan="2">template&lt;class UnitTypeLhs , class UnitTypeRhs , typename std::enable_if&lt; traits::is_convertible_unit_t&lt; UnitTypeLhs, UnitTypeRhs &gt;::value &amp;&amp;traits::has_linear_scale&lt; UnitTypeLhs, UnitTypeRhs &gt;::value, int &gt;::type  = 0&gt; </td></tr>
<tr class="memitem:ab25fd921bcae7ad360270801b38ebeaa"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classunits_1_1unit__t.html">dimensionless::scalar_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceunits.html#ab25fd921bcae7ad360270801b38ebeaa">operator/</a> (const UnitTypeLhs &amp;lhs, const UnitTypeRhs &amp;rhs)</td></tr>
<tr class="memdesc:ab25fd921bcae7ad360270801b38ebeaa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Division for convertible <a class="el" href="classunits_1_1unit__t.html" title="Container for values which represent quantities of a given unit. ">unit_t</a> types with a linear scale.  <a href="#ab25fd921bcae7ad360270801b38ebeaa">More...</a><br /></td></tr>
<tr class="separator:ab25fd921bcae7ad360270801b38ebeaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac32647919236d14893b4cf82d07a9357"><td class="memTemplParams" colspan="2">template&lt;class UnitTypeLhs , class UnitTypeRhs , typename std::enable_if&lt;!traits::is_convertible_unit_t&lt; UnitTypeLhs, UnitTypeRhs &gt;::value &amp;&amp;traits::has_linear_scale&lt; UnitTypeLhs, UnitTypeRhs &gt;::value, int &gt;::type  = 0&gt; </td></tr>
<tr class="memitem:ac32647919236d14893b4cf82d07a9357"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceunits.html#ac32647919236d14893b4cf82d07a9357">operator/</a> (const UnitTypeLhs &amp;lhs, const UnitTypeRhs &amp;rhs) -&gt; <a class="el" href="classunits_1_1unit__t.html">unit_t</a>&lt; <a class="el" href="group___unit_types.html#ga9c3f6f077dc894620e1ed8358442a8f1">compound_unit</a>&lt; typename <a class="el" href="structunits_1_1traits_1_1unit__t__traits.html">traits::unit_t_traits</a>&lt; UnitTypeLhs &gt;::unit_type, <a class="el" href="group___unit_manipulators.html#gaacc539ef162e24b260d023d3ff949b57">inverse</a>&lt; typename <a class="el" href="structunits_1_1traits_1_1unit__t__traits.html">traits::unit_t_traits</a>&lt; UnitTypeRhs &gt;::unit_type &gt;&gt;&gt;</td></tr>
<tr class="memdesc:ac32647919236d14893b4cf82d07a9357"><td class="mdescLeft">&#160;</td><td class="mdescRight">Division for non-convertible <a class="el" href="classunits_1_1unit__t.html" title="Container for values which represent quantities of a given unit. ">unit_t</a> types with a linear scale.  <a href="#ac32647919236d14893b4cf82d07a9357">More...</a><br /></td></tr>
<tr class="separator:ac32647919236d14893b4cf82d07a9357"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b5aa610729119d0758f529ce5f24518"><td class="memTemplParams" colspan="2"><a class="anchor" id="a4b5aa610729119d0758f529ce5f24518"></a>
template&lt;class UnitTypeLhs , typename T , typename std::enable_if&lt; std::is_arithmetic&lt; T &gt;::value &amp;&amp;traits::has_linear_scale&lt; UnitTypeLhs &gt;::value, int &gt;::type  = 0&gt; </td></tr>
<tr class="memitem:a4b5aa610729119d0758f529ce5f24518"><td class="memTemplItemLeft" align="right" valign="top">UnitTypeLhs&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceunits.html#a4b5aa610729119d0758f529ce5f24518">operator/</a> (const UnitTypeLhs &amp;lhs, T rhs)</td></tr>
<tr class="memdesc:a4b5aa610729119d0758f529ce5f24518"><td class="mdescLeft">&#160;</td><td class="mdescRight">Division by a scalar for <a class="el" href="classunits_1_1unit__t.html" title="Container for values which represent quantities of a given unit. ">unit_t</a> types with a linear scale. <br /></td></tr>
<tr class="separator:a4b5aa610729119d0758f529ce5f24518"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88bc970d8a608586597c43a6b947c644"><td class="memTemplParams" colspan="2"><a class="anchor" id="a88bc970d8a608586597c43a6b947c644"></a>
template&lt;class UnitTypeRhs , typename T , typename std::enable_if&lt; std::is_arithmetic&lt; T &gt;::value &amp;&amp;traits::has_linear_scale&lt; UnitTypeRhs &gt;::value, int &gt;::type  = 0&gt; </td></tr>
<tr class="memitem:a88bc970d8a608586597c43a6b947c644"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceunits.html#a88bc970d8a608586597c43a6b947c644">operator/</a> (T lhs, const UnitTypeRhs &amp;rhs) -&gt; <a class="el" href="classunits_1_1unit__t.html">unit_t</a>&lt; <a class="el" href="group___unit_manipulators.html#gaacc539ef162e24b260d023d3ff949b57">inverse</a>&lt; typename <a class="el" href="structunits_1_1traits_1_1unit__t__traits.html">traits::unit_t_traits</a>&lt; UnitTypeRhs &gt;::unit_type &gt;&gt;</td></tr>
<tr class="memdesc:a88bc970d8a608586597c43a6b947c644"><td class="mdescLeft">&#160;</td><td class="mdescRight">Division of a scalar by a <a class="el" href="classunits_1_1unit__t.html" title="Container for values which represent quantities of a given unit. ">unit_t</a> type with a linear scale. <br /></td></tr>
<tr class="separator:a88bc970d8a608586597c43a6b947c644"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a150c1d13f1414ebbd4eb9c75c29d2f37"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a150c1d13f1414ebbd4eb9c75c29d2f37"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator==</b> (double lhs, const <a class="el" href="classunits_1_1unit__t.html">dimensionless::scalar_t</a> &amp;rhs)</td></tr>
<tr class="separator:a150c1d13f1414ebbd4eb9c75c29d2f37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0fb7d4574e1a2f82d573958d8e4cbe3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad0fb7d4574e1a2f82d573958d8e4cbe3"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator==</b> (const <a class="el" href="classunits_1_1unit__t.html">dimensionless::scalar_t</a> &amp;lhs, double rhs)</td></tr>
<tr class="separator:ad0fb7d4574e1a2f82d573958d8e4cbe3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2af67bb118928918c5b97bab43f8eb8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab2af67bb118928918c5b97bab43f8eb8"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator!=</b> (double lhs, const <a class="el" href="classunits_1_1unit__t.html">dimensionless::scalar_t</a> &amp;rhs)</td></tr>
<tr class="separator:ab2af67bb118928918c5b97bab43f8eb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac72cf6e1978a9be631c95d84df128f65"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac72cf6e1978a9be631c95d84df128f65"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator!=</b> (const <a class="el" href="classunits_1_1unit__t.html">dimensionless::scalar_t</a> &amp;lhs, double rhs)</td></tr>
<tr class="separator:ac72cf6e1978a9be631c95d84df128f65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11d1606e46e95ed9fc8fd58019446e34"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a11d1606e46e95ed9fc8fd58019446e34"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator&gt;=</b> (double lhs, const <a class="el" href="classunits_1_1unit__t.html">dimensionless::scalar_t</a> &amp;rhs)</td></tr>
<tr class="separator:a11d1606e46e95ed9fc8fd58019446e34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5b1cb8ea6d39cdabe0216cbdd71f2a5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae5b1cb8ea6d39cdabe0216cbdd71f2a5"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator&gt;=</b> (const <a class="el" href="classunits_1_1unit__t.html">dimensionless::scalar_t</a> &amp;lhs, double rhs)</td></tr>
<tr class="separator:ae5b1cb8ea6d39cdabe0216cbdd71f2a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57fd46e74e12a209cfe126906f5ca39d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a57fd46e74e12a209cfe126906f5ca39d"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator&gt;</b> (double lhs, const <a class="el" href="classunits_1_1unit__t.html">dimensionless::scalar_t</a> &amp;rhs)</td></tr>
<tr class="separator:a57fd46e74e12a209cfe126906f5ca39d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af44463877cdb370f1f8a306ef9a78aa8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af44463877cdb370f1f8a306ef9a78aa8"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator&gt;</b> (const <a class="el" href="classunits_1_1unit__t.html">dimensionless::scalar_t</a> &amp;lhs, double rhs)</td></tr>
<tr class="separator:af44463877cdb370f1f8a306ef9a78aa8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29f05d6980d76f6d15e41f5f698cc9dc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a29f05d6980d76f6d15e41f5f698cc9dc"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;=</b> (double lhs, const <a class="el" href="classunits_1_1unit__t.html">dimensionless::scalar_t</a> &amp;rhs)</td></tr>
<tr class="separator:a29f05d6980d76f6d15e41f5f698cc9dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6edc757d8bf05fa01299dd47959537f2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6edc757d8bf05fa01299dd47959537f2"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;=</b> (const <a class="el" href="classunits_1_1unit__t.html">dimensionless::scalar_t</a> &amp;lhs, double rhs)</td></tr>
<tr class="separator:a6edc757d8bf05fa01299dd47959537f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf632a607c4b4bd61e53f2773802a79b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adf632a607c4b4bd61e53f2773802a79b"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;</b> (double lhs, const <a class="el" href="classunits_1_1unit__t.html">dimensionless::scalar_t</a> &amp;rhs)</td></tr>
<tr class="separator:adf632a607c4b4bd61e53f2773802a79b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26f492bedf875f41c348fe9c182ef94d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a26f492bedf875f41c348fe9c182ef94d"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;</b> (const <a class="el" href="classunits_1_1unit__t.html">dimensionless::scalar_t</a> &amp;lhs, double rhs)</td></tr>
<tr class="separator:a26f492bedf875f41c348fe9c182ef94d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a488c7b98d0a88d36d584354ed7de0c09"><td class="memTemplParams" colspan="2"><a class="anchor" id="a488c7b98d0a88d36d584354ed7de0c09"></a>
template&lt;class UnitTypeLhs , class UnitTypeRhs , typename std::enable_if&lt; traits::has_decibel_scale&lt; UnitTypeLhs, UnitTypeRhs &gt;::value, int &gt;::type  = 0&gt; </td></tr>
<tr class="memitem:a488c7b98d0a88d36d584354ed7de0c09"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceunits.html#a488c7b98d0a88d36d584354ed7de0c09">operator+</a> (const UnitTypeLhs &amp;lhs, const UnitTypeRhs &amp;rhs) -&gt; <a class="el" href="classunits_1_1unit__t.html">unit_t</a>&lt; <a class="el" href="group___unit_types.html#ga9c3f6f077dc894620e1ed8358442a8f1">compound_unit</a>&lt; <a class="el" href="group___unit_manipulators.html#ga636346f7898c35eb98a796bec1d77fb2">squared</a>&lt; typename <a class="el" href="structunits_1_1traits_1_1unit__t__traits.html">traits::unit_t_traits</a>&lt; UnitTypeLhs &gt;::unit_type &gt;&gt;, typename <a class="el" href="structunits_1_1traits_1_1unit__t__traits.html">traits::unit_t_traits</a>&lt; UnitTypeLhs &gt;::underlying_type, <a class="el" href="structunits_1_1decibel__scale.html">decibel_scale</a> &gt;</td></tr>
<tr class="memdesc:a488c7b98d0a88d36d584354ed7de0c09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Addition for convertible <a class="el" href="classunits_1_1unit__t.html" title="Container for values which represent quantities of a given unit. ">unit_t</a> types with a <a class="el" href="structunits_1_1decibel__scale.html" title="unit_t scale for representing decibel values. ">decibel_scale</a>. <br /></td></tr>
<tr class="separator:a488c7b98d0a88d36d584354ed7de0c09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf06dd60e06ef1eed7a1bb57cb548ecb"><td class="memTemplParams" colspan="2"><a class="anchor" id="adf06dd60e06ef1eed7a1bb57cb548ecb"></a>
template&lt;class UnitTypeLhs , typename std::enable_if&lt; traits::has_decibel_scale&lt; UnitTypeLhs &gt;::value &amp;&amp;!traits::is_scalar_unit&lt; UnitTypeLhs &gt;::value, int &gt;::type  = 0&gt; </td></tr>
<tr class="memitem:adf06dd60e06ef1eed7a1bb57cb548ecb"><td class="memTemplItemLeft" align="right" valign="top">UnitTypeLhs&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceunits.html#adf06dd60e06ef1eed7a1bb57cb548ecb">operator+</a> (const UnitTypeLhs &amp;lhs, const <a class="el" href="classunits_1_1unit__t.html">dimensionless::dB_t</a> &amp;rhs)</td></tr>
<tr class="memdesc:adf06dd60e06ef1eed7a1bb57cb548ecb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Addition between <a class="el" href="classunits_1_1unit__t.html" title="Container for values which represent quantities of a given unit. ">unit_t</a> types with a <a class="el" href="structunits_1_1decibel__scale.html" title="unit_t scale for representing decibel values. ">decibel_scale</a> and dimensionless dB units. <br /></td></tr>
<tr class="separator:adf06dd60e06ef1eed7a1bb57cb548ecb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae865c6df51af18fed561ca9b3c270202"><td class="memTemplParams" colspan="2"><a class="anchor" id="ae865c6df51af18fed561ca9b3c270202"></a>
template&lt;class UnitTypeRhs , typename std::enable_if&lt; traits::has_decibel_scale&lt; UnitTypeRhs &gt;::value &amp;&amp;!traits::is_scalar_unit&lt; UnitTypeRhs &gt;::value, int &gt;::type  = 0&gt; </td></tr>
<tr class="memitem:ae865c6df51af18fed561ca9b3c270202"><td class="memTemplItemLeft" align="right" valign="top">UnitTypeRhs&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceunits.html#ae865c6df51af18fed561ca9b3c270202">operator+</a> (const <a class="el" href="classunits_1_1unit__t.html">dimensionless::dB_t</a> &amp;lhs, const UnitTypeRhs &amp;rhs)</td></tr>
<tr class="memdesc:ae865c6df51af18fed561ca9b3c270202"><td class="mdescLeft">&#160;</td><td class="mdescRight">Addition between <a class="el" href="classunits_1_1unit__t.html" title="Container for values which represent quantities of a given unit. ">unit_t</a> types with a <a class="el" href="structunits_1_1decibel__scale.html" title="unit_t scale for representing decibel values. ">decibel_scale</a> and dimensionless dB units. <br /></td></tr>
<tr class="separator:ae865c6df51af18fed561ca9b3c270202"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3bd152cb3657ecbd02f3d21d6599d62"><td class="memTemplParams" colspan="2"><a class="anchor" id="aa3bd152cb3657ecbd02f3d21d6599d62"></a>
template&lt;class UnitTypeLhs , class UnitTypeRhs , typename std::enable_if&lt; traits::has_decibel_scale&lt; UnitTypeLhs, UnitTypeRhs &gt;::value, int &gt;::type  = 0&gt; </td></tr>
<tr class="memitem:aa3bd152cb3657ecbd02f3d21d6599d62"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceunits.html#aa3bd152cb3657ecbd02f3d21d6599d62">operator-</a> (const UnitTypeLhs &amp;lhs, const UnitTypeRhs &amp;rhs) -&gt; <a class="el" href="classunits_1_1unit__t.html">unit_t</a>&lt; <a class="el" href="group___unit_types.html#ga9c3f6f077dc894620e1ed8358442a8f1">compound_unit</a>&lt; typename <a class="el" href="structunits_1_1traits_1_1unit__t__traits.html">traits::unit_t_traits</a>&lt; UnitTypeLhs &gt;::unit_type, <a class="el" href="group___unit_manipulators.html#gaacc539ef162e24b260d023d3ff949b57">inverse</a>&lt; typename <a class="el" href="structunits_1_1traits_1_1unit__t__traits.html">traits::unit_t_traits</a>&lt; UnitTypeRhs &gt;::unit_type &gt;&gt;, typename <a class="el" href="structunits_1_1traits_1_1unit__t__traits.html">traits::unit_t_traits</a>&lt; UnitTypeLhs &gt;::underlying_type, <a class="el" href="structunits_1_1decibel__scale.html">decibel_scale</a> &gt;</td></tr>
<tr class="memdesc:aa3bd152cb3657ecbd02f3d21d6599d62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtraction for convertible <a class="el" href="classunits_1_1unit__t.html" title="Container for values which represent quantities of a given unit. ">unit_t</a> types with a <a class="el" href="structunits_1_1decibel__scale.html" title="unit_t scale for representing decibel values. ">decibel_scale</a>. <br /></td></tr>
<tr class="separator:aa3bd152cb3657ecbd02f3d21d6599d62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38f54d23ecf931ee73d810e1bbace48b"><td class="memTemplParams" colspan="2"><a class="anchor" id="a38f54d23ecf931ee73d810e1bbace48b"></a>
template&lt;class UnitTypeLhs , typename std::enable_if&lt; traits::has_decibel_scale&lt; UnitTypeLhs &gt;::value &amp;&amp;!traits::is_scalar_unit&lt; UnitTypeLhs &gt;::value, int &gt;::type  = 0&gt; </td></tr>
<tr class="memitem:a38f54d23ecf931ee73d810e1bbace48b"><td class="memTemplItemLeft" align="right" valign="top">UnitTypeLhs&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceunits.html#a38f54d23ecf931ee73d810e1bbace48b">operator-</a> (const UnitTypeLhs &amp;lhs, const <a class="el" href="classunits_1_1unit__t.html">dimensionless::dB_t</a> &amp;rhs)</td></tr>
<tr class="memdesc:a38f54d23ecf931ee73d810e1bbace48b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtraction between <a class="el" href="classunits_1_1unit__t.html" title="Container for values which represent quantities of a given unit. ">unit_t</a> types with a <a class="el" href="structunits_1_1decibel__scale.html" title="unit_t scale for representing decibel values. ">decibel_scale</a> and dimensionless dB units. <br /></td></tr>
<tr class="separator:a38f54d23ecf931ee73d810e1bbace48b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24c569dc5b4fe1aca6ff343e77886b90"><td class="memTemplParams" colspan="2"><a class="anchor" id="a24c569dc5b4fe1aca6ff343e77886b90"></a>
template&lt;class UnitTypeRhs , typename std::enable_if&lt; traits::has_decibel_scale&lt; UnitTypeRhs &gt;::value &amp;&amp;!traits::is_scalar_unit&lt; UnitTypeRhs &gt;::value, int &gt;::type  = 0&gt; </td></tr>
<tr class="memitem:a24c569dc5b4fe1aca6ff343e77886b90"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceunits.html#a24c569dc5b4fe1aca6ff343e77886b90">operator-</a> (const <a class="el" href="classunits_1_1unit__t.html">dimensionless::dB_t</a> &amp;lhs, const UnitTypeRhs &amp;rhs) -&gt; <a class="el" href="classunits_1_1unit__t.html">unit_t</a>&lt; <a class="el" href="group___unit_manipulators.html#gaacc539ef162e24b260d023d3ff949b57">inverse</a>&lt; typename <a class="el" href="structunits_1_1traits_1_1unit__t__traits.html">traits::unit_t_traits</a>&lt; UnitTypeRhs &gt;::unit_type &gt;, typename <a class="el" href="structunits_1_1traits_1_1unit__t__traits.html">traits::unit_t_traits</a>&lt; UnitTypeRhs &gt;::underlying_type, <a class="el" href="structunits_1_1decibel__scale.html">decibel_scale</a> &gt;</td></tr>
<tr class="memdesc:a24c569dc5b4fe1aca6ff343e77886b90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtraction between <a class="el" href="classunits_1_1unit__t.html" title="Container for values which represent quantities of a given unit. ">unit_t</a> types with a <a class="el" href="structunits_1_1decibel__scale.html" title="unit_t scale for representing decibel values. ">decibel_scale</a> and dimensionless dB units. <br /></td></tr>
<tr class="separator:a24c569dc5b4fe1aca6ff343e77886b90"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Unit Conversion Library namespace. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="a3d67221c61e6c955fb24dd97053cb0ba"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class UnitTypeLhs , class UnitTypeRhs , typename std::enable_if&lt; traits::is_convertible_unit_t&lt; UnitTypeLhs, UnitTypeRhs &gt;::value &amp;&amp;traits::has_linear_scale&lt; UnitTypeLhs, UnitTypeRhs &gt;::value, int &gt;::type  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto units::operator* </td>
          <td>(</td>
          <td class="paramtype">const UnitTypeLhs &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const UnitTypeRhs &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="classunits_1_1unit__t.html">unit_t</a>&lt;<a class="el" href="group___unit_types.html#ga9c3f6f077dc894620e1ed8358442a8f1">compound_unit</a>&lt;<a class="el" href="group___unit_manipulators.html#ga636346f7898c35eb98a796bec1d77fb2">squared</a>&lt;typename <a class="el" href="structunits_1_1traits_1_1unit__t__traits.html">traits::unit_t_traits</a>&lt;UnitTypeLhs&gt;::unit_type&gt;&gt;&gt;
	</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplication type for convertible <a class="el" href="classunits_1_1unit__t.html" title="Container for values which represent quantities of a given unit. ">unit_t</a> types with a linear scale. </p>
<dl class="section return"><dt>Returns</dt><dd>the multiplied value, with the same type as left-hand side unit.</dd>
<dd>
the multiplied value, whose type is a compound unit of the left and right hand side values. </dd></dl>

</div>
</div>
<a class="anchor" id="ab25fd921bcae7ad360270801b38ebeaa"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class UnitTypeLhs , class UnitTypeRhs , typename std::enable_if&lt; traits::is_convertible_unit_t&lt; UnitTypeLhs, UnitTypeRhs &gt;::value &amp;&amp;traits::has_linear_scale&lt; UnitTypeLhs, UnitTypeRhs &gt;::value, int &gt;::type  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classunits_1_1unit__t.html">dimensionless::scalar_t</a> units::operator/ </td>
          <td>(</td>
          <td class="paramtype">const UnitTypeLhs &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const UnitTypeRhs &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Division for convertible <a class="el" href="classunits_1_1unit__t.html" title="Container for values which represent quantities of a given unit. ">unit_t</a> types with a linear scale. </p>
<dl class="section return"><dt>Returns</dt><dd>the lhs divided by rhs value, whose type is a scalar </dd></dl>

</div>
</div>
<a class="anchor" id="ac32647919236d14893b4cf82d07a9357"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class UnitTypeLhs , class UnitTypeRhs , typename std::enable_if&lt;!traits::is_convertible_unit_t&lt; UnitTypeLhs, UnitTypeRhs &gt;::value &amp;&amp;traits::has_linear_scale&lt; UnitTypeLhs, UnitTypeRhs &gt;::value, int &gt;::type  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto units::operator/ </td>
          <td>(</td>
          <td class="paramtype">const UnitTypeLhs &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const UnitTypeRhs &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="classunits_1_1unit__t.html">unit_t</a>&lt;<a class="el" href="group___unit_types.html#ga9c3f6f077dc894620e1ed8358442a8f1">compound_unit</a>&lt;typename <a class="el" href="structunits_1_1traits_1_1unit__t__traits.html">traits::unit_t_traits</a>&lt;UnitTypeLhs&gt;::unit_type, <a class="el" href="group___unit_manipulators.html#gaacc539ef162e24b260d023d3ff949b57">inverse</a>&lt;typename <a class="el" href="structunits_1_1traits_1_1unit__t__traits.html">traits::unit_t_traits</a>&lt;UnitTypeRhs&gt;::unit_type&gt;&gt;&gt;
	</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Division for non-convertible <a class="el" href="classunits_1_1unit__t.html" title="Container for values which represent quantities of a given unit. ">unit_t</a> types with a linear scale. </p>
<dl class="section return"><dt>Returns</dt><dd>the lhs divided by the rhs, with a compound unit type of lhs/rhs </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sun Apr 3 2016 13:47:02 for Unit Conversion and Dimensional Analysis Library by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.9.1
</small></address>
</body>
</html>
