<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.9.1"/>
<title>Unit Conversion and Dimensional Analysis Library: Type Traits</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Unit Conversion and Dimensional Analysis Library
   &#160;<span id="projectnumber">2.0.0</span>
   </div>
   <div id="projectbrief">A compile-time c++14 unit conversion library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.9.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a>  </div>
  <div class="headertitle">
<div class="title">Type Traits</div>  </div>
</div><!--header-->
<div class="contents">

<p>Defines a series of classes to obtain unit type information at compile-time.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespaceunits_1_1traits"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceunits_1_1traits.html">units::traits</a></td></tr>
<tr class="memdesc:namespaceunits_1_1traits"><td class="mdescLeft">&#160;</td><td class="mdescRight">namespace representing type traits which can access the properties of types provided by the units library. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structunits_1_1traits_1_1unit__traits.html">units::traits::unit_traits&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Traits class defining the properties of units.  <a href="structunits_1_1traits_1_1unit__traits.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structunits_1_1traits_1_1is__base__unit.html">units::traits::is_base_unit&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trait which tests if a class is a <code><a class="el" href="structunits_1_1base__unit.html" title="Class representing SI base unit types. ">base_unit</a></code> type.  <a href="structunits_1_1traits_1_1is__base__unit.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structunits_1_1traits_1_1is__unit.html">units::traits::is_unit&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Traits which tests if a class is a <code>unit</code>  <a href="structunits_1_1traits_1_1is__unit.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structunits_1_1traits_1_1is__convertible__unit.html">units::traits::is_convertible_unit&lt; U1, U2 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trait which checks whether two units can be converted to each other.  <a href="structunits_1_1traits_1_1is__convertible__unit.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structunits_1_1traits_1_1is__nonlinear__scale.html">units::traits::is_nonlinear_scale&lt; T, Ret &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trait which tests that <code>class T</code> meets the requirements for a non-linear scale.  <a href="structunits_1_1traits_1_1is__nonlinear__scale.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structunits_1_1traits_1_1unit__t__traits.html">units::traits::unit_t_traits&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trait for accessing the publically defined types of <code><a class="el" href="classunits_1_1unit__t.html" title="Container for values which represent quantities of a given unit. ">units::unit_t</a></code>  <a href="structunits_1_1traits_1_1unit__t__traits.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structunits_1_1traits_1_1is__convertible__unit__t.html">units::traits::is_convertible_unit_t&lt; U1, U2 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trait which tests whether two container types derived from <code><a class="el" href="classunits_1_1unit__t.html" title="Container for values which represent quantities of a given unit. ">unit_t</a></code> are convertible to each other.  <a href="structunits_1_1traits_1_1is__convertible__unit__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structunits_1_1traits_1_1is__unit__t.html">units::traits::is_unit_t&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Traits which tests if a class is a <code>unit</code>  <a href="structunits_1_1traits_1_1is__unit__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structunits_1_1traits_1_1has__linear__scale.html">units::traits::has_linear_scale&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trait which tests whether a type is inherited from a linear scale.  <a href="structunits_1_1traits_1_1has__linear__scale.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structunits_1_1traits_1_1has__decibel__scale.html">units::traits::has_decibel_scale&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trait which tests whether a type is inherited from a decibel scale.  <a href="structunits_1_1traits_1_1has__decibel__scale.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structunits_1_1traits_1_1is__same__scale.html">units::traits::is_same_scale&lt; T1, T2 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trait which tests whether two types has the same non-linear scale.  <a href="structunits_1_1traits_1_1is__same__scale.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structunits_1_1traits_1_1is__scalar__unit.html">units::traits::is_scalar_unit&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trait which tests whether one or more types derived from <code><a class="el" href="classunits_1_1unit__t.html" title="Container for values which represent quantities of a given unit. ">unit_t</a></code> represent scalar values.  <a href="structunits_1_1traits_1_1is__scalar__unit.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structunits_1_1traits_1_1unit__value__t__traits.html">units::traits::unit_value_t_traits&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trait for accessing the publically defined types of <code>units::unit_value_t_traits</code>  <a href="structunits_1_1traits_1_1unit__value__t__traits.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structunits_1_1traits_1_1is__unit__value__t.html">units::traits::is_unit_value_t&lt; T, Units &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trait which tests whether a type is a <a class="el" href="structunits_1_1unit__value__t.html" title="Stores a rational unit value as a compile-time constant. ">unit_value_t</a> representing the given unit type.  <a href="structunits_1_1traits_1_1is__unit__value__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structunits_1_1traits_1_1is__unit__value__t__category.html">units::traits::is_unit_value_t_category&lt; Category, T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trait which tests whether type T is a <a class="el" href="structunits_1_1unit__value__t.html" title="Stores a rational unit value as a compile-time constant. ">unit_value_t</a> with a unit type in the given category.  <a href="structunits_1_1traits_1_1is__unit__value__t__category.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structunits_1_1traits_1_1is__length__unit.html">units::traits::is_length_unit&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trait which tests whether a type represents a unit of length.  <a href="structunits_1_1traits_1_1is__length__unit.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structunits_1_1traits_1_1is__mass__unit.html">units::traits::is_mass_unit&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trait which tests whether a type represents a unit of mass.  <a href="structunits_1_1traits_1_1is__mass__unit.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structunits_1_1traits_1_1is__time__unit.html">units::traits::is_time_unit&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trait which tests whether a type represents a unit of time.  <a href="structunits_1_1traits_1_1is__time__unit.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structunits_1_1traits_1_1is__angle__unit.html">units::traits::is_angle_unit&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trait which tests whether a type represents a unit of angle.  <a href="structunits_1_1traits_1_1is__angle__unit.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structunits_1_1traits_1_1is__current__unit.html">units::traits::is_current_unit&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trait which tests whether a type represents a unit of current.  <a href="structunits_1_1traits_1_1is__current__unit.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structunits_1_1traits_1_1is__temperature__unit.html">units::traits::is_temperature_unit&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trait which tests whether a type represents a unit of temperature.  <a href="structunits_1_1traits_1_1is__temperature__unit.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structunits_1_1traits_1_1is__substance__unit.html">units::traits::is_substance_unit&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trait which tests whether a type represents a unit of substance.  <a href="structunits_1_1traits_1_1is__substance__unit.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structunits_1_1traits_1_1is__luminous__intensity__unit.html">units::traits::is_luminous_intensity_unit&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trait which tests whether a type represents a unit of <a class="el" href="namespaceunits_1_1luminous__intensity.html" title="namespace for unit types and containers representing luminous_intensity values ">luminous_intensity</a>.  <a href="structunits_1_1traits_1_1is__luminous__intensity__unit.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structunits_1_1traits_1_1is__solid__angle__unit.html">units::traits::is_solid_angle_unit&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trait which tests whether a type represents a unit of <a class="el" href="namespaceunits_1_1solid__angle.html" title="namespace for unit types and containers representing solid_angle values ">solid_angle</a>.  <a href="structunits_1_1traits_1_1is__solid__angle__unit.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structunits_1_1traits_1_1is__frequency__unit.html">units::traits::is_frequency_unit&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trait which tests whether a type represents a unit of frequency.  <a href="structunits_1_1traits_1_1is__frequency__unit.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structunits_1_1traits_1_1is__velocity__unit.html">units::traits::is_velocity_unit&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trait which tests whether a type represents a unit of velocity.  <a href="structunits_1_1traits_1_1is__velocity__unit.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structunits_1_1traits_1_1is__angular__velocity__unit.html">units::traits::is_angular_velocity_unit&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trait which tests whether a type represents a unit of <a class="el" href="namespaceunits_1_1angular__velocity.html" title="namespace for unit types and containers representing angular velocity values ">angular_velocity</a>.  <a href="structunits_1_1traits_1_1is__angular__velocity__unit.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structunits_1_1traits_1_1is__acceleration__unit.html">units::traits::is_acceleration_unit&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trait which tests whether a type represents a unit of acceleration.  <a href="structunits_1_1traits_1_1is__acceleration__unit.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structunits_1_1traits_1_1is__force__unit.html">units::traits::is_force_unit&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trait which tests whether a type represents a unit of force.  <a href="structunits_1_1traits_1_1is__force__unit.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structunits_1_1traits_1_1is__pressure__unit.html">units::traits::is_pressure_unit&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trait which tests whether a type represents a unit of pressure.  <a href="structunits_1_1traits_1_1is__pressure__unit.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structunits_1_1traits_1_1is__charge__unit.html">units::traits::is_charge_unit&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trait which tests whether a type represents a unit of charge.  <a href="structunits_1_1traits_1_1is__charge__unit.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structunits_1_1traits_1_1is__energy__unit.html">units::traits::is_energy_unit&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trait which tests whether a type represents a unit of energy.  <a href="structunits_1_1traits_1_1is__energy__unit.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structunits_1_1traits_1_1is__power__unit.html">units::traits::is_power_unit&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trait which tests whether a type represents a unit of power.  <a href="structunits_1_1traits_1_1is__power__unit.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structunits_1_1traits_1_1is__voltage__unit.html">units::traits::is_voltage_unit&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trait which tests whether a type represents a unit of voltage.  <a href="structunits_1_1traits_1_1is__voltage__unit.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structunits_1_1traits_1_1is__capacitance__unit.html">units::traits::is_capacitance_unit&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trait which tests whether a type represents a unit of capacitance.  <a href="structunits_1_1traits_1_1is__capacitance__unit.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structunits_1_1traits_1_1is__impedance__unit.html">units::traits::is_impedance_unit&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trait which tests whether a type represents a unit of impedance.  <a href="structunits_1_1traits_1_1is__impedance__unit.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structunits_1_1traits_1_1is__conductance__unit.html">units::traits::is_conductance_unit&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trait which tests whether a type represents a unit of conductance.  <a href="structunits_1_1traits_1_1is__conductance__unit.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structunits_1_1traits_1_1is__magnetic__flux__unit.html">units::traits::is_magnetic_flux_unit&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trait which tests whether a type represents a unit of <a class="el" href="namespaceunits_1_1magnetic__flux.html" title="namespace for unit types and containers representing magnetic_flux values ">magnetic_flux</a>.  <a href="structunits_1_1traits_1_1is__magnetic__flux__unit.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structunits_1_1traits_1_1is__magnetic__field__strength__unit.html">units::traits::is_magnetic_field_strength_unit&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trait which tests whether a type represents a unit of <a class="el" href="namespaceunits_1_1magnetic__field__strength.html" title="namespace for unit types and containers representing magnetic_field_strength values ...">magnetic_field_strength</a>.  <a href="structunits_1_1traits_1_1is__magnetic__field__strength__unit.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structunits_1_1traits_1_1is__inductance__unit.html">units::traits::is_inductance_unit&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trait which tests whether a type represents a unit of inductance.  <a href="structunits_1_1traits_1_1is__inductance__unit.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structunits_1_1traits_1_1is__luminous__flux__unit.html">units::traits::is_luminous_flux_unit&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trait which tests whether a type represents a unit of <a class="el" href="namespaceunits_1_1luminous__flux.html" title="namespace for unit types and containers representing luminous_flux values ">luminous_flux</a>.  <a href="structunits_1_1traits_1_1is__luminous__flux__unit.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structunits_1_1traits_1_1is__illuminance__unit.html">units::traits::is_illuminance_unit&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trait which tests whether a type represents a unit of illuminance.  <a href="structunits_1_1traits_1_1is__illuminance__unit.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structunits_1_1traits_1_1is__radioactivity__unit.html">units::traits::is_radioactivity_unit&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trait which tests whether a type represents a unit of radiation.  <a href="structunits_1_1traits_1_1is__radioactivity__unit.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structunits_1_1traits_1_1is__torque__unit.html">units::traits::is_torque_unit&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trait which tests whether a type represents a unit of torque.  <a href="structunits_1_1traits_1_1is__torque__unit.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structunits_1_1traits_1_1is__area__unit.html">units::traits::is_area_unit&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trait which tests whether a type represents a unit of area.  <a href="structunits_1_1traits_1_1is__area__unit.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structunits_1_1traits_1_1is__volume__unit.html">units::traits::is_volume_unit&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trait which tests whether a type represents a unit of volume.  <a href="structunits_1_1traits_1_1is__volume__unit.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structunits_1_1traits_1_1is__density__unit.html">units::traits::is_density_unit&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trait which tests whether a type represents a unit of density.  <a href="structunits_1_1traits_1_1is__density__unit.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structunits_1_1traits_1_1is__concentration__unit.html">units::traits::is_concentration_unit&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trait which tests whether a type represents a unit of concentration.  <a href="structunits_1_1traits_1_1is__concentration__unit.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga62dd90a825a801e3e29841ed51713693"><td class="memTemplParams" colspan="2">template&lt;typename Ratio , std::intmax_t Eps = 10000000000&gt; </td></tr>
<tr class="memitem:ga62dd90a825a801e3e29841ed51713693"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___type_traits.html#ga62dd90a825a801e3e29841ed51713693">units::ratio_sqrt</a> = typename detail::Sqrt&lt; Ratio, std::ratio&lt; 1, Eps &gt;&gt;::type</td></tr>
<tr class="memdesc:ga62dd90a825a801e3e29841ed51713693"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate square root of a ratio at compile-time.  <a href="#ga62dd90a825a801e3e29841ed51713693">More...</a><br /></td></tr>
<tr class="separator:ga62dd90a825a801e3e29841ed51713693"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Defines a series of classes to obtain unit type information at compile-time. </p>
<h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="ga62dd90a825a801e3e29841ed51713693"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Ratio , std::intmax_t Eps = 10000000000&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group___type_traits.html#ga62dd90a825a801e3e29841ed51713693">units::ratio_sqrt</a> = typedef typename detail::Sqrt&lt;Ratio, std::ratio&lt;1, Eps&gt;&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate square root of a ratio at compile-time. </p>
<p>Calculates a rational approximation of the square root of the ratio. The error in the calculation is bounded by 1/epsilon (Eps). E.g. for the default value of 10000000000, the maximum error will be a/10000000000, or 1e-8, or said another way, the error will be on the order of 10^-9. Since these calculations are done at compile time, it is advisable to set epsilon to the highest value that does not cause an integer overflow in the calculation. If you can't compile <code>ratio_sqrt</code> due to overflow errors, reducing the value of epsilon sufficiently will correct the problem.<br />
<br />
 <code>ratio_sqrt</code> is guaranteed to converge for all values of <code>Ratio</code> which do not overflow. </p><dl class="section note"><dt>Note</dt><dd>This function provides a rational approximation, <em>NOT</em> an exact value. </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Ratio</td><td>ratio to take the square root of. This can represent any rational value, <em>not</em> just integers or values with integer roots. </td></tr>
    <tr><td class="paramname">Eps</td><td>Value of epsilon, which represents the inverse of the maximum allowable error. This value should be chosen to be as high as possible before integer overflow errors occur in the compiler. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sun Apr 3 2016 13:47:02 for Unit Conversion and Dimensional Analysis Library by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.9.1
</small></address>
</body>
</html>
