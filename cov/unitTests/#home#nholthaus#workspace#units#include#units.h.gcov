        -:    0:Source:/home/nholthaus/workspace/units/include/units.h
        -:    0:Graph:/home/nholthaus/workspace/units/cov/unitTests/CMakeFiles/unitLibTest.dir/main.cpp.gcno
        -:    0:Data:/home/nholthaus/workspace/units/cov/unitTests/CMakeFiles/unitLibTest.dir/main.cpp.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1://--------------------------------------------------------------------------------------------------
        -:    2:// 
        -:    3://	Units: A compile-time c++14 unit conversion library with no dependencies
        -:    4://
        -:    5://--------------------------------------------------------------------------------------------------
        -:    6://
        -:    7:// The MIT License (MIT)
        -:    8://
        -:    9:// Permission is hereby granted, free of charge, to any person obtaining a copy of this software 
        -:   10:// and associated documentation files (the "Software"), to deal in the Software without 
        -:   11:// restriction, including without limitation the rights to use, copy, modify, merge, publish, 
        -:   12:// distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the 
        -:   13:// Software is furnished to do so, subject to the following conditions:
        -:   14:// 
        -:   15:// The above copyright notice and this permission notice shall be included in all copies or 
        -:   16:// substantial portions of the Software.
        -:   17:// 
        -:   18:// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING 
        -:   19:// BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND 
        -:   20:// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, 
        -:   21:// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING 
        -:   22:// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
        -:   23://
        -:   24://--------------------------------------------------------------------------------------------------
        -:   25://
        -:   26:// ATTRIBUTION:
        -:   27:// Parts of this work have been adapted from: 
        -:   28:// http://stackoverflow.com/questions/35069778/create-comparison-trait-for-template-classes-whose-parameters-are-in-a-different
        -:   29:// http://stackoverflow.com/questions/28253399/check-traits-for-all-variadic-template-arguments/28253503
        -:   30://
        -:   31://--------------------------------------------------------------------------------------------------
        -:   32:// 
        -:   33:// Copyright (c) 2016 Nic Holthaus
        -:   34:// 
        -:   35://--------------------------------------------------------------------------------------------------
        -:   36:
        -:   37:#ifndef units_h__
        -:   38:#define units_h__
        -:   39:
        -:   40:#if _MCS_VER < 1800
        -:   41:#	pragma warning(push)
        -:   42:#	pragma warning(disable : 4520)
        -:   43:#endif
        -:   44:
        -:   45://--------------------
        -:   46://	INCLUDES
        -:   47://--------------------
        -:   48:
        -:   49:#include <ratio>
        -:   50:#include <type_traits>
        -:   51:#include <cstdint>
        -:   52:#include <cmath>
        -:   53:#include <iostream>
        -:   54:
        -:   55://--------------------
        -:   56://	UNITS NAMESPACE
        -:   57://--------------------
        -:   58:
        -:   59:/**
        -:   60: * @namespace units
        -:   61: * @brief Unit Conversion Library namespace
        -:   62: */
        -:   63:namespace units
        -:   64:{
        -:   65:	//----------------------------------
        -:   66:	//	DOXYGEN
        -:   67:	//----------------------------------
        -:   68:
        -:   69:	/**
        -:   70:	 * @defgroup	UnitContainers Unit Containers
        -:   71:	 * @brief		Defines a series of classes which contain dimensioned values. Unit containers
        -:   72:	 *				store a value, and support various arithmetic operations.
        -:   73:	 */
        -:   74:
        -:   75:	/**
        -:   76:	 * @defgroup	UnitTypes Unit Types
        -:   77:	 * @brief		Defines a series of classes which represent units. These types are tags used by
        -:   78:	 *				the conversion function, to create compound units, or to create `unit_t` types.
        -:   79:	 *				By themselves, they are not containers and have no stored value.
        -:   80:	 */
        -:   81:
        -:   82:	/**
        -:   83:	 * @defgroup	UnitManipulators Unit Manipulators
        -:   84:	 * @brief		Defines a series of classes used to manipulate unit types, such as `inverse<>`, `squared<>`, and metric prefixes. Unit
        -:   85:	 *				manipulators can be chained together, e.g. `inverse<squared<pico<time::seconds>>>` to
        -:   86:	 *				represent picoseconds^-2.
        -:   87:	 */
        -:   88:
        -:   89:	/**
        -:   90:	 * @defgroup	Conversion Explicit Conversion
        -:   91:	 * @brief		Functions used to convert values of one logical type to another.
        -:   92:	 */
        -:   93:
        -:   94:	/**
        -:   95:	 * @defgroup	TypeTraits Type Traits
        -:   96:	 * @brief		Defines a series of classes to obtain unit type information at compile-time.
        -:   97:	 */
        -:   98:
        -:   99:	//------------------------------
        -:  100:	//	FORWARD DECLARATIONS
        -:  101:	//------------------------------
        -:  102:
        -:  103:	/** @cond */	// DOXYGEN IGNORE
        -:  104:	namespace constants
        -:  105:	{
        -:  106:		static const double PI = 3.14159265358979323846264338327950288419716939937510;
        -:  107:	}
        -:  108:	/** @endcond */	// END DOXYGEN IGNORE
        -:  109:
        -:  110:	//------------------------------
        -:  111:	//	RATIO TRAITS
        -:  112:	//------------------------------
        -:  113:
        -:  114:	/**
        -:  115:	 * @ingroup TypeTraits
        -:  116:	 * @{
        -:  117:	 */
        -:  118:
        -:  119:	/** @cond */	// DOXYGEN IGNORE
        -:  120:	namespace detail
        -:  121:	{
        -:  122:		/// has_num implementation.
        -:  123:		template<class T>
        -:  124:		struct has_num_impl
        -:  125:		{
        -:  126:			template<class U>
        -:  127:			static auto test(U*)->std::is_integral<decltype(U::num)>;
        -:  128:			template<typename>
        -:  129:			static std::false_type test(...);
        -:  130:
        -:  131:			using type = decltype(test<T>(0));
        -:  132:		};
        -:  133:	}
        -:  134:
        -:  135:	/**
        -:  136:	 * @brief		Trait which checks for the existence of a static numerator.
        -:  137:	 * @details		Inherits from `std::true_type` or `std::false_type`. Use `has_num<T>::value` to test
        -:  138:	 *				whether `class T` has a numerator static member.
        -:  139:	 */
        -:  140:	template<class T>
        -:  141:	struct has_num : detail::has_num_impl<T>::type {};
        -:  142:
        -:  143:	namespace detail
        -:  144:	{
        -:  145:		/// has_den implementation.
        -:  146:		template<class T>
        -:  147:		struct has_den_impl
        -:  148:		{
        -:  149:			template<class U>
        -:  150:			static auto test(U*)->std::is_integral<decltype(U::den)>;
        -:  151:			template<typename>
        -:  152:			static std::false_type test(...);
        -:  153:
        -:  154:			using type = decltype(test<T>(0));
        -:  155:		};
        -:  156:	}
        -:  157:
        -:  158:	/**
        -:  159:	 * @brief		Trait which checks for the existence of a static denominator.
        -:  160:	 * @details		Inherits from `std::true_type` or `std::false_type`. Use `has_den<T>::value` to test
        -:  161:	 *				whether `class T` has a denominator static member.
        -:  162:	 */
        -:  163:	template<class T>
        -:  164:	struct has_den : detail::has_den_impl<T>::type {};
        -:  165:
        -:  166:	/** @endcond */	// END DOXYGEN IGNORE
        -:  167:
        -:  168:	/**
        -:  169:	 * @brief		Trait that tests whether a type represents a std::ratio.
        -:  170:	 * @details		Inherits from `std::true_type` or `std::false_type`. Use `is_ratio<T>::value` to test
        -:  171:	 *				whether `class T` implements a std::ratio.
        -:  172:	 */
        -:  173:	template<class T>
        -:  174:	struct is_ratio : std::integral_constant<bool,
        -:  175:		has_num<T>::value &&
        -:  176:		has_den<T>::value>
        -:  177:	{};
        -:  178:
        -:  179:	//------------------------------
        -:  180:	//	UNIT TRAITS
        -:  181:	//------------------------------
        -:  182:
        -:  183:	/** @cond */	// DOXYGEN IGNORE
        -:  184:	/**
        -:  185:	 * @brief		void type.
        -:  186:	 * @details		Helper class for creating type traits.
        -:  187:	 */
        -:  188:	template<class ...>
        -:  189:	struct void_t { typedef void type; };
        -:  190:
        -:  191:	/**
        -:  192:	 * @brief		parameter pack for boolean arguments.
        -:  193:	 */
        -:  194:	template<bool...> struct bool_pack {};
        -:  195:
        -:  196:	/**
        -:  197:	 * @brief		Trait which tests that a set of other traits are all true.
        -:  198:	 */
        -:  199:	template<bool... Args>
        -:  200:	struct all_true : std::is_same<bool_pack<true, Args...>, bool_pack<Args..., true>> {};
        -:  201:
        -:  202:	/**
        -:  203:	 * @brief		unit traits implementation for classes which are not units.
        -:  204:	 */
        -:  205:	template<class T, typename = void>
        -:  206:	struct unit_traits
        -:  207:	{
        -:  208:		typedef void base_unit_type;
        -:  209:		typedef void conversion_ratio;
        -:  210:		typedef void pi_exponent_ratio;
        -:  211:		typedef void translation_ratio;
        -:  212:	};
        -:  213:	/** @endcond */	// END DOXYGEN IGNORE
        -:  214:
        -:  215:	/**
        -:  216:	 * @ingroup		TypeTraits
        -:  217:	 * @brief		Traits class defining the properties of units.
        -:  218:	 * @details
        -:  219:	 */
        -:  220:	template<class T>
        -:  221:	struct unit_traits
        -:  222:		<T, typename void_t<
        -:  223:		typename T::base_unit_type,
        -:  224:		typename T::conversion_ratio,
        -:  225:		typename T::pi_exponent_ratio,
        -:  226:		typename T::translation_ratio>::type>
        -:  227:	{
        -:  228:		typedef typename T::base_unit_type base_unit_type;											///< Unit type that the unit was derived from. May be a `base_unit` or another `unit`. Use the `base_unit_of` trait to find the SI base unit type. 
        -:  229:		typedef typename T::conversion_ratio conversion_ratio;										///< std::ratio representing the conversion factor to the `base_unit_type`.
        -:  230:		typedef typename T::pi_exponent_ratio pi_exponent_ratio;									///< std::ratio representing the exponent of pi to be used in the conversion.
        -:  231:		typedef typename T::translation_ratio translation_ratio;									///< std::ratio representing a datum translation to the base unit (i.e. degrees C to degrees F conversion).
        -:  232:	};
        -:  233:
        -:  234:	/** @cond */	// DOXYGEN IGNORE
        -:  235:	namespace detail
        -:  236:	{
        -:  237:		/**
        -:  238:		 * @brief		helper type to identify base units.
        -:  239:		 * @details		A non-templated base class for `base_unit` which enables RTTI testing.
        -:  240:		 */
        -:  241:		struct _base_unit_t {};
        -:  242:	}
        -:  243:	/** @endcond */	// END DOXYGEN IGNORE
        -:  244:
        -:  245:	/**
        -:  246:	 * @ingroup		TypeTraits
        -:  247:	 * @brief		Traits which tests if a class is a `base_unit` type.
        -:  248:	 * @details		Inherits from `std::true_type` or `std::false_type`. Use `is_base_unit<T>::value` to test
        -:  249:	 *				whether `class T` implements a `base_unit`.
        -:  250:	 */
        -:  251:	template<class T>
        -:  252:	struct is_base_unit : std::is_base_of<detail::_base_unit_t, T> {};
        -:  253:
        -:  254:	/** @cond */	// DOXYGEN IGNORE
        -:  255:	namespace detail
        -:  256:	{
        -:  257:		/**
        -:  258:		 * @brief		helper type to identify units.
        -:  259:		 * @details		A non-templated base class for `unit` which enables RTTI testing.
        -:  260:		 */
        -:  261:		struct _unit_t {};
        -:  262:	}
        -:  263:	/** @endcond */	// END DOXYGEN IGNORE
        -:  264:
        -:  265:	/**
        -:  266:	 * @ingroup		TypeTraits
        -:  267:	 * @brief		Traits which tests if a class is a `unit`
        -:  268:	 * @details		Inherits from `std::true_type` or `std::false_type`. Use `is_unit<T>::value` to test
        -:  269:	 *				whether `class T` implements a `unit`.
        -:  270:	 */
        -:  271:	template<class T>
        -:  272:	struct is_unit : std::is_base_of<detail::_unit_t, T>::type {};
        -:  273:
        -:  274:	/** @} */ // end of TypeTraits
        -:  275:
        -:  276:	//------------------------------
        -:  277:	//	BASE UNIT CLASS
        -:  278:	//------------------------------
        -:  279:
        -:  280:	/**
        -:  281:	 * @brief		Class representing SI base unit types.
        -:  282:	 * @details		Base units are represented by a combination of `std::ratio` template parameters, each
        -:  283:	 *				describing the exponent of the type of unit they represent. Example: meters per second
        -:  284:	 *				would be described by a +1 exponent for meters, and a -1 exponent for seconds, thus:
        -:  285:	 *				`base_unit<std::ratio<1>, std::ratio<0>, std::ratio<-1>>`
        -:  286:	 * @tparam		Meter		`std::ratio` representing the exponent value for meters.
        -:  287:	 * @tparam		Kilogram	`std::ratio` representing the exponent value for kilograms.
        -:  288:	 * @tparam		Second		`std::ratio` representing the exponent value for seconds.
        -:  289:	 * @tparam		Radian		`std::ratio` representing the exponent value for radians. Although radians are not SI base units, they are included because radians are described by the SI as m * m^-1, which would make them indistinguishable from scalars.
        -:  290:	 * @tparam		Ampere		`std::ratio` representing the exponent value for amperes.
        -:  291:	 * @tparam		Kelvin		`std::ratio` representing the exponent value for Kelvin.
        -:  292:	 * @tparam		Mole		`std::ratio` representing the exponent value for moles.
        -:  293:	 * @tparam		Candela		`std::ratio` representing the exponent value for candelas.
        -:  294:	 * @ingroup		UnitTypes
        -:  295:	 * @sa			category	 for type aliases for SI base_unit types.
        -:  296:	 */
        -:  297:	template<class Meter = std::ratio<0>,
        -:  298:	class Kilogram = std::ratio<0>,
        -:  299:	class Second = std::ratio<0>,
        -:  300:	class Radian = std::ratio<0>,
        -:  301:	class Ampere = std::ratio<0>,
        -:  302:	class Kelvin = std::ratio<0>,
        -:  303:	class Mole = std::ratio<0>,
        -:  304:	class Candela = std::ratio < 0 >>
        -:  305:	struct base_unit : detail::_base_unit_t
        -:  306:	{
        -:  307:		static_assert(is_ratio<Meter>::value, "Template parameter `Meter` must be a `std::ratio` representing the exponent of meters the unit has");
        -:  308:		static_assert(is_ratio<Kilogram>::value, "Template parameter `Kilogram` must be a `std::ratio` representing the exponent of kilograms the unit has");
        -:  309:		static_assert(is_ratio<Second>::value, "Template parameter `Second` must be a `std::ratio` representing the exponent of seconds the unit has");
        -:  310:		static_assert(is_ratio<Ampere>::value, "Template parameter `Ampere` must be a `std::ratio` representing the exponent of amperes the unit has");
        -:  311:		static_assert(is_ratio<Kelvin>::value, "Template parameter `Kelvin` must be a `std::ratio` representing the exponent of kelvin the unit has");
        -:  312:		static_assert(is_ratio<Candela>::value, "Template parameter `Candela` must be a `std::ratio` representing the exponent of candelas the unit has");
        -:  313:		static_assert(is_ratio<Mole>::value, "Template parameter `Mole` must be a `std::ratio` representing the exponent of moles the unit has");
        -:  314:		static_assert(is_ratio<Radian>::value, "Template parameter `Radian` must be a `std::ratio` representing the exponent of radians the unit has");
        -:  315:	};
        -:  316:
        -:  317:	//------------------------------
        -:  318:	//	UNIT CATEGORIES
        -:  319:	//------------------------------
        -:  320:
        -:  321:	/**
        -:  322:	 * @brief		namespace representing the implemented base and derived unit types. These will not generally be needed by library users.
        -:  323:	 */
        -:  324:	namespace category
        -:  325:	{
        -:  326:		// SCALAR (DIMENSIONLESS) TYPES
        -:  327:		using scalar_unit = base_unit<>;
        -:  328:		using dimensionless_unit = base_unit<>;
        -:  329:
        -:  330:		// SI BASE UNIT TYPES	--------------------		METERS			KILOGRAMS		SECONDS			RADIANS			AMPERES			KELVIN			MOLE			CANDELA			
        -:  331:		using length_unit = base_unit<std::ratio<1>>;
        -:  332:		using mass_unit = base_unit<std::ratio<0>, std::ratio<1>>;
        -:  333:		using time_unit = base_unit<std::ratio<0>, std::ratio<0>, std::ratio<1>>;
        -:  334:		using angle_unit = base_unit<std::ratio<0>, std::ratio<0>, std::ratio<0>, std::ratio<1>>;
        -:  335:		using current_unit = base_unit<std::ratio<0>, std::ratio<0>, std::ratio<0>, std::ratio<0>, std::ratio<1>>;
        -:  336:		using temperature_unit = base_unit<std::ratio<0>, std::ratio<0>, std::ratio<0>, std::ratio<0>, std::ratio<0>, std::ratio<1>>;
        -:  337:		using substance_unit = base_unit<std::ratio<0>, std::ratio<0>, std::ratio<0>, std::ratio<0>, std::ratio<0>, std::ratio<0>, std::ratio<1>>;
        -:  338:		using luminous_intensity_unit = base_unit<std::ratio<0>, std::ratio<0>, std::ratio<0>, std::ratio<0>, std::ratio<0>, std::ratio<0>, std::ratio<0>, std::ratio<1>>;
        -:  339:
        -:  340:		// SI DERIVED UNIT TYPES	---------------			METERS			KILOGRAMS		SECONDS			RADIANS			AMPERES			KELVIN			MOLE			CANDELA			
        -:  341:		using solid_angle_unit = base_unit<std::ratio<0>, std::ratio<0>, std::ratio<0>, std::ratio<2>, std::ratio<0>, std::ratio<0>, std::ratio<0>, std::ratio<0>>;
        -:  342:		using frequency_unit = base_unit<std::ratio<0>, std::ratio<0>, std::ratio<-1>>;
        -:  343:		using velocity_unit = base_unit<std::ratio<1>, std::ratio<0>, std::ratio<-1>>;
        -:  344:		using angular_velocity_unit = base_unit<std::ratio<0>, std::ratio<0>, std::ratio<-1>, std::ratio<1>>;
        -:  345:		using acceleration_unit = base_unit<std::ratio<1>, std::ratio<0>, std::ratio<-2>>;
        -:  346:		using force_unit = base_unit<std::ratio<1>, std::ratio<1>, std::ratio<-2>>;
        -:  347:		using pressure_unit = base_unit<std::ratio<-1>, std::ratio<1>, std::ratio<-2>>;
        -:  348:		using charge_unit = base_unit<std::ratio<0>, std::ratio<0>, std::ratio<1>, std::ratio<0>, std::ratio<1>>;
        -:  349:		using energy_unit = base_unit<std::ratio<2>, std::ratio<1>, std::ratio<-2>>;
        -:  350:		using power_unit = base_unit<std::ratio<2>, std::ratio<1>, std::ratio<-3>>;
        -:  351:		using voltage_unit = base_unit<std::ratio<2>, std::ratio<1>, std::ratio<-3>, std::ratio<0>, std::ratio<-1>>;
        -:  352:		using capacitance_unit = base_unit<std::ratio<-2>, std::ratio<-1>, std::ratio<4>, std::ratio<0>, std::ratio<2>>;
        -:  353:		using impedance_unit = base_unit<std::ratio<2>, std::ratio<1>, std::ratio<-3>, std::ratio<0>, std::ratio<-2>>;
        -:  354:		using conductance_unit = base_unit<std::ratio<-2>, std::ratio<-1>, std::ratio<3>, std::ratio<0>, std::ratio<2>>;
        -:  355:		using magnetic_flux_unit = base_unit<std::ratio<2>, std::ratio<1>, std::ratio<-2>, std::ratio<0>, std::ratio<-1>>;
        -:  356:		using magnetic_field_strength_unit = base_unit<std::ratio<0>, std::ratio<1>, std::ratio<-2>, std::ratio<0>, std::ratio<-1>>;
        -:  357:		using inductance_unit = base_unit<std::ratio<2>, std::ratio<1>, std::ratio<-2>, std::ratio<0>, std::ratio<-2>>;
        -:  358:		using luminous_flux_unit = base_unit<std::ratio<0>, std::ratio<0>, std::ratio<0>, std::ratio<2>, std::ratio<0>, std::ratio<0>, std::ratio<0>, std::ratio<1>>;
        -:  359:		using illuminance_unit = base_unit<std::ratio<-2>, std::ratio<0>, std::ratio<0>, std::ratio<2>, std::ratio<0>, std::ratio<0>, std::ratio<0>, std::ratio<1>>;
        -:  360:		using radioactivity_unit = base_unit<std::ratio<0>, std::ratio<0>, std::ratio<-1>>;
        -:  361:
        -:  362:		// OTHER UNIT TYPES			---------------			METERS			KILOGRAMS		SECONDS			RADIANS			AMPERES			KELVIN			MOLE			CANDELA			
        -:  363:		using	torque_unit = base_unit<std::ratio<2>, std::ratio<1>, std::ratio<-2>>;
        -:  364:		using	area_unit = base_unit<std::ratio<2>>;
        -:  365:		using	volume_unit = base_unit<std::ratio<3>>;
        -:  366:		using	density_unit = base_unit<std::ratio<-3>, std::ratio<1>>;
        -:  367:	}
        -:  368:
        -:  369:	//------------------------------
        -:  370:	//	UNIT CLASSES
        -:  371:	//------------------------------
        -:  372:
        -:  373:	/** @cond */	// DOXYGEN IGNORE
        -:  374:	/**
        -:  375:	 * @brief		unit type template specialization for units derived from base units.
        -:  376:	 */
        -:  377:	template <class, class, class, class> struct unit;
        -:  378:	template<class Conversion, class... Exponents, class PiExponent, class Translation>
        -:  379:	struct unit<Conversion, base_unit<Exponents...>, PiExponent, Translation> : detail::_unit_t
        -:  380:	{
        -:  381:		static_assert(is_ratio<Conversion>::value, "Template parameter `Conversion` must be a `std::ratio` representing the conversion factor to `BaseUnit`.");
        -:  382:		static_assert(is_ratio<PiExponent>::value, "Template parameter `PiExponent` must be a `std::ratio` representing the exponents of Pi the unit has.");
        -:  383:		static_assert(is_ratio<Translation>::value, "Template parameter `Translation` must be a `std::ratio` representing an additive translation required by the unit conversion.");
        -:  384:
        -:  385:		typedef typename units::base_unit<Exponents...> base_unit_type;
        -:  386:		typedef Conversion conversion_ratio;
        -:  387:		typedef Translation translation_ratio;
        -:  388:		typedef PiExponent pi_exponent_ratio;
        -:  389:	};
        -:  390:	/** @endcond */	// END DOXYGEN IGNORE
        -:  391:
        -:  392:	/**
        -:  393:	 * @brief		Type representing an arbitrary unit.
        -:  394:	 * @ingroup		UnitTypes
        -:  395:	 * @details		`unit` types are used as tags for the `conversion` function. They are *not* containers
        -:  396:	 *				(see `unit_t` for a  container class). Each unit is defined by:
        -:  397:	 *
        -:  398:	 *				- A `std::ratio` defining the conversion factor to the base unit type. (e.g. `std::ratio<1,12>` for inches to feet)
        -:  399:	 *				- A base unit that the unit is derived from (or a unit category. Must be of type `unit` or `base_unit`)
        -:  400:	 *				- An exponent representing factors of PI required by the conversion. (e.g. `std::ratio<-1>` for a radians to degrees conversion)
        -:  401:	 *				- a ratio representing a datum translation required for the conversion (e.g. `std::ratio<32>` for a farenheit to celsius conversion)
        -:  402:	 *
        -:  403:	 *				Typically, a specific unit, like `meters`, would be implemented as a type alias
        -:  404:	 *				of `unit`, i.e. `using meters = unit<std::ratio<1>, category::length_unit`, or
        -:  405:	 *				`using inches = unit<std::ratio<1,12>, feet>`.
        -:  406:	 * @tparam		Conversion	std::ratio representing scalar multiplication factor.
        -:  407:	 * @tparam		BaseUnit	Unit type which this unit is derived from. May be a `base_unit`, or another `unit`.
        -:  408:	 * @tparam		PiExponent	std::ratio representing the exponent of pi required by the conversion.
        -:  409:	 * @tparam		Translation	std::ratio representing any datum translation required by the conversion.
        -:  410:	 */
        -:  411:	template<class Conversion, class BaseUnit, class PiExponent = std::ratio<0>, class Translation = std::ratio<0>>
        -:  412:	struct unit : detail::_unit_t
        -:  413:	{
        -:  414:		static_assert(is_unit<BaseUnit>::value, "Template parameter `BaseUnit` must be a `unit` type.");
        -:  415:		static_assert(is_ratio<Conversion>::value, "Template parameter `Conversion` must be a `std::ratio` representing the conversion factor to `BaseUnit`.");
        -:  416:		static_assert(is_ratio<PiExponent>::value, "Template parameter `PiExponent` must be a `std::ratio` representing the exponents of Pi the unit has.");
        -:  417:
        -:  418:		typedef typename unit_traits<BaseUnit>::base_unit_type base_unit_type;
        -:  419:		typedef typename std::ratio_multiply<typename BaseUnit::conversion_ratio, Conversion> conversion_ratio;
        -:  420:		typedef typename std::ratio_add<typename BaseUnit::pi_exponent_ratio, PiExponent> pi_exponent_ratio;
        -:  421:		typedef typename std::ratio_add<std::ratio_multiply<typename BaseUnit::conversion_ratio, Translation>, typename BaseUnit::translation_ratio> translation_ratio;
        -:  422:	};
        -:  423:
        -:  424:	//------------------------------
        -:  425:	//	BASE UNIT MANIPULATORS
        -:  426:	//------------------------------
        -:  427:
        -:  428:	/** @cond */	// DOXYGEN IGNORE
        -:  429:	namespace detail
        -:  430:	{
        -:  431:		/**
        -:  432:		 * @brief		base_unit_of trait implementation
        -:  433:		 * @details		recursively seeks base_unit type that a unit is derived from. Since units can be
        -:  434:		 *				derived from other units, the `base_unit_type` typedef may not represent this value.
        -:  435:		 */
        -:  436:		template<class> struct base_unit_of_impl;
        -:  437:		template<class Conversion, class BaseUnit, class PiExponent, class Translation>
        -:  438:		struct base_unit_of_impl<unit<Conversion, BaseUnit, PiExponent, Translation>> : base_unit_of_impl<BaseUnit> {};
        -:  439:		template<class... Exponents>
        -:  440:		struct base_unit_of_impl<base_unit<Exponents...>>
        -:  441:		{
        -:  442:			typedef base_unit<Exponents...> type;
        -:  443:		};
        -:  444:		template<>
        -:  445:		struct base_unit_of_impl<void>
        -:  446:		{
        -:  447:			typedef void type;
        -:  448:		};
        -:  449:	}
        -:  450:	/** @endcond */	// END DOXYGEN IGNORE
        -:  451:
        -:  452:	/**
        -:  453:	 * @brief		Trait which returns the `base_unit` type that a unit is originally derived from.
        -:  454:	 * @details		Since units can be derived from other `unit` types in addition to `base_unit` types,
        -:  455:	 *				the `base_unit_type` typedef will not always be a `base_unit` (or unit category).
        -:  456:	 *				Since compatible
        -:  457:	 */
        -:  458:	template<class U>
        -:  459:	using base_unit_of = typename detail::base_unit_of_impl<U>::type;
        -:  460:
        -:  461:	/** @cond */	// DOXYGEN IGNORE
        -:  462:	namespace detail
        -:  463:	{
        -:  464:		/**
        -:  465:		 * @brief		implementation of base_unit_multiply
        -:  466:		 * @details		'multiples' (adds exponent ratios of) two base unit types. Base units can be found
        -:  467:		 *				using `base_unit_of`.
        -:  468:		 */
        -:  469:		template<class, class> struct base_unit_multiply_impl;
        -:  470:		template<class... Exponents1, class... Exponents2>
        -:  471:		struct base_unit_multiply_impl<base_unit<Exponents1...>, base_unit<Exponents2...>> {
        -:  472:			using type = base_unit<std::ratio_add<Exponents1, Exponents2>...>;
        -:  473:		};
        -:  474:
        -:  475:		/**
        -:  476:		 * @brief		represents type of two base units multiplied together
        -:  477:		 */
        -:  478:		template<class U1, class U2>
        -:  479:		using base_unit_multiply = typename base_unit_multiply_impl<U1, U2>::type;
        -:  480:
        -:  481:		/**
        -:  482:		 * @brief		implementation of base_unit_divide
        -:  483:		 * @details		'dived' (subtracts exponent ratios of) two base unit types. Base units can be found
        -:  484:		 *				using `base_unit_of`.
        -:  485:		 */
        -:  486:		template<class, class> struct base_unit_divide_impl;
        -:  487:		template<class... Exponents1, class... Exponents2>
        -:  488:		struct base_unit_divide_impl<base_unit<Exponents1...>, base_unit<Exponents2...>> {
        -:  489:			using type = base_unit<std::ratio_subtract<Exponents1, Exponents2>...>;
        -:  490:		};
        -:  491:
        -:  492:		/**
        -:  493:		 * @brief		represents the resulting type of `base_unit` U1 divided by U2.
        -:  494:		 */
        -:  495:		template<class U1, class U2>
        -:  496:		using base_unit_divide = typename base_unit_divide_impl<U1, U2>::type;
        -:  497:
        -:  498:		/**
        -:  499:		 * @brief		implementation of inverse_base
        -:  500:		 * @details		multiplies all `base_unit` exponent ratios by -1. The resulting type represents
        -:  501:		 *				the inverse base unit of the given `base_unit` type.
        -:  502:		 */
        -:  503:		template<class> struct inverse_base_impl;
        -:  504:
        -:  505:		template<class... Exponents>
        -:  506:		struct inverse_base_impl<base_unit<Exponents...>> {
        -:  507:			using type = base_unit<std::ratio_multiply<Exponents, std::ratio<-1>>...>;
        -:  508:		};
        -:  509:
        -:  510:		/**
        -:  511:		 * @brief		represent the inverse type of `class U`
        -:  512:		 * @details		E.g. if `U` is `length_unit`, then `inverse<U>` will represent `length_unit^-1`.
        -:  513:		 */
        -:  514:		template<class U> using inverse_base = typename inverse_base_impl<U>::type;
        -:  515:
        -:  516:		/**
        -:  517:		 * @brief		implementation of `squared_base`
        -:  518:		 * @details		multiplies all the exponent ratios of the given class by 2. The resulting type is
        -:  519:		 *				equivalent to the given type squared.
        -:  520:		 */
        -:  521:		template<class U> struct squared_base_impl;
        -:  522:		template<class... Exponents>
        -:  523:		struct squared_base_impl<base_unit<Exponents...>> {
        -:  524:			using type = base_unit<std::ratio_multiply<Exponents, std::ratio<2>>...>;
        -:  525:		};
        -:  526:
        -:  527:		/**
        -:  528:		 * @brief		represents the type of a `base_unit` squared.
        -:  529:		 * @details		E.g. `squared<length_unit>` will represent `length_unit^2`.
        -:  530:		 */
        -:  531:		template<class U> using squared_base = typename squared_base_impl<U>::type;
        -:  532:
        -:  533:		/**
        -:  534:		 * @brief		implementation of `cubed_base`
        -:  535:		 * @details		multiplies all the exponent ratios of the given class by 3. The resulting type is
        -:  536:		 *				equivalent to the given type cubed.
        -:  537:		 */
        -:  538:		template<class U> struct cubed_base_impl;
        -:  539:		template<class... Exponents>
        -:  540:		struct cubed_base_impl<base_unit<Exponents...>> {
        -:  541:			using type = base_unit<std::ratio_multiply<Exponents, std::ratio<3>>...>;
        -:  542:		};
        -:  543:
        -:  544:		/**
        -:  545:		 * @brief		represents the type of a `base_unit` cubed.
        -:  546:		 * @details		E.g. `cubed<length_unit>` will represent `length_unit^3`.
        -:  547:		 */
        -:  548:		template<class U> using cubed_base = typename cubed_base_impl<U>::type;
        -:  549:	}
        -:  550:	/** @endcond */	// END DOXYGEN IGNORE
        -:  551:
        -:  552:	//------------------------------
        -:  553:	//	UNIT MANIPULATORS
        -:  554:	//------------------------------
        -:  555:
        -:  556:	/** @cond */	// DOXYGEN IGNORE
        -:  557:	namespace detail
        -:  558:	{
        -:  559:		/**
        -:  560:		 * @brief		implementation of `unit_multiply`.
        -:  561:		 * @details		multiplies two units. The base unit becomes the base units of each with their exponents
        -:  562:		 *				added together. The conversion factors of each are multiplied by each other. Pi exponent ratios
        -:  563:		 *				are added, and datum translations are removed.
        -:  564:		 */
        -:  565:		template<class Unit1, class Unit2>
        -:  566:		struct unit_multiply_impl
        -:  567:		{
        -:  568:			using type = unit < std::ratio_multiply<typename Unit1::conversion_ratio, typename Unit2::conversion_ratio>,
        -:  569:				base_unit_multiply <base_unit_of<typename Unit1::base_unit_type>, base_unit_of<typename Unit2::base_unit_type>>,
        -:  570:				std::ratio_add<typename Unit1::pi_exponent_ratio, typename Unit2::pi_exponent_ratio>,
        -:  571:				std::ratio < 0 >> ;
        -:  572:		};
        -:  573:
        -:  574:		/**
        -:  575:		 * @brief		represents the type of two units multiplied together.
        -:  576:		 * @details		recalculates conversion and exponent ratios at compile-time.
        -:  577:		 */
        -:  578:		template<class U1, class U2>
        -:  579:		using unit_multiply = typename unit_multiply_impl<U1, U2>::type;
        -:  580:
        -:  581:		/**
        -:  582:		 * @brief		implementation of `unit_divide`.
        -:  583:		 * @details		divides two units. The base unit becomes the base units of each with their exponents
        -:  584:		 *				subtracted from each other. The conversion factors of each are divided by each other. Pi exponent ratios
        -:  585:		 *				are subtracted, and datum translations are removed.
        -:  586:		 */
        -:  587:		template<class Unit1, class Unit2>
        -:  588:		struct unit_divide_impl
        -:  589:		{
        -:  590:			using type = unit < std::ratio_divide<typename Unit1::conversion_ratio, typename Unit2::conversion_ratio>,
        -:  591:				base_unit_divide<base_unit_of<typename Unit1::base_unit_type>, base_unit_of<typename Unit2::base_unit_type>>,
        -:  592:				std::ratio_subtract<typename Unit1::pi_exponent_ratio, typename Unit2::pi_exponent_ratio>,
        -:  593:				std::ratio < 0 >> ;
        -:  594:		};
        -:  595:
        -:  596:		/**
        -:  597:		 * @brief		represents the type of two units divided by each other.
        -:  598:		 * @details		recalculates conversion and exponent ratios at compile-time.
        -:  599:		 */
        -:  600:		template<class U1, class U2>
        -:  601:		using unit_divide = typename unit_divide_impl<U1, U2>::type;
        -:  602:
        -:  603:		/**
        -:  604:		 * @brief		implementation of `inverse`
        -:  605:		 * @details		inverts a unit (equivalent to 1/unit). The `base_unit` and pi exponents are all multiplied by
        -:  606:		 *				-1. The conversion ratio numerator and denominator are swapped. Datum translation
        -:  607:		 *				ratios are removed.
        -:  608:		 */
        -:  609:		template<class Unit>
        -:  610:		struct inverse_impl
        -:  611:		{
        -:  612:			using type = unit < std::ratio<Unit::conversion_ratio::den, Unit::conversion_ratio::num>,
        -:  613:				inverse_base<base_unit_of<typename unit_traits<Unit>::base_unit_type>>,
        -:  614:				std::ratio_multiply<typename unit_traits<Unit>::pi_exponent_ratio, std::ratio<-1>>,
        -:  615:				std::ratio < 0 >> ;	// inverses are rates or change, the translation factor goes away.
        -:  616:		};
        -:  617:	}
        -:  618:	/** @endcond */	// END DOXYGEN IGNORE
        -:  619:
        -:  620:	/**
        -:  621:	 * @brief		represents the inverse unit type of `class U`.
        -:  622:	 * @ingroup		UnitManipulators
        -:  623:	 * @tparam		U	`unit` type to invert.
        -:  624:	 * @details		E.g. `inverse<meters>` will represent meters^-1 (i.e. 1/meters).
        -:  625:	 */
        -:  626:	template<class U> using inverse = typename detail::inverse_impl<U>::type;
        -:  627:
        -:  628:	/** @cond */	// DOXYGEN IGNORE
        -:  629:	namespace detail
        -:  630:	{
        -:  631:		/**
        -:  632:		 * @brief		implementation of `squared`
        -:  633:		 * @details		Squares the conversion ratio, `base_unit` exponents, pi exponents, and removes
        -:  634:		 *				datum translation ratios.
        -:  635:		 */
        -:  636:		template<class Unit>
        -:  637:		struct squared_impl
        -:  638:		{
        -:  639:			static_assert(is_unit<Unit>::value, "Template parameter `Unit` must be a `unit` type.");
        -:  640:			using Conversion = typename Unit::conversion_ratio;
        -:  641:			using type = unit < std::ratio_multiply<Conversion, Conversion>,
        -:  642:				squared_base<base_unit_of<typename Unit::base_unit_type>>,
        -:  643:				std::ratio_multiply<typename Unit::pi_exponent_ratio, std::ratio<2>>,
        -:  644:				std::ratio < 0 >> ;
        -:  645:		};
        -:  646:	}
        -:  647:	/** @endcond */	// END DOXYGEN IGNORE
        -:  648:
        -:  649:	/**
        -:  650:	 * @brief		represents the unit type of `class U` squared
        -:  651:	 * @ingroup		UnitManipulators
        -:  652:	 * @tparam		U	`unit` type to square.
        -:  653:	 * @details		E.g. `square<meters>` will represent meters^2.
        -:  654:	 */
        -:  655:	template<class U>
        -:  656:	using squared = typename detail::squared_impl<U>::type;
        -:  657:
        -:  658:	/** @cond */	// DOXYGEN IGNORE
        -:  659:	namespace detail
        -:  660:	{
        -:  661:		/**
        -:  662:			 * @brief		implementation of `cubed`
        -:  663:			 * @details		Cubes the conversion ratio, `base_unit` exponents, pi exponents, and removes
        -:  664:			 *				datum translation ratios.
        -:  665:			 */
        -:  666:		template<class Unit>
        -:  667:		struct cubed_impl
        -:  668:		{
        -:  669:			static_assert(is_unit<Unit>::value, "Template parameter `Unit` must be a `unit` type.");
        -:  670:			using Conversion = typename Unit::conversion_ratio;
        -:  671:			using type = unit < std::ratio_multiply<Conversion, std::ratio_multiply<Conversion, Conversion>>,
        -:  672:				cubed_base<base_unit_of<typename Unit::base_unit_type>>,
        -:  673:				std::ratio_multiply<typename Unit::pi_exponent_ratio, std::ratio<3>>,
        -:  674:				std::ratio < 0 >> ;
        -:  675:		};
        -:  676:	}
        -:  677:	/** @endcond */	// END DOXYGEN IGNORE
        -:  678:
        -:  679:	/**
        -:  680:	 * @brief		represents the type of `class U` cubed.
        -:  681:	 * @ingroup		UnitManipulators
        -:  682:	 * @tparam		U	`unit` type to cube.
        -:  683:	 * @details		E.g. `cubed<meters>` will represent meters^3.
        -:  684:	 */
        -:  685:	template<class U>
        -:  686:	using cubed = typename detail::cubed_impl<U>::type;
        -:  687:
        -:  688:	//------------------------------
        -:  689:	//	COMPOUND UNITS
        -:  690:	//------------------------------
        -:  691:
        -:  692:	/** @cond */	// DOXYGEN IGNORE
        -:  693:	namespace detail
        -:  694:	{
        -:  695:		/**
        -:  696:			 * @brief		implementation of compound_unit
        -:  697:			 * @details		multiplies a variadic list of units together, and is inherited from the resulting
        -:  698:			 *				type.
        -:  699:			 */
        -:  700:		template<class U, class... Us> struct compound_impl;
        -:  701:		template<class U> struct compound_impl<U> { using type = U; };
        -:  702:		template<class U1, class U2, class...Us>
        -:  703:		struct compound_impl<U1, U2, Us...>
        -:  704:			: compound_impl<unit_multiply<U1, U2>, Us...> {};
        -:  705:	}
        -:  706:	/** @endcond */	// END DOXYGEN IGNORE
        -:  707:
        -:  708:	/**
        -:  709:	 * @brief		Represents a unit type made up from other units.
        -:  710:	 * @details		Compound units are formed by multiplying the units of all the types provided in
        -:  711:	 *				the template argument. Types provided must inherit from `unit`. A compound unit can
        -:  712:	 *				be formed from any number of other units, and unit manipulators like `inverse` and
        -:  713:	 *				`squared` are supported. E.g. to specify acceleration, on could create
        -:  714:	 *				`using acceleration = compound_unit<length::meters, inverse<squared<seconds>>;`
        -:  715:	 * @tparam		U...	units which, when multiplied together, form the desired compound unit.
        -:  716:	 * @ingroup		UnitTypes
        -:  717:	 */
        -:  718:	template<class U, class... Us>
        -:  719:	using compound_unit = typename detail::compound_impl<U, Us...>::type;
        -:  720:
        -:  721:	//------------------------------
        -:  722:	//	PREFIXES
        -:  723:	//------------------------------
        -:  724:
        -:  725:	/** @cond */	// DOXYGEN IGNORE
        -:  726:	namespace detail
        -:  727:	{
        -:  728:		/**
        -:  729:			 * @brief		prefix applicator.
        -:  730:			 * @details		creates a unit type from a prefix and a unit
        -:  731:			 */
        -:  732:		template<class Ratio, class Unit>
        -:  733:		struct prefix
        -:  734:		{
        -:  735:			static_assert(is_ratio<Ratio>::value, "Template parameter `Ratio` must be a `std::ratio`.");
        -:  736:			static_assert(is_unit<Unit>::value, "Template parameter `Unit` must be a `unit` type.");
        -:  737:			typedef typename units::unit<Ratio, Unit> type;
        -:  738:		};
        -:  739:	}
        -:  740:	/** @endcond */	// END DOXYGEN IGNORE
        -:  741:
        -:  742:	/**
        -:  743:	 * @ingroup UnitManipulators
        -:  744:	 * @{
        -:  745:	 * @ingroup Prefixes
        -:  746:	 * @{
        -:  747:	 */
        -:  748:	template<class U> using atto = typename detail::prefix<std::atto, U>::type;								///< Represents the type of `class U` with the metric 'atto' prefix appended.  @details E.g. atto<meters> represents meters*10^-21	@tparam U unit type to apply the prefix to.
        -:  749:	template<class U> using femto = typename detail::prefix<std::femto, U>::type;							///< Represents the type of `class U` with the metric 'atto' prefix appended.  @details E.g. femto<meters> represents meters*10^-18	@tparam U unit type to apply the prefix to.
        -:  750:	template<class U> using pico = typename detail::prefix<std::pico, U>::type;								///< Represents the type of `class U` with the metric 'femto' prefix appended. @details E.g. pico<meters> represents meters*10^-15	@tparam U unit type to apply the prefix to.
        -:  751:	template<class U> using nano = typename detail::prefix<std::nano, U>::type;								///< Represents the type of `class U` with the metric 'pico' prefix appended.  @details E.g. nano<meters> represents meters*10^-12	@tparam U unit type to apply the prefix to.
        -:  752:	template<class U> using micro = typename detail::prefix<std::micro, U>::type;							///< Represents the type of `class U` with the metric 'nano' prefix appended.  @details E.g. micro<meters> represents meters*10^-9	@tparam U unit type to apply the prefix to.
        -:  753:	template<class U> using milli = typename detail::prefix<std::milli, U>::type;							///< Represents the type of `class U` with the metric 'micro' prefix appended. @details E.g. milli<meters> represents meters*10^-6	@tparam U unit type to apply the prefix to.
        -:  754:	template<class U> using centi = typename detail::prefix<std::centi, U>::type;							///< Represents the type of `class U` with the metric 'milli' prefix appended. @details E.g. centi<meters> represents meters*10^-3	@tparam U unit type to apply the prefix to.
        -:  755:	template<class U> using deci = typename detail::prefix<std::deci, U>::type;								///< Represents the type of `class U` with the metric 'centi' prefix appended. @details E.g. deci<meters> represents meters*10^-2	@tparam U unit type to apply the prefix to.
        -:  756:	template<class U> using deca = typename detail::prefix<std::deca, U>::type;								///< Represents the type of `class U` with the metric 'deci' prefix appended.  @details E.g. deca<meters> represents meters*10^-1	@tparam U unit type to apply the prefix to.
        -:  757:	template<class U> using hecto = typename detail::prefix<std::hecto, U>::type;							///< Represents the type of `class U` with the metric 'deca' prefix appended.  @details E.g. hecto<meters> represents meters*10^1	@tparam U unit type to apply the prefix to.
        -:  758:	template<class U> using kilo = typename detail::prefix<std::kilo, U>::type;								///< Represents the type of `class U` with the metric 'hecto' prefix appended. @details E.g. kilo<meters> represents meters*10^2	@tparam U unit type to apply the prefix to.
        -:  759:	template<class U> using mega = typename detail::prefix<std::mega, U>::type;								///< Represents the type of `class U` with the metric 'kilo' prefix appended.  @details E.g. mega<meters> represents meters*10^3	@tparam U unit type to apply the prefix to.
        -:  760:	template<class U> using giga = typename detail::prefix<std::giga, U>::type;								///< Represents the type of `class U` with the metric 'mega' prefix appended.  @details E.g. giga<meters> represents meters*10^6	@tparam U unit type to apply the prefix to.
        -:  761:	template<class U> using tera = typename detail::prefix<std::tera, U>::type;								///< Represents the type of `class U` with the metric 'giga' prefix appended.  @details E.g. tera<meters> represents meters*10^9	@tparam U unit type to apply the prefix to.
        -:  762:	template<class U> using peta = typename detail::prefix<std::peta, U>::type;								///< Represents the type of `class U` with the metric 'tera' prefix appended.  @details E.g. peta<meters> represents meters*10^12	@tparam U unit type to apply the prefix to.
        -:  763:	template<class U> using exa = typename detail::prefix<std::exa, U>::type;								///< Represents the type of `class U` with the metric 'peta' prefix appended.  @details E.g. exa<meters> represents meters*10^15	@tparam U unit type to apply the prefix to.
        -:  764:	/** @} @} */
        -:  765:
        -:  766:	//------------------------------
        -:  767:	//	CONVERSION TRAITS
        -:  768:	//------------------------------
        -:  769:
        -:  770:	/**
        -:  771:	 * @ingroup		TypeTraits
        -:  772:	 * @brief		Trait which checks whether two units can be converted to each other
        -:  773:	 * @details		Inherits from `std::true_type` or `std::false_type`. Use `is_convertible_unit<U1, U2>::value` to test
        -:  774:	 *				whether `class U1` is convertible to `class U2`. Note: convertible has both the semantic meaning,
        -:  775:	 *				(i.e. meters can be converted to feet), and the c++ meaning of conversion (type meters can be
        -:  776:	 *				converted to type feet). Conversion is always symmetric, so if U1 is convertible to U2, then
        -:  777:	 *				U2 will be convertible to U1.
        -:  778:	 * @tparam		U1 Unit to convert from.
        -:  779:	 * @tparam		U2 Unit to convert to.
        -:  780:	 * @sa			is_convertible_unit_t
        -:  781:	 */
        -:  782:	template<class U1, class U2>
        -:  783:	struct is_convertible_unit : std::is_same <base_unit_of<typename unit_traits<U1>::base_unit_type>,
        -:  784:		base_unit_of<typename unit_traits<U2>::base_unit_type >> {};
        -:  785:
        -:  786:	//------------------------------
        -:  787:	//	CONVERSION FUNCTION
        -:  788:	//------------------------------
        -:  789:
        -:  790:	/** @cond */	// DOXYGEN IGNORE
        -:  791:	namespace detail
        -:  792:	{
        -:  793:		/// convert dispatch for units which are both the same
        -:  794:		template<class, class, typename T>
       51:  795:		static inline T convert(const T& value, std::true_type, std::false_type, std::false_type)
        -:  796:		{
       51:  797:			return value;
        -:  798:		}
        -:  799:
        -:  800:		/// convert dispatch for units which are both the same
        -:  801:		template<class, class, typename T>
        1:  802:		static inline T convert(const T& value, std::true_type, std::false_type, std::true_type)
        -:  803:		{
        1:  804:			return value;
        -:  805:		}
        -:  806:
        -:  807:		/// convert dispatch for units which are both the same
        -:  808:		template<class, class, typename T>
        2:  809:		static inline T convert(const T& value, std::true_type, std::true_type, std::false_type)
        -:  810:		{
        2:  811:			return value;
        -:  812:		}
        -:  813:
        -:  814:		/// convert dispatch for units which are both the same
        -:  815:		template<class, class, typename T>
        -:  816:		static inline T convert(const T& value, std::true_type, std::true_type, std::true_type)
        -:  817:		{
        -:  818:			return value;
        -:  819:		}
        -:  820:
        -:  821:		/// convert dispatch for units of different types w/ no translation and no PI
        -:  822:		template<class UnitFrom, class UnitTo, typename T>
      287:  823:		static inline T convert(const T& value, std::false_type, std::false_type, std::false_type)
        -:  824:		{
        -:  825:			using Ratio = std::ratio_divide<typename UnitFrom::conversion_ratio, typename UnitTo::conversion_ratio>;
      287:  826:			return (double(Ratio::num) * value / Ratio::den);
        -:  827:		}
        -:  828:
        -:  829:		/// convert dispatch for units of different types w/ no translation, but has PI
        -:  830:		template<class UnitFrom, class UnitTo, typename T>
       25:  831:		static inline T convert(const T& value, std::false_type, std::true_type, std::false_type)
        -:  832:		{
        -:  833:			using Ratio = std::ratio_divide<typename UnitFrom::conversion_ratio, typename UnitTo::conversion_ratio>;
        -:  834:			using PiRatio = std::ratio_subtract<typename UnitFrom::pi_exponent_ratio, typename UnitTo::pi_exponent_ratio>;
       25:  835:			return ((double(Ratio::num) * value / Ratio::den) * std::pow(constants::PI, (double(PiRatio::num) / PiRatio::den)));
        -:  836:		}
        -:  837:
        -:  838:		/// convert dispatch for units of different types with a translation, but no PI
        -:  839:		template<class UnitFrom, class UnitTo, typename T>
       15:  840:		static inline T convert(const T& value, std::false_type, std::false_type, std::true_type)
        -:  841:		{
        -:  842:			using Ratio = std::ratio_divide<typename UnitFrom::conversion_ratio, typename UnitTo::conversion_ratio>;
        -:  843:			using Translation = std::ratio_divide<std::ratio_subtract<typename UnitFrom::translation_ratio, typename UnitTo::translation_ratio>, typename UnitTo::conversion_ratio>;
       15:  844:			return ((double(Ratio::num) * value / Ratio::den) + (double(Translation::num) / Translation::den));
        -:  845:		}
        -:  846:
        -:  847:		/// convert dispatch for units of different types with a translation AND PI
        -:  848:		template<class UnitFrom, class UnitTo, typename T>
        -:  849:		static inline T convert(const T& value, std::false_type, std::true_type, std::true_type)
        -:  850:		{
        -:  851:			using Ratio = std::ratio_divide<typename UnitFrom::conversion_ratio, typename UnitTo::conversion_ratio>;
        -:  852:			using Translation = std::ratio_divide<std::ratio_subtract<typename UnitFrom::translation_ratio, typename UnitTo::translation_ratio>, typename UnitTo::conversion_ratio>;
        -:  853:			using PiRatio = std::ratio_subtract<typename UnitFrom::pi_exponent_ratio, typename UnitTo::pi_exponent_ratio>;
        -:  854:			return ((double(Ratio::num) * value / Ratio::den) * std::pow(constants::PI, (double(PiRatio::num) / PiRatio::den)) + (double(Translation::num) / Translation::den));
        -:  855:		}
        -:  856:	}
        -:  857:	/** @endcond */	// END DOXYGEN IGNORE
        -:  858:
        -:  859:
        -:  860:	/**
        -:  861:	 * @ingroup		Conversion
        -:  862:	 * @brief		converts a <i>value</i> from one type to another.
        -:  863:	 * @details		Converts a <i>value</i> of a built-in arithmetic type to another unit. This does not change
        -:  864:	 *				the type of <i>value</i>, only what it contains. E.g. @code double result = convert<length::meters, length::feet>(1.0);	// result == 3.28084 @endcode
        -:  865:	 * @sa			unit_t	for implicit conversion of unit containers.
        -:  866:	 * @tparam		UnitFrom unit tag to convert <i>value</i> from. Must be a `unit` type (i.e. is_unit<UnitFrom>::value == true),
        -:  867:	 *				and must be convertible to `UnitTo` (i.e. is_converitble_unit<UnitFrom, UnitTo>::value == true).
        -:  868:	 * @tparam		UnitTo unit tag to convert <i>value</i> to. Must be a `unit` type (i.e. is_unit<UnitTo>::value == true),
        -:  869:	 *				and must be convertible from `UnitFrom` (i.e. is_converitble_unit<UnitFrom, UnitTo>::value == true).
        -:  870:	 * @tparam		T type of <i>value</i>. It is infered from <i>value</i>, and is expected to be a built-in arethmetic type.
        -:  871:	 * @param[in]	value Arithmetic value to convert from `UnitFrom` to `UnitTo`. The value should represent
        -:  872:	 *				a quantity in units of `UnitFrom`.
        -:  873:	 * @returns		value, converted from units of `UnitFrom` to `UnitTo`.
        -:  874:	 */
        -:  875:	template<class UnitFrom, class UnitTo, typename T = double>
      381:  876:	static inline T convert(const T& value)
        -:  877:	{
        -:  878:		static_assert(is_unit<UnitFrom>::value, "Template parameter `UnitFrom` must be a `unit` type.");
        -:  879:		static_assert(is_unit<UnitTo>::value, "Template parameter `UnitTo` must be a `unit` type.");
        -:  880:		static_assert(is_convertible_unit<UnitFrom, UnitTo>::value, "Units are not compatible.");
        -:  881:
        -:  882:		using isSame = typename std::is_same<typename std::decay<UnitFrom>::type, typename std::decay<UnitTo>::type>::type;
        -:  883:		using piRequired = std::integral_constant<bool, !(std::is_same<std::ratio<0>, typename UnitFrom::pi_exponent_ratio>::value &&
        -:  884:			std::is_same<std::ratio<0>, typename UnitTo::pi_exponent_ratio>::value)>;
        -:  885:		using translationRequired = std::integral_constant<bool, !(std::is_same<std::ratio<0>, typename UnitFrom::translation_ratio>::value &&
        -:  886:			std::is_same<std::ratio<0>, typename UnitTo::translation_ratio>::value)>;
        -:  887:
      381:  888:		return detail::convert<UnitFrom, UnitTo, T>(value, isSame{}, piRequired{}, translationRequired{});
        -:  889:	};
        -:  890:
        -:  891:	//----------------------------------
        -:  892:	//	NON-LINEAR SCALE TRAITS
        -:  893:	//----------------------------------
        -:  894:
        -:  895:	/** @cond */	// DOXYGEN IGNORE
        -:  896:	namespace detail
        -:  897:	{
        -:  898:		/**
        -:  899:			 * @brief		implementation of has_operator_parenthesis
        -:  900:			 * @details		checks that operator() returns the same type as `Ret`
        -:  901:			 */
        -:  902:		template<class T, class Ret>
        -:  903:		struct has_operator_parenthesis_impl
        -:  904:		{
        -:  905:			template<class U>
        -:  906:			static auto test(U*) -> decltype(std::declval<U>()());
        -:  907:			template<typename>
        -:  908:			static std::false_type test(...);
        -:  909:
        -:  910:			using type = typename std::is_same<Ret, decltype(test<T>(0))>::type;
        -:  911:		};
        -:  912:	}
        -:  913:
        -:  914:	/**
        -:  915:	 * @brief		checks that `class T` has an `operator()` member which returns `Ret`
        -:  916:	 * @details		used as part of the linear_scale concept.
        -:  917:	 */
        -:  918:	template<class T, class Ret>
        -:  919:	struct has_operator_parenthesis : detail::has_operator_parenthesis_impl<T, Ret>::type {};
        -:  920:
        -:  921:	namespace detail
        -:  922:	{
        -:  923:		/**
        -:  924:			* @brief		implementation of has_value_member
        -:  925:			* @details		checks for a member named `m_member` with type `Ret`
        -:  926:			*/
        -:  927:		template<class T, class Ret>
        -:  928:		struct has_value_member_impl
        -:  929:		{
        -:  930:			template<class U>
        -:  931:			static auto test(U* p) -> decltype(p->m_value);
        -:  932:			template<typename>
        -:  933:			static auto test(...)->std::false_type;
        -:  934:
        -:  935:			using type = typename std::is_same<typename std::decay<Ret>::type, typename std::decay<decltype(test<T>(0))>::type>::type;
        -:  936:		};
        -:  937:	}
        -:  938:
        -:  939:	/**
        -:  940:	 * @brief		checks for a member named `m_member` with type `Ret`
        -:  941:	 * @details		used as part of the linear_scale concept checker.
        -:  942:	 */
        -:  943:	template<class T, class Ret>
        -:  944:	struct has_value_member : detail::has_value_member_impl<T, Ret>::type {};
        -:  945:	/** @endcond */	// END DOXYGEN IGNORE
        -:  946:
        -:  947:	/**
        -:  948:	 * @ingroup		TypeTraits
        -:  949:	 * @brief		Tests that `class T` meets the requirements for a non-linear scale
        -:  950:	 * @details		A non-linear scale must:
        -:  951:	 *				- be default constructible
        -:  952:	 *				- have an `operator()` member which returns the non-linear value stored in the scale
        -:  953:	 *				- have an accessible `m_value` member type which stores the linearized value in the scale.
        -:  954:	 *
        -:  955:	 *				Linear/nonlinear scales are used by `units::unit` to store values and scale them
        -:  956:	 *				if they represent things like dB.
        -:  957:	 */
        -:  958:	template<class T, class Ret>
        -:  959:	struct is_nonlinear_scale : std::integral_constant<bool,
        -:  960:		std::is_default_constructible<T>::value &&
        -:  961:		has_operator_parenthesis<T, Ret>::value &&
        -:  962:		has_value_member<T, Ret>::value>
        -:  963:	{};
        -:  964:
        -:  965:	//------------------------------
        -:  966:	//	UNIT_T TYPE TRAITS
        -:  967:	//------------------------------
        -:  968:
        -:  969:	/** @cond */	// DOXYGEN IGNORE
        -:  970:	/**
        -:  971:	 * @brief		unit_t_traits specialization for things which are not unit_t
        -:  972:	 * @details
        -:  973:	 */
        -:  974:	template<typename T, typename = void>
        -:  975:	struct unit_t_traits
        -:  976:	{
        -:  977:		typedef void non_linear_scale_type;
        -:  978:		typedef void underlying_type;
        -:  979:		typedef void unit_type;
        -:  980:	};
        -:  981:	/** @endcond */	// END DOXYGEN IGNORE
        -:  982:
        -:  983:	/**
        -:  984:	 * @ingroup		TypeTraits
        -:  985:	 * @brief		Trait for accessing the publically defined types of `units::unit_t`
        -:  986:	 * @details
        -:  987:	 */
        -:  988:	template<typename T>
        -:  989:	struct unit_t_traits <T, typename void_t<
        -:  990:		typename T::non_linear_scale_type,
        -:  991:		typename T::underlying_type,
        -:  992:		typename T::unit_type>::type>
        -:  993:	{
        -:  994:		typedef typename T::non_linear_scale_type non_linear_scale_type;
        -:  995:		typedef typename T::underlying_type underlying_type;
        -:  996:		typedef typename T::unit_type unit_type;
        -:  997:	};
        -:  998:
        -:  999:	/**
        -: 1000:	 * @ingroup		TypeTraits
        -: 1001:	 * @brief		Trait which tests whether two container types derived from `unit_t` are convertible to each other
        -: 1002:	 * @details		Inherits from `std::true_type` or `std::false_type`. Use `is_convertible_unit_t<U1, U2>::value` to test
        -: 1003:	 *				whether `class U1` is convertible to `class U2`. Note: convertible has both the semantic meaning,
        -: 1004:	 *				(i.e. meters can be converted to feet), and the c++ meaning of conversion (type meters can be
        -: 1005:	 *				converted to type feet). Conversion is always symmetric, so if U1 is convertible to U2, then
        -: 1006:	 *				U2 will be convertible to U1.
        -: 1007:	 * @tparam		U1 Unit to convert from.
        -: 1008:	 * @tparam		U2 Unit to convert to.
        -: 1009:	 * @sa			is_convertible_unit
        -: 1010:	 */
        -: 1011:	template<class U1, class U2>
        -: 1012:	struct is_convertible_unit_t : std::integral_constant<bool,
        -: 1013:		is_convertible_unit<typename unit_t_traits<U1>::unit_type, typename unit_t_traits<U2>::unit_type>::value>
        -: 1014:	{};
        -: 1015:
        -: 1016:	//---------------------------------- 
        -: 1017:	//	UNIT TYPE
        -: 1018:	//----------------------------------
        -: 1019:
        -: 1020:	/** @cond */	// DOXYGEN IGNORE
        -: 1021:	// forward declaration
        -: 1022:	template<typename T> struct linear_scale;
        -: 1023:	/** @endcond */	// END DOXYGEN IGNORE
        -: 1024:
        -: 1025:	/**
        -: 1026:	 * @ingroup		UnitContainers
        -: 1027:	 * @brief		Container for values which represent quantities of a given unit.
        -: 1028:	 * @details		Stores a value which represents a quantity in the given units. Unit containers
        -: 1029:	 *				(except scalar values) are *not* convertible to built-in c++ types, in order to
        -: 1030:	 *				provide type safety in dimensional analysis. Unit containers *are* implicitely
        -: 1031:	 *				convertible to other compatible unit container types. Unit containers support
        -: 1032:	 *				various types of arithmetic operations, depending on their scale type.
        -: 1033:	 *
        -: 1034:	 *				The value of a `unit_t` can only be changed on construction, or by assignment
        -: 1035:	 *				from another `unit_t` type. If necessary, the underlying value can be accessed
        -: 1036:	 *				using `operator()`: @code
        -: 1037:	 *				meter_t m(5.0);
        -: 1038:	 *				double val = m(); // val == 5.0	@endcode.
        -: 1039:	 * @tparam		Units unit tag for which type of units the `unit_t` represents (e.g. meters)
        -: 1040:	 * @tparam		T underlying type of the storage. Defaults to double.
        -: 1041:	 * @tparam		NonLinearScale optional scale class for the units. Defaults to linear (i.e. does
        -: 1042:	 *				not scale the unit value). Examples of non-linear scales could be logarithmic,
        -: 1043:	 *				decibel, or richter scales. Non-linear scales must adhere to the non-linear-scale
        -: 1044:	 *				concept, i.e. `is_nonlinear_scale<...>::value` must be `true`.
        -: 1045:	 * @sa
        -: 1046:	 *				- \ref lengthContainers "length unit containers"
        -: 1047:	 *				- \ref massContainers "mass unit containers"
        -: 1048:	 *				- \ref timeContainers "time unit containers"
        -: 1049:	 *				- \ref angleContainers "angle unit containers"
        -: 1050:	 *				- \ref currentContainers "current unit containers"
        -: 1051:	 *				- \ref temperatureContainers "temperature unit containers"
        -: 1052:	 *				- \ref substanceContainers "substance unit containers"
        -: 1053:	 *				- \ref luminousIntensityContainers "luminous intensity unit containers"
        -: 1054:	 *				- \ref solidAngleContainers "solid angle unit containers"
        -: 1055:	 *				- \ref frequencyContainers "frequency unit containers"
        -: 1056:	 *				- \ref velocityContainers "velocity unit containers"
        -: 1057:	 *				- \ref angularVelocityContainers "angular velocity unit containers"
        -: 1058:	 *				- \ref accelerationContainers "acceleration unit containers"
        -: 1059:	 *				- \ref forceContainers "force unit containers"
        -: 1060:	 *				- \ref pressureContainers "pressure unit containers"
        -: 1061:	 *				- \ref chargeContainers "charge unit containers"
        -: 1062:	 *				- \ref energyContainers "energy unit containers"
        -: 1063:	 *				- \ref powerContainers "power unit containers"
        -: 1064:	 *				- \ref voltageContainers "voltage unit containers"
        -: 1065:	 *				- \ref capacitanceContainers "capacitance unit containers"
        -: 1066:	 *				- \ref impedanceContainers "impedance unit containers"
        -: 1067:	 *				- \ref magneticFluxContainers "magnetic flux unit containers"
        -: 1068:	 *				- \ref magneticFieldStrengthContainers "magnetic field strength unit containers"
        -: 1069:	 *				- \ref inductanceContainers "inductance unit containers"
        -: 1070:	 *				- \ref luminousFluxContainers "luminous flux unit containers"
        -: 1071:	 *				- \ref illuminanceContainers "illuminance unit containers"
        -: 1072:	 *				- \ref radiationContainers "radiation unit containers"
        -: 1073:	 *				- \ref torqueContainers "torque unit containers"
        -: 1074:	 *				- \ref areaContainers "area unit containers"
        -: 1075:	 *				- \ref volumeContainers "volume unit containers"
        -: 1076:	 *				- \ref densityContainers "density unit containers"
        -: 1077:	 *				- \ref concentrationContainers "concentration unit containers"
        -: 1078:	 *				- \ref constantContainers "constant unit containers"
        -: 1079:	 */
        -: 1080:	template<class Units, typename T = double, template<typename> class NonLinearScale = linear_scale>
        -: 1081:	class unit_t : public NonLinearScale<T>
        -: 1082:	{
        -: 1083:		static_assert(units::is_nonlinear_scale<NonLinearScale<T>, T>::value, "Template parameter `NonLinearScale` does not conform to the `is_nonlinear_scale` concept.");
        -: 1084:
        -: 1085:	protected:
        -: 1086:
        -: 1087:		using nls = NonLinearScale<T>;
        -: 1088:		using nls::m_value;
        -: 1089:
        -: 1090:	public:
        -: 1091:
        -: 1092:		typedef NonLinearScale<T> non_linear_scale_type;											///< Type of the non-linear scale of the unit_t (e.g. linear_scale)
        -: 1093:		typedef T underlying_type;																	///< Type of the underlying storage of the unit_t (e.g. double)
        -: 1094:		typedef Units unit_type;																	///< Type of `unit` the `unit_t` represents (e.g. meters)
        -: 1095:
        -: 1096:		/**
        -: 1097:		 * @ingroup		Constructors
        -: 1098:		 * @brief		default constructor.
        -: 1099:		 */
       19: 1100:		inline unit_t() : NonLinearScale<T>(0) {};
        -: 1101:
        -: 1102:
        -: 1103:		/**
        -: 1104:		 * @brief		constructor
        -: 1105:		 * @details		constructs a new unit_t using the non-linear scale's constructor.
        -: 1106:		 * @param[in]	args	constructor arguments are forwarded to the non-linear scale constructor. Which
        -: 1107:		 *				args are required depends on which scale is used. For the default (linear) scale,
        -: 1108:		 *				a single double-type value should be given.
        -: 1109:		 */
        -: 1110:		template<class... Args>
      119: 1111:		inline explicit unit_t(const Args&... args) : nls(args...) {};
        -: 1112:
        -: 1113:		/**
        -: 1114:		 * @brief		constructor
        -: 1115:		 * @details		enable implicit conversions from T types ONLY for linear scalar units
        -: 1116:		 * @param[in]	value value of the unit_t
        -: 1117:		 */
        -: 1118:		template<class Ty, class = typename std::enable_if<std::is_same<base_unit_of<Units>, category::scalar_unit>::value && std::is_arithmetic<Ty>::value>::type>
       82: 1119:		inline unit_t(Ty value) : nls(value) {};
        -: 1120:
        -: 1121:		/**
        -: 1122:		 * @brief		copy constructor
        -: 1123:		 * @details		performs implicit unit conversions if required.
        -: 1124:		 * @param[in]	rhs unit to copy.
        -: 1125:		 */
        -: 1126:		template<class UnitsRhs, typename Ty, template<typename> class NlsRhs>
       11: 1127:		inline unit_t(const unit_t<UnitsRhs, Ty, NlsRhs>& rhs)
       11: 1128:		{
       11: 1129:			nls::m_value = units::convert<UnitsRhs, Units, T>(rhs.m_value);
       11: 1130:		};
        -: 1131:
        -: 1132:		/**
        -: 1133:		 * @brief		assignment
        -: 1134:		 * @details		performs implicit unit conversions if required
        -: 1135:		 * @param[in]	rhs unit to copy.
        -: 1136:		 */
        -: 1137:		template<class UnitsRhs, typename Ty, template<typename> class NlsRhs>
        8: 1138:		inline unit_t& operator=(const unit_t<UnitsRhs, Ty, NlsRhs>& rhs)
        -: 1139:		{
        8: 1140:			nls::m_value = units::convert<UnitsRhs, Units, T>(rhs.m_value);
        8: 1141:			return *this;
        -: 1142:		}
        -: 1143:
        -: 1144:		/**
        -: 1145:		* @brief		assignment
        -: 1146:		* @details		performs implicit conversions from built-in types ONLY for scalar units
        -: 1147:		* @param[in]	rhs value to copy.
        -: 1148:		*/
        -: 1149:		template<class Ty, class = typename std::enable_if<std::is_same<base_unit_of<Units>, category::scalar_unit>::value && std::is_arithmetic<Ty>::value>::type>
        -: 1150:		inline unit_t& operator=(Ty rhs)
        -: 1151:		{
        -: 1152:			nls::m_value = rhs;
        -: 1153:			return *this;
        -: 1154:		}
        -: 1155:
        -: 1156:		/**
        -: 1157:		 * @brief		less-than
        -: 1158:		 * @details		compares the linearized value of two units. Performs unit conversions if necessary.
        -: 1159:		 * @param[in]	rhs right-hand side unit for the comparison
        -: 1160:		 * @returns		true IFF the value of `this` is less than the value of `rhs`
        -: 1161:		 */
        -: 1162:		template<class UnitsRhs, typename Ty, template<typename> class NlsRhs>
        -: 1163:		inline bool operator<(const unit_t<UnitsRhs, Ty, NlsRhs>& rhs) const
        -: 1164:		{
        -: 1165:			return (nls::m_value < units::convert<UnitsRhs, Units>(rhs.m_value));
        -: 1166:		}
        -: 1167:
        -: 1168:		/**
        -: 1169:		 * @brief		less-than or equal
        -: 1170:		 * @details		compares the linearized value of two units. Performs unit conversions if necessary.
        -: 1171:		 * @param[in]	rhs right-hand side unit for the comparison
        -: 1172:		 * @returns		true IFF the value of `this` is less than or equal to the value of `rhs`
        -: 1173:		 */
        -: 1174:		template<class UnitsRhs, typename Ty, template<typename> class NlsRhs>
        -: 1175:		inline bool operator<=(const unit_t<UnitsRhs, Ty, NlsRhs>& rhs) const
        -: 1176:		{
        -: 1177:			return (nls::m_value <= units::convert<UnitsRhs, Units>(rhs.m_value));
        -: 1178:		}
        -: 1179:
        -: 1180:		/**
        -: 1181:		 * @brief		greater-than
        -: 1182:		 * @details		compares the linearized value of two units. Performs unit conversions if necessary.
        -: 1183:		 * @param[in]	rhs right-hand side unit for the comparison
        -: 1184:		 * @returns		true IFF the value of `this` is greater than the value of `rhs`
        -: 1185:		 */
        -: 1186:		template<class UnitsRhs, typename Ty, template<typename> class NlsRhs>
        -: 1187:		inline bool operator>(const unit_t<UnitsRhs, Ty, NlsRhs>& rhs) const
        -: 1188:		{
        -: 1189:			return (nls::m_value > units::convert<UnitsRhs, Units>(rhs.m_value));
        -: 1190:		}
        -: 1191:
        -: 1192:		/**
        -: 1193:		 * @brief		greater-than or equal
        -: 1194:		 * @details		compares the linearized value of two units. Performs unit conversions if necessary.
        -: 1195:		 * @param[in]	rhs right-hand side unit for the comparison
        -: 1196:		 * @returns		true IFF the value of `this` is greater than or equal to the value of `rhs`
        -: 1197:		 */
        -: 1198:		template<class UnitsRhs, typename Ty, template<typename> class NlsRhs>
        -: 1199:		inline bool operator>=(const unit_t<UnitsRhs, Ty, NlsRhs>& rhs) const
        -: 1200:		{
        -: 1201:			return (nls::m_value >= units::convert<UnitsRhs, Units>(rhs.m_value));
        -: 1202:		}
        -: 1203:
        -: 1204:		/**
        -: 1205:		 * @brief		equality
        -: 1206:		 * @details		compares the linearized value of two units. Performs unit conversions if necessary.
        -: 1207:		 * @param[in]	rhs right-hand side unit for the comparison
        -: 1208:		 * @returns		true IFF the value of `this` exactly equal to the value of rhs.
        -: 1209:		 * @note		This may not be suitable for all applications when the underlying_type of unit_t is a double.
        -: 1210:		 */
        -: 1211:		template<class UnitsRhs, typename Ty, template<typename> class NlsRhs>
        -: 1212:		inline bool operator==(const unit_t<UnitsRhs, Ty, NlsRhs>& rhs) const
        -: 1213:		{
        -: 1214:			return (nls::m_value == units::convert<UnitsRhs, Units>(rhs.m_value));
        -: 1215:		}
        -: 1216:
        -: 1217:		/**
        -: 1218:		 * @brief		inequality
        -: 1219:		 * @details		compares the linearized value of two units. Performs unit conversions if necessary.
        -: 1220:		 * @param[in]	rhs right-hand side unit for the comparison
        -: 1221:		 * @returns		true IFF the value of `this` is not equal to the value of rhs.
        -: 1222:		 * @note		This may not be suitable for all applications when the underlying_type of unit_t is a double.
        -: 1223:		 */
        -: 1224:		template<class UnitsRhs, typename Ty, template<typename> class NlsRhs>
        -: 1225:		inline bool operator!=(const unit_t<UnitsRhs, Ty, NlsRhs>& rhs) const
        -: 1226:		{
        -: 1227:			return (nls::m_value != units::convert<UnitsRhs, Units>(rhs.m_value));
        -: 1228:		}
        -: 1229:
        -: 1230:		/**
        -: 1231:		 * @brief		unit value
        -: 1232:		 * @returns		value of the unit in it's underlying, non-safe type.
        -: 1233:		 */
      139: 1234:		inline T value() const
        -: 1235:		{
      139: 1236:			return (*this)();
        -: 1237:		}
        -: 1238:
        -: 1239:		/**
        -: 1240:		 * @brief		linearized unit value
        -: 1241:		 * @returns		linearized value of unit which has a non-linear scale. For `unit_t` types with
        -: 1242:		 *				linear scales, this is equivalent to `value`.
        -: 1243:		 */
       16: 1244:		inline T linearizedValue() const
        -: 1245:		{
       16: 1246:			return m_value;
        -: 1247:		}
        -: 1248:
        -: 1249:		/**
        -: 1250:		 * @brief		conversion
        -: 1251:		 * @details		Converts to a different unit container. Units can be converted to other containers
        -: 1252:		 *				implicitly, but this can be used in cases where explicit notation of a conversion
        -: 1253:		 *				is beneficial, or where an r-value container is needed.
        -: 1254:		 * @tparam		U unit (not unit_t) to convert to
        -: 1255:		 * @returns		a unit container with the specified units containing the equivalent value to
        -: 1256:		 *				*this.
        -: 1257:		 */
        -: 1258:		template<class U>
        1: 1259:		inline auto convert() const -> unit_t<U>
        -: 1260:		{
        -: 1261:			static_assert(units::is_unit<U>::value, "Template parameter `U` must be a unit type.");
        1: 1262:			return unit_t<U>(*this);
        -: 1263:		}
        -: 1264:
        -: 1265:		/**
        -: 1266:		 * @brief		implicit type conversion.
        -: 1267:		 * @details		only enabled for scalar unit types.
        -: 1268:		 */
        -: 1269:		template<class Ty, class = typename std::enable_if<std::is_same<base_unit_of<Units>, category::scalar_unit>::value && std::is_arithmetic<Ty>::value>::type>
       29: 1270:		operator Ty() const { return  units::convert<Units, unit<std::ratio<1>, category::scalar_unit>>(nls::m_value); }
        -: 1271:
        -: 1272:	public:
        -: 1273:
        -: 1274:		template<class U, typename Ty, template<typename> class Nlt>
        -: 1275:		friend class unit_t;
        -: 1276:
        -: 1277:	};
        -: 1278:
        -: 1279:	template<class Units, typename T, template<typename> class NonLinearScale>
        3: 1280:	std::ostream& operator<<(std::ostream& os, const unit_t<Units, T, NonLinearScale>& obj)
        -: 1281:	{
        3: 1282:		os << obj.value();
        3: 1283:		return os;
        -: 1284:	}
        -: 1285:
        -: 1286:	//------------------------------
        -: 1287:	//	NON-LINEAR SCALE TRAITS
        -: 1288:	//------------------------------
        -: 1289:
        -: 1290:	// forward declaration
        -: 1291:	template<typename T> struct decibel_scale;
        -: 1292:
        -: 1293:	/**
        -: 1294:	 * @ingroup		TypeTraits
        -: 1295:	 * @brief		Trait which tests whether a type is inherited from a linear scale.
        -: 1296:	 * @details		Inherits from `std::true_type` or `std::false_type`. Use `has_linear_scale<U1 [, U2, ...]>::value` to test
        -: 1297:	 *				one or more types to see if they represent unit_t's whose scale is linear.
        -: 1298:	 * @tparam		T	one or more types to test.
        -: 1299:	 */
        -: 1300:	template<typename... T>
        -: 1301:	struct has_linear_scale : std::integral_constant<bool,
        -: 1302:		all_true<std::is_base_of<linear_scale<typename unit_t_traits<T>::underlying_type>, T>::value...>::value >
        -: 1303:	{};
        -: 1304:
        -: 1305:	/**
        -: 1306:	 * @ingroup		TypeTraits
        -: 1307:	 * @brief		Trait which tests whether a type is inherited from a decibel scale.
        -: 1308:	 * @details		Inherits from `std::true_type` or `std::false_type`. Use `has_decibel_scale<U1 [, U2, ...]>::value` to test
        -: 1309:	 *				one or more types to see if they represent unit_t's whose scale is in decibels.
        -: 1310:	 * @tparam		T	one or more types to test.
        -: 1311:	 */
        -: 1312:	template<typename... T>
        -: 1313:	struct has_decibel_scale : std::integral_constant<bool,
        -: 1314:		all_true<std::is_base_of<decibel_scale<typename unit_t_traits<T>::underlying_type>, T>::value...>::value>
        -: 1315:	{};
        -: 1316:
        -: 1317:	/**
        -: 1318:	 * @ingroup		TypeTraits
        -: 1319:	 * @brief		Trait which tests whether two types has the same non-linear scale.
        -: 1320:	 * @details		Inherits from `std::true_type` or `std::false_type`. Use `is_same_scale<U1 , U2>::value` to test
        -: 1321:	 *				whether two types have the same non-linear scale.
        -: 1322:	 * @tparam		T1	left hand type.
        -: 1323:	 * @tparam		T2	right hand type
        -: 1324:	 */
        -: 1325:	template<typename T1, typename T2>
        -: 1326:	struct is_same_scale : std::integral_constant<bool,
        -: 1327:		std::is_same<typename unit_t_traits<T1>::non_linear_scale_type, typename unit_t_traits<T2>::non_linear_scale_type>::value>
        -: 1328:	{};
        -: 1329:
        -: 1330:	//----------------------------------
        -: 1331:	//	NON-LINEAR SCALES
        -: 1332:	//----------------------------------
        -: 1333:
        -: 1334:	// Non-linear transforms are used to pre and post scale units which are defined in terms of non-
        -: 1335:	// linear functions of their current value. A good example of a non-linear scale would be a 
        -: 1336:	// logarithmic or decibel scale
        -: 1337:
        -: 1338:	//------------------------------
        -: 1339:	//	LINEAR SCALE
        -: 1340:	//------------------------------
        -: 1341:
        -: 1342:	/**
        -: 1343:	 * @brief		unit_t scale which is linear
        -: 1344:	 * @details		Represents units on a linear scale. This is the appropriate unit_t scale for almost
        -: 1345:	 *				all units almost all of the time.
        -: 1346:	 * @tparam		T	underlying storage type
        -: 1347:	 * @sa			unit_t
        -: 1348:	 */
        -: 1349:	template<typename T>
        -: 1350:	struct linear_scale
        -: 1351:	{
        8: 1352:		inline linear_scale() : m_value(0) {}														///< default constructor.
      192: 1353:		inline linear_scale(T value) : m_value(value) {}											///< constructor.
      203: 1354:		inline T operator()() const { return m_value; }												///< returns value.
        -: 1355:
        -: 1356:		T m_value;																					///< linearized value.	
        -: 1357:	};
        -: 1358:
        -: 1359:	//----------------------------------
        -: 1360:	//	SCALAR (LINEAR) UNITS
        -: 1361:	//----------------------------------
        -: 1362:
        -: 1363:	// Scalar units are the *ONLY* units implicitly convertible to/from built-in types.
        -: 1364:	namespace dimensionless
        -: 1365:	{
        -: 1366:		using scalar = unit<std::ratio<1>, category::scalar_unit>;
        -: 1367:		using dimensionless = unit<std::ratio<1>, category::dimensionless_unit>;
        -: 1368:
        -: 1369:		using scalar_t = unit_t<scalar>;
        -: 1370:		using dimensionless_t = scalar_t;
        -: 1371:	}
        -: 1372:
        -: 1373:	namespace detail
        -: 1374:	{
        -: 1375:		template<class T> struct is_scalar_unit_impl : std::false_type {};
        -: 1376:		template<typename C, typename U, typename P, typename T>
        -: 1377:		struct is_scalar_unit_impl<unit<C, U, P, T>> : std::is_same<base_unit_of<typename unit_traits<unit<C, U, P, T>>::base_unit_type>, category::scalar_unit>::type {};
        -: 1378:		template<typename U, typename S, template<typename> class N>
        -: 1379:		struct is_scalar_unit_impl<unit_t<U, S, N>> : std::is_same<base_unit_of<typename unit_t_traits<unit_t<U, S, N>>::unit_type>, category::scalar_unit>::type {};
        -: 1380:	}
        -: 1381:
        -: 1382:	/**
        -: 1383:	 * @ingroup		TypeTraits
        -: 1384:	 * @brief		Trait which tests whether one or more types derived from `unit_t` represent scalar values.
        -: 1385:	 * @details		Inherits from `std::true_type` or `std::false_type`. Use `is_scalar_unit<U1 [, U2, ...]>::value` to test
        -: 1386:	 *				one or more types to see if they represent scalar value containers. A scalar unit is one which has no
        -: 1387:	 *				dimensions (e.g. PI).
        -: 1388:	 * @tparam		T	one or more types to test.
        -: 1389:	 */
        -: 1390:	template<class... T>
        -: 1391:	struct is_scalar_unit : std::integral_constant<bool, all_true<detail::is_scalar_unit_impl<typename std::decay<T>::type>::value...>::value> {};
        -: 1392:
        -: 1393:	//------------------------------
        -: 1394:	//	LINEAR ARITHMETIC
        -: 1395:	//------------------------------
        -: 1396:
        -: 1397:	template<class UnitTypeLhs, class UnitTypeRhs, typename std::enable_if<!is_same_scale<UnitTypeLhs, UnitTypeRhs>::value, int>::type = 0>
        -: 1398:	inline int operator+(const UnitTypeLhs& lhs, const UnitTypeRhs& rhs)
        -: 1399:	{
        -: 1400:		static_assert(is_same_scale<UnitTypeLhs, UnitTypeRhs>::value, "Cannot add units with different linear/non-linear scales.");
        -: 1401:		return 0;
        -: 1402:	}
        -: 1403:
        -: 1404:	/// Addition operator for unit_t types with a linear_scale.
        -: 1405:	template<class UnitTypeLhs, class UnitTypeRhs, typename std::enable_if<has_linear_scale<UnitTypeLhs, UnitTypeRhs>::value, int>::type = 0>
        5: 1406:	inline UnitTypeLhs operator+(const UnitTypeLhs& lhs, const UnitTypeRhs& rhs)
        -: 1407:	{
        5: 1408:		return UnitTypeLhs(lhs.value() + convert<typename unit_t_traits<UnitTypeRhs>::unit_type, typename unit_t_traits<UnitTypeLhs>::unit_type>(rhs.value()));
        -: 1409:	}
        -: 1410:
        -: 1411:	/// Addition operator for scalar unit_t types with a linear_scale. Scalar types can be implicitly converted to built-in types.
        -: 1412:	template<typename T, typename std::enable_if<std::is_arithmetic<T>::value, int>::type = 0>
        2: 1413:	inline dimensionless::scalar_t operator+(const dimensionless::scalar_t& lhs, T rhs)
        -: 1414:	{
        2: 1415:		return dimensionless::scalar_t(lhs.value() + rhs);
        -: 1416:	}
        -: 1417:
        -: 1418:	/// Addition operator for scalar unit_t types with a linear_scale. Scalar types can be implicitly converted to built-in types.
        -: 1419:	template<typename T, typename std::enable_if<std::is_arithmetic<T>::value, int>::type = 0>
        2: 1420:	inline dimensionless::scalar_t operator+(T lhs, const dimensionless::scalar_t& rhs)
        -: 1421:	{
        2: 1422:		return dimensionless::scalar_t(lhs + rhs.value());
        -: 1423:	}
        -: 1424:
        -: 1425:	/// Subtraction operator for unit_t types with a linear_scale.
        -: 1426:	template<class UnitTypeLhs, class UnitTypeRhs, typename std::enable_if<has_linear_scale<UnitTypeLhs, UnitTypeRhs>::value, int>::type = 0>
        5: 1427:	inline UnitTypeLhs operator-(const UnitTypeLhs& lhs, const UnitTypeRhs& rhs)
        -: 1428:	{
        5: 1429:		return UnitTypeLhs(lhs.value() - convert<typename unit_t_traits<UnitTypeRhs>::unit_type, typename unit_t_traits<UnitTypeLhs>::unit_type>(rhs.value()));
        -: 1430:	}
        -: 1431:
        -: 1432:	/// Subtraction operator for scalar unit_t types with a linear_scale. Scalar types can be implicitly converted to built-in types.
        -: 1433:	template<typename T, typename std::enable_if<std::is_arithmetic<T>::value, int>::type = 0>
        2: 1434:	inline dimensionless::scalar_t operator-(const dimensionless::scalar_t& lhs, T rhs)
        -: 1435:	{
        2: 1436:		return dimensionless::scalar_t(lhs.value() - rhs);
        -: 1437:	}
        -: 1438:
        -: 1439:	/// Subtraction operator for scalar unit_t types with a linear_scale. Scalar types can be implicitly converted to built-in types.
        -: 1440:	template<typename T, typename std::enable_if<std::is_arithmetic<T>::value, int>::type = 0>
        2: 1441:	inline dimensionless::scalar_t operator-(T lhs, const dimensionless::scalar_t& rhs)
        -: 1442:	{
        2: 1443:		return dimensionless::scalar_t(lhs - rhs.value());
        -: 1444:	}
        -: 1445:
        -: 1446:	/// Multiplication type for convertible unit_t types with a linear scale. @returns the multiplied value, with the same type as left-hand side unit.
        -: 1447:	template<class UnitTypeLhs, class UnitTypeRhs,
        -: 1448:		typename std::enable_if<is_convertible_unit_t<UnitTypeLhs, UnitTypeRhs>::value && has_linear_scale<UnitTypeLhs, UnitTypeRhs>::value, int>::type = 0>
       10: 1449:		inline auto operator*(const UnitTypeLhs& lhs, const UnitTypeRhs& rhs) -> unit_t<compound_unit<squared<typename unit_t_traits<UnitTypeLhs>::unit_type>>>
        -: 1450:	{
        -: 1451:		return  unit_t<compound_unit<squared<typename unit_t_traits<UnitTypeLhs>::unit_type>>>
       10: 1452:			(lhs.value() * convert<typename unit_t_traits<UnitTypeRhs>::unit_type, typename unit_t_traits<UnitTypeLhs>::unit_type>(rhs.value()));
        -: 1453:	}
        -: 1454:
        -: 1455:	/// Multiplication type for convertible unit_t types with a linear scale. @returns the multiplied value, whose type is a compound unit of the left and right hand side values.
        -: 1456:	template<class UnitTypeLhs, class UnitTypeRhs,
        -: 1457:		typename std::enable_if<!is_convertible_unit_t<UnitTypeLhs, UnitTypeRhs>::value && has_linear_scale<UnitTypeLhs, UnitTypeRhs>::value, int>::type = 0>
       23: 1458:		inline auto operator*(const UnitTypeLhs& lhs, const UnitTypeRhs& rhs) -> unit_t<compound_unit<typename unit_t_traits<UnitTypeLhs>::unit_type, typename unit_t_traits<UnitTypeRhs>::unit_type>>
        -: 1459:	{
        -: 1460:		return unit_t<compound_unit<typename unit_t_traits<UnitTypeLhs>::unit_type, typename unit_t_traits<UnitTypeRhs>::unit_type>>
       23: 1461:			(lhs.value() * rhs.value());
        -: 1462:	}
        -: 1463:
        -: 1464:	/// Multiplication by a scalar for unit_t types with a linear scale.
        -: 1465:	template<class UnitTypeLhs, typename T,
        -: 1466:		typename std::enable_if<std::is_arithmetic<T>::value && has_linear_scale<UnitTypeLhs>::value, int>::type = 0>
        4: 1467:		inline UnitTypeLhs operator*(const UnitTypeLhs& lhs, T rhs)
        -: 1468:	{
        4: 1469:		return UnitTypeLhs(lhs.value() * rhs);
        -: 1470:	}
        -: 1471:
        -: 1472:	/// Multiplication by a scalar for unit_t types with a linear scale.
        -: 1473:	template<class UnitTypeRhs, typename T,
        -: 1474:		typename std::enable_if<std::is_arithmetic<T>::value && has_linear_scale<UnitTypeRhs>::value, int>::type = 0>
        9: 1475:		inline UnitTypeRhs operator*(T lhs, const UnitTypeRhs& rhs)
        -: 1476:	{
        9: 1477:		return UnitTypeRhs(lhs * rhs.value());
        -: 1478:	}
        -: 1479:
        -: 1480:	/// Division for convertible unit_t types with a linear scale. @returns the lhs divided by rhs value, whose type is a scalar
        -: 1481:	template<class UnitTypeLhs, class UnitTypeRhs,
        -: 1482:		typename std::enable_if<is_convertible_unit_t<UnitTypeLhs, UnitTypeRhs>::value && has_linear_scale<UnitTypeLhs, UnitTypeRhs>::value, int>::type = 0>
        4: 1483:		inline dimensionless::scalar_t operator/(const UnitTypeLhs& lhs, const UnitTypeRhs& rhs)
        -: 1484:	{
        4: 1485:		return dimensionless::scalar_t(lhs.value() / convert<typename unit_t_traits<UnitTypeRhs>::unit_type, typename unit_t_traits<UnitTypeLhs>::unit_type>(rhs.value()));
        -: 1486:	}
        -: 1487:
        -: 1488:	/// Division for non-convertible unit_t types with a linear scale. @returns the lhs divided by the rhs, with a compound unit type of lhs/rhs 
        -: 1489:	template<class UnitTypeLhs, class UnitTypeRhs,
        -: 1490:		typename std::enable_if<!is_convertible_unit_t<UnitTypeLhs, UnitTypeRhs>::value && has_linear_scale<UnitTypeLhs, UnitTypeRhs>::value, int>::type = 0>
        6: 1491:		inline auto operator/(const UnitTypeLhs& lhs, const UnitTypeRhs& rhs) ->  unit_t<compound_unit<typename unit_t_traits<UnitTypeLhs>::unit_type, inverse<typename unit_t_traits<UnitTypeRhs>::unit_type>>>
        -: 1492:	{
        -: 1493:		return unit_t<compound_unit<typename unit_t_traits<UnitTypeLhs>::unit_type, inverse<typename unit_t_traits<UnitTypeRhs>::unit_type>>>
        6: 1494:			(lhs.value() / rhs.value());
        -: 1495:	}
        -: 1496:
        -: 1497:	/// Division by a scalar for unit_t types with a linear scale
        -: 1498:	template<class UnitTypeLhs, typename T,
        -: 1499:		typename std::enable_if<std::is_arithmetic<T>::value && has_linear_scale<UnitTypeLhs>::value, int>::type = 0>
        3: 1500:		inline UnitTypeLhs operator/(const UnitTypeLhs& lhs, T rhs)
        -: 1501:	{
        3: 1502:		return UnitTypeLhs(lhs.value() / rhs);
        -: 1503:	}
        -: 1504:
        -: 1505:	/// Division of a scalar  by a unit_t type with a linear scale
        -: 1506:	template<class UnitTypeRhs, typename T,
        -: 1507:		typename std::enable_if<std::is_arithmetic<T>::value && has_linear_scale<UnitTypeRhs>::value, int>::type = 0>
        4: 1508:		inline auto operator/(T lhs, const UnitTypeRhs& rhs) -> unit_t<inverse<typename unit_t_traits<UnitTypeRhs>::unit_type>>
        -: 1509:	{
        -: 1510:		return unit_t<inverse<typename unit_t_traits<UnitTypeRhs>::unit_type>>
        4: 1511:			(lhs / rhs.value());
        -: 1512:	}
        -: 1513:
        -: 1514:	/** @cond */	// DOXYGEN IGNORE
        -: 1515:	namespace detail
        -: 1516:	{
        -: 1517:		/// recursive exponential implementation
        -: 1518:		template <int N, class U> struct power_of_unit
        -: 1519:		{
        -: 1520:			typedef typename units::detail::unit_multiply<U, typename power_of_unit<N - 1, U>::type> type;
        -: 1521:		};
        -: 1522:
        -: 1523:		/// End recursion
        -: 1524:		template <class U> struct power_of_unit<1, U>
        -: 1525:		{
        -: 1526:			typedef U type;
        -: 1527:		};
        -: 1528:	}
        -: 1529:	/** @endcond */	// END DOXYGEN IGNORE
        -: 1530:
        -: 1531:	/**
        -: 1532:	 * @brief		computes the value of <i>value</i> raised to the <i>power</i>
        -: 1533:	 * @details		Only implemented for linear_scale units. <i>Power</i> must be known at compile time, so the resulting unit type can be deduced.
        -: 1534:	 * @tparam		power exponential power to raise <i>value</i> by.
        -: 1535:	 * @param[in]	value `unit_t` derived type to raise to the given <i>power</i>
        -: 1536:	 * @returns		new unit_t, raised to the given exponent
        -: 1537:	 */
        -: 1538:	template<int power, class UnitType, typename std::enable_if<units::has_linear_scale<UnitType>::value, int>::type = 0>
       13: 1539:	inline auto pow(const UnitType& value) -> unit_t<typename detail::power_of_unit<power, typename unit_t_traits<UnitType>::unit_type>::type, typename unit_t_traits<UnitType>::underlying_type, linear_scale>
        -: 1540:	{
        -: 1541:		return unit_t<typename detail::power_of_unit<power, typename unit_t_traits<UnitType>::unit_type>::type, typename unit_t_traits<UnitType>::underlying_type, linear_scale>
       13: 1542:			(std::pow(value(), power));
        -: 1543:	}
        -: 1544:
        -: 1545:	//------------------------------
        -: 1546:	//	DECIBEL SCALE
        -: 1547:	//------------------------------
        -: 1548:
        -: 1549:	/**
        -: 1550:	* @brief		unit_t scale for representing decibel values.
        -: 1551:	* @details		internally stores linearized values. `operator()` returns the value in dB.
        -: 1552:	* @tparam		T	underlying storage type
        -: 1553:	* @sa			unit_t
        -: 1554:	*/
        -: 1555:	template<typename T>
        -: 1556:	struct decibel_scale
        -: 1557:	{
        3: 1558:		inline decibel_scale() : m_value(1) {}
       28: 1559:		inline decibel_scale(T value) { m_value = std::pow(10, value / 10); }
       12: 1560:		inline T operator()() const { return 10 * std::log10(m_value); }
        -: 1561:
        -: 1562:		T m_value;	///< linearized value	
        -: 1563:	};
        -: 1564:
        -: 1565:	//------------------------------
        -: 1566:	//	SCALAR (DECIBEL) UNITS
        -: 1567:	//------------------------------
        -: 1568:
        -: 1569:	/**
        -: 1570:	 * @brief		namespace for unit types and containers for units that have no dimension (scalar units)
        -: 1571:	 * @sa			See unit_t for more information on unit type containers.
        -: 1572:	 */
        -: 1573:	namespace dimensionless
        -: 1574:	{
        -: 1575:		using dB_t = unit_t<scalar, double, decibel_scale>;
        -: 1576:		using dBi_t = dB_t;
        -: 1577:	}
        -: 1578:
        -: 1579:	//------------------------------
        -: 1580:	//	DECIBEL ARITHMETIC
        -: 1581:	//------------------------------
        -: 1582:
        -: 1583:	/// Addition for convertible unit_t types with a decibel_scale
        -: 1584:	template<class UnitTypeLhs, class UnitTypeRhs,
        -: 1585:		typename std::enable_if<has_decibel_scale<UnitTypeLhs, UnitTypeRhs>::value, int>::type = 0>
        1: 1586:		inline auto operator+(const UnitTypeLhs& lhs, const UnitTypeRhs& rhs) -> unit_t<compound_unit<squared<typename unit_t_traits<UnitTypeLhs>::unit_type>>, typename unit_t_traits<UnitTypeLhs>::underlying_type, decibel_scale>
        -: 1587:	{
        -: 1588:		using LhsUnits = typename unit_t_traits<UnitTypeLhs>::unit_type;
        -: 1589:		using RhsUnits = typename unit_t_traits<UnitTypeRhs>::unit_type;
        -: 1590:		using underlying_type = typename unit_t_traits<UnitTypeLhs>::underlying_type;
        -: 1591:
        1: 1592:		unit_t<compound_unit<squared<LhsUnits>>, underlying_type, decibel_scale> ret;
        1: 1593:		reinterpret_cast<decibel_scale<underlying_type>&>(ret).m_value = lhs.linearizedValue() * convert<RhsUnits, LhsUnits>(rhs.linearizedValue());
        1: 1594:		return ret;
        -: 1595:	}
        -: 1596:
        -: 1597:	/// Addition between unit_t types with a decibel_scale and dimensionless dB units
        -: 1598:	template<class UnitTypeLhs, typename std::enable_if<has_decibel_scale<UnitTypeLhs>::value && !is_scalar_unit<UnitTypeLhs>::value, int>::type = 0>
        1: 1599:	inline UnitTypeLhs operator+(const UnitTypeLhs& lhs, const dimensionless::dB_t& rhs)
        -: 1600:	{
        -: 1601:		using underlying_type = typename unit_t_traits<UnitTypeLhs>::underlying_type;
        -: 1602:
        1: 1603:		UnitTypeLhs ret;
        1: 1604:		reinterpret_cast<decibel_scale<underlying_type>&>(ret).m_value = lhs.linearizedValue() * rhs.linearizedValue();
        1: 1605:		return ret;
        -: 1606:	}
        -: 1607:
        -: 1608:	/// Addition between unit_t types with a decibel_scale and dimensionless dB units
        -: 1609:	template<class UnitTypeRhs, typename std::enable_if<has_decibel_scale<UnitTypeRhs>::value && !is_scalar_unit<UnitTypeRhs>::value, int>::type = 0>
        2: 1610:	inline UnitTypeRhs operator+(const dimensionless::dB_t& lhs, const UnitTypeRhs& rhs)
        -: 1611:	{
        -: 1612:		using underlying_type = typename unit_t_traits<UnitTypeRhs>::underlying_type;
        -: 1613:
        2: 1614:		UnitTypeRhs ret;
        2: 1615:		reinterpret_cast<decibel_scale<underlying_type>&>(ret).m_value = lhs.linearizedValue() * rhs.linearizedValue();
        2: 1616:		return ret;
        -: 1617:	}
        -: 1618:
        -: 1619:	/// Subtraction for convertible unit_t types with a decibel_scale
        -: 1620:	template<class UnitTypeLhs, class UnitTypeRhs, typename std::enable_if<has_decibel_scale<UnitTypeLhs, UnitTypeRhs>::value, int>::type = 0>
        2: 1621:	inline auto operator-(const UnitTypeLhs& lhs, const UnitTypeRhs& rhs) -> unit_t<compound_unit<typename unit_t_traits<UnitTypeLhs>::unit_type, inverse<typename unit_t_traits<UnitTypeRhs>::unit_type>>, typename unit_t_traits<UnitTypeLhs>::underlying_type, decibel_scale>
        -: 1622:	{
        -: 1623:		using LhsUnits = typename unit_t_traits<UnitTypeLhs>::unit_type;
        -: 1624:		using RhsUnits = typename unit_t_traits<UnitTypeRhs>::unit_type;
        -: 1625:		using underlying_type = typename unit_t_traits<UnitTypeLhs>::underlying_type;
        -: 1626:
        2: 1627:		unit_t<compound_unit<LhsUnits, inverse<RhsUnits>>, underlying_type, decibel_scale> ret;
        2: 1628:		reinterpret_cast<decibel_scale<underlying_type>&>(ret).m_value = lhs.linearizedValue() / convert<RhsUnits, LhsUnits>(rhs.linearizedValue());
        2: 1629:		return ret;
        -: 1630:	}
        -: 1631:
        -: 1632:	/// Subtraction between unit_t types with a decibel_scale and dimensionless dB units
        -: 1633:	template<class UnitTypeLhs, typename std::enable_if<has_decibel_scale<UnitTypeLhs>::value && !is_scalar_unit<UnitTypeLhs>::value, int>::type = 0>
        2: 1634:	inline UnitTypeLhs operator-(const UnitTypeLhs& lhs, const dimensionless::dB_t& rhs)
        -: 1635:	{
        -: 1636:		using underlying_type = typename unit_t_traits<UnitTypeLhs>::underlying_type;
        -: 1637:
        2: 1638:		UnitTypeLhs ret;
        2: 1639:		reinterpret_cast<decibel_scale<underlying_type>&>(ret).m_value = lhs.linearizedValue() / rhs.linearizedValue();
        2: 1640:		return ret;
        -: 1641:	}
        -: 1642:
        -: 1643:	/// Subtraction between unit_t types with a decibel_scale and dimensionless dB units
        -: 1644:	template<class UnitTypeRhs, typename std::enable_if<has_decibel_scale<UnitTypeRhs>::value && !is_scalar_unit<UnitTypeRhs>::value, int>::type = 0>
        -: 1645:	inline auto operator-(const dimensionless::dB_t& lhs, const UnitTypeRhs& rhs) -> unit_t<inverse<typename unit_t_traits<UnitTypeRhs>::unit_type>, typename unit_t_traits<UnitTypeRhs>::underlying_type, decibel_scale>
        -: 1646:	{
        -: 1647:		using RhsUnits = typename unit_t_traits<UnitTypeRhs>::unit_type;
        -: 1648:		using underlying_type = typename unit_t_traits<RhsUnits>::underlying_type;
        -: 1649:
        -: 1650:		unit_t<inverse<RhsUnits>, underlying_type, decibel_scale> ret;
        -: 1651:		reinterpret_cast<decibel_scale<underlying_type>&>(ret).m_value = lhs.linearizedValue() / rhs.linearizedValue();
        -: 1652:		return ret;
        -: 1653:	}
        -: 1654:
        -: 1655:	//------------------------------
        -: 1656:	//	LENGTH UNITS
        -: 1657:	//------------------------------
        -: 1658:
        -: 1659:	/**
        -: 1660:	 * @brief		namespace for unit types and containers representing length values
        -: 1661:	 * @details		The SI unit for length is `meters`, and the corresponding `base_unit` category is
        -: 1662:	 *				`length_unit`.
        -: 1663:	 * @sa			See unit_t for more information on unit type containers.
        -: 1664:	 */
        -: 1665:	namespace length
        -: 1666:	{
        -: 1667:		/**
        -: 1668:		 * @name Units (full names plural)
        -: 1669:		 * @{
        -: 1670:		 */
        -: 1671:		using meters = unit<std::ratio<1>, category::length_unit>;
        -: 1672:		using nanometers = nano<meters>;
        -: 1673:		using micrometers = micro<meters>;
        -: 1674:		using millimeters = milli<meters>;
        -: 1675:		using centimeters = centi<meters>;
        -: 1676:		using kilometers = kilo<meters>;
        -: 1677:		using feet = unit<std::ratio<381, 1250>, meters>;
        -: 1678:		using mils = unit<std::ratio<1000>, feet>;
        -: 1679:		using inches = unit<std::ratio<1, 12>, feet>;
        -: 1680:		using miles = unit<std::ratio<5280>, feet>;
        -: 1681:		using nauticalMiles = unit<std::ratio<1852>, meters>;
        -: 1682:		using astronicalUnits = unit<std::ratio<149597870700>, meters>;
        -: 1683:		using lightyears = unit<std::ratio<9460730472580800>, meters>;
        -: 1684:		using parsecs = unit<std::ratio<648000>, astronicalUnits, std::ratio<-1>>;
        -: 1685:		using angstroms = unit<std::ratio<1, 10>, nanometers>;
        -: 1686:		using cubits = unit<std::ratio<18>, inches>;
        -: 1687:		using fathoms = unit<std::ratio<6>, feet>;
        -: 1688:		using chains = unit<std::ratio<66>, feet>;
        -: 1689:		using furlongs = unit<std::ratio<10>, chains>;
        -: 1690:		using hands = unit<std::ratio<4>, inches>;
        -: 1691:		using leagues = unit<std::ratio<3>, miles>;
        -: 1692:		using nauticalLeagues = unit<std::ratio<3>, nauticalMiles>;
        -: 1693:		using yards = unit<std::ratio<3>, feet>;
        -: 1694:		/** @} */
        -: 1695:
        -: 1696:		/**
        -: 1697:		 * @name Units (full names singular)
        -: 1698:		 * @{
        -: 1699:		 */
        -: 1700:		using meter = meters;
        -: 1701:		using nanometer = nanometers;
        -: 1702:		using micrometer = micrometers;
        -: 1703:		using millimeter = millimeters;
        -: 1704:		using centimeter = centimeters;
        -: 1705:		using kilometer = kilometers;
        -: 1706:		using foot = feet;
        -: 1707:		using inch = inches;
        -: 1708:		using mile = miles;
        -: 1709:		using nauticalMile = nauticalMiles;
        -: 1710:		using astronicalUnit = astronicalUnits;
        -: 1711:		using lightyear = lightyears;
        -: 1712:		using parsec = parsecs;
        -: 1713:		using angstrom = angstroms;
        -: 1714:		using cubit = cubits;
        -: 1715:		using fathom = fathoms;
        -: 1716:		using chain = chains;
        -: 1717:		using furlong = furlongs;
        -: 1718:		using hand = hands;
        -: 1719:		using league = leagues;
        -: 1720:		using nauticalLeague = nauticalLeagues;
        -: 1721:		using yard = yards;
        -: 1722:		/** @} */
        -: 1723:
        -: 1724:		/**
        -: 1725:		* @name Units (abbreviated names)
        -: 1726:		* @{
        -: 1727:		*/
        -: 1728:		using m = meters;
        -: 1729:		using nm = nanometers;
        -: 1730:		using um = micrometers;
        -: 1731:		using mm = millimeters;
        -: 1732:		using cm = centimeters;
        -: 1733:		using km = kilometers;
        -: 1734:		using ft = feet;
        -: 1735:		using inc = inches;
        -: 1736:		using mi = miles;
        -: 1737:		using nmi = nauticalMiles;
        -: 1738:		using au = astronicalUnits;
        -: 1739:		using ly = lightyears;
        -: 1740:		using pc = parsecs;
        -: 1741:		using ftm = fathoms;
        -: 1742:		using ch = chains;
        -: 1743:		using fur = furlongs;
        -: 1744:		using lea = leagues;
        -: 1745:		using nl = nauticalLeagues;
        -: 1746:		using yd = yards;
        -: 1747:		/** @} */
        -: 1748:
        -: 1749:		/**
        -: 1750:		 * @anchor		lengthContainers
        -: 1751:		 * @name		Unit Containers
        -: 1752:		 * @{
        -: 1753:		 */
        -: 1754:		using meter_t = unit_t<meter>;
        -: 1755:		using nanometer_t = unit_t<nanometer>;
        -: 1756:		using micrometer_t = unit_t<micrometer>;
        -: 1757:		using millimeter_t = unit_t<millimeter>;
        -: 1758:		using centimeter_t = unit_t<centimeter>;
        -: 1759:		using kilometer_t = unit_t<kilometer>;
        -: 1760:		using foot_t = unit_t<foot>;
        -: 1761:		using inch_t = unit_t<inch>;
        -: 1762:		using mile_t = unit_t<mile>;
        -: 1763:		using nauticalMile_t = unit_t<nauticalMile>;
        -: 1764:		using astronicalUnit_t = unit_t<astronicalUnit>;
        -: 1765:		using lightyear_t = unit_t<lightyear>;
        -: 1766:		using parsec_t = unit_t<parsec>;
        -: 1767:		using angstrom_t = unit_t<angstrom>;
        -: 1768:		using cubit_t = unit_t<cubit>;
        -: 1769:		using fathom_t = unit_t<fathom>;
        -: 1770:		using chain_t = unit_t<chain>;
        -: 1771:		using furlong_t = unit_t<furlong>;
        -: 1772:		using hand_t = unit_t<hand>;
        -: 1773:		using league_t = unit_t<league>;
        -: 1774:		using nauticalLeague_t = unit_t<nauticalLeague>;
        -: 1775:		using yard_t = unit_t<yard>;
        -: 1776:		/** @} */
        -: 1777:	}
        -: 1778:
        -: 1779:	namespace detail
        -: 1780:	{
        -: 1781:		template<typename T> struct is_length_unit_impl : std::false_type {};
        -: 1782:		template<typename C, typename U, typename P, typename T>
        -: 1783:		struct is_length_unit_impl<unit<C, U, P, T>> : std::is_same<base_unit_of<typename unit_traits<unit<C, U, P, T>>::base_unit_type>, category::length_unit>::type {};
        -: 1784:		template<typename U, typename S, template<typename> class N>
        -: 1785:		struct is_length_unit_impl<unit_t<U, S, N>> : std::is_same<base_unit_of<typename unit_t_traits<unit_t<U, S, N>>::unit_type>, category::length_unit>::type {};
        -: 1786:	}
        -: 1787:
        -: 1788:	/**
        -: 1789:	 * @ingroup		TypeTraits
        -: 1790:	 * @brief		Trait which tests whether a type represents a unit of length
        -: 1791:	 * @details		Inherits from `std::true_type` or `std::false_type`. Use `is_length_unit<T>::value` to test
        -: 1792:	 *				the unit represents a length quantity.
        -: 1793:	 * @tparam		T	one or more types to test
        -: 1794:	 */
        -: 1795:	template<typename... T> struct is_length_unit : std::integral_constant<bool, all_true<detail::is_length_unit_impl<typename std::decay<T>::type>::value...>::value> {};
        -: 1796:
        -: 1797:	//------------------------------
        -: 1798:	//	MASS UNITS
        -: 1799:	//------------------------------
        -: 1800:
        -: 1801:	/**
        -: 1802:	 * @brief		namespace for unit types and containers representing mass values
        -: 1803:	 * @details		The SI unit for mass is `kilograms`, and the corresponding `base_unit` category is
        -: 1804:	 *				`mass_unit`.
        -: 1805:	 * @sa			See unit_t for more information on unit type containers.
        -: 1806:	 */
        -: 1807:	namespace mass
        -: 1808:	{
        -: 1809:		/**
        -: 1810:		 * @name Units (full names plural)
        -: 1811:		 * @{
        -: 1812:		 */
        -: 1813:		using kilograms = unit<std::ratio<1>, category::mass_unit>;
        -: 1814:		using grams = unit<std::ratio<1, 1000>, kilograms>;
        -: 1815:		using micrograms = micro<grams>;
        -: 1816:		using milligrams = milli<grams>;
        -: 1817:		using metric_tons = unit<std::ratio<1000>, kilograms>;
        -: 1818:		using pounds = unit<std::ratio<45359237, 100000000>, kilograms>;
        -: 1819:		using imperial_tons = unit<std::ratio<2240>, pounds>;
        -: 1820:		using us_tons = unit<std::ratio<2000>, pounds>;
        -: 1821:		using stone = unit<std::ratio<14>, pounds>;
        -: 1822:		using ounces = unit<std::ratio<1, 16>, pounds>;
        -: 1823:		using carats = unit<std::ratio<200>, milligrams>;
        -: 1824:		using slugs = unit<std::ratio<145939029, 10000000>, kilograms>;
        -: 1825:		/** @} */
        -: 1826:
        -: 1827:		/**
        -: 1828:		 * @name Units (full names singular)
        -: 1829:		 * @{
        -: 1830:		 */
        -: 1831:		using gram = grams;
        -: 1832:		using microgram = micrograms;
        -: 1833:		using milligram = milligrams;
        -: 1834:		using kilogram = kilograms;
        -: 1835:		using metric_ton = metric_tons;
        -: 1836:		using pound = pounds;
        -: 1837:		using imperial_ton = imperial_tons;
        -: 1838:		using us_ton = us_tons;
        -: 1839:		using ounce = ounces;
        -: 1840:		using carat = carats;
        -: 1841:		using slug = slugs;
        -: 1842:		/** @} */
        -: 1843:
        -: 1844:		/**
        -: 1845:		 * @name Units (abbreviated names)
        -: 1846:		 * @{
        -: 1847:		 */
        -: 1848:		using g = grams;
        -: 1849:		using ug = micrograms;
        -: 1850:		using mg = milligrams;
        -: 1851:		using kg = kilograms;
        -: 1852:		using mt = metric_tons;
        -: 1853:		using t = us_tons;
        -: 1854:		using Ib = pounds;
        -: 1855:		using Ibs = pounds;
        -: 1856:		using st = stone;
        -: 1857:		using oz = ounces;
        -: 1858:		using ct = carats;
        -: 1859:		/** @} */
        -: 1860:
        -: 1861:		/**
        -: 1862:		 * @name Unit Containers
        -: 1863:		 * @anchor massContainers
        -: 1864:		 * @{
        -: 1865:		 */
        -: 1866:		using gram_t = unit_t<gram>;
        -: 1867:		using microgram_t = unit_t<microgram>;
        -: 1868:		using milligram_t = unit_t<milligram>;
        -: 1869:		using kilogram_t = unit_t<kilogram>;
        -: 1870:		using metric_ton_t = unit_t<metric_ton>;
        -: 1871:		using pound_t = unit_t<pound>;
        -: 1872:		using imperial_ton_t = unit_t<imperial_ton>;
        -: 1873:		using us_ton_t = unit_t<us_ton>;
        -: 1874:		using stone_t = unit_t<stone>;
        -: 1875:		using ounce_t = unit_t<ounce>;
        -: 1876:		using carat_t = unit_t<carat>;
        -: 1877:		using slug_t = unit_t<slug>;
        -: 1878:		/** @} */
        -: 1879:	}
        -: 1880:
        -: 1881:	namespace detail
        -: 1882:	{
        -: 1883:		template<typename T> struct is_mass_unit_impl : std::false_type {};
        -: 1884:		template<typename C, typename U, typename P, typename T>
        -: 1885:		struct is_mass_unit_impl<unit<C, U, P, T>> : std::is_same<base_unit_of<typename unit_traits<unit<C, U, P, T>>::base_unit_type>, category::mass_unit>::type {};
        -: 1886:		template<typename U, typename S, template<typename> class N>
        -: 1887:		struct is_mass_unit_impl<unit_t<U, S, N>> : std::is_same<base_unit_of<typename unit_t_traits<unit_t<U, S, N>>::unit_type>, category::mass_unit>::type {};
        -: 1888:	}
        -: 1889:
        -: 1890:	/**
        -: 1891:	 * @ingroup		TypeTraits
        -: 1892:	 * @brief		Trait which tests whether a type represents a unit of mass
        -: 1893:	 * @details		Inherits from `std::true_type` or `std::false_type`. Use `is_mass_unit<T>::value` to test
        -: 1894:	 *				the unit represents a mass quantity.
        -: 1895:	 * @tparam		T	one or more types to test
        -: 1896:	 */
        -: 1897:	template<typename... T> struct is_mass_unit : std::integral_constant<bool, all_true<detail::is_mass_unit_impl<typename std::decay<T>::type>::value...>::value> {};
        -: 1898:
        -: 1899:	//------------------------------
        -: 1900:	//	TIME UNITS
        -: 1901:	//------------------------------
        -: 1902:
        -: 1903:	/**
        -: 1904:	 * @brief		namespace for unit types and containers representing time values
        -: 1905:	 * @details		The SI unit for time is `seconds`, and the corresponding `base_unit` category is
        -: 1906:	 *				`time_unit`.
        -: 1907:	 * @sa			See unit_t for more information on unit type containers.
        -: 1908:	 */
        -: 1909:	namespace time
        -: 1910:	{
        -: 1911:		/**
        -: 1912:		 * @name Units (full names plural)
        -: 1913:		 * @{
        -: 1914:		 */
        -: 1915:		using seconds = unit<std::ratio<1>, category::time_unit>;
        -: 1916:		using nanoseconds = nano<seconds>;
        -: 1917:		using microseconds = micro<seconds>;
        -: 1918:		using millseconds = milli<seconds>;
        -: 1919:		using minutes = unit<std::ratio<60>, seconds>;
        -: 1920:		using hours = unit<std::ratio<60>, minutes>;
        -: 1921:		using days = unit<std::ratio<24>, hours>;
        -: 1922:		using weeks = unit<std::ratio<7>, days>;
        -: 1923:		using years = unit<std::ratio<365>, days>;
        -: 1924:		/** @} */
        -: 1925:
        -: 1926:		/**
        -: 1927:		 * @name Units (full names singular)
        -: 1928:		 * @{
        -: 1929:		 */
        -: 1930:		using second = seconds;
        -: 1931:		using nanosecond = nanoseconds;
        -: 1932:		using microsecond = microseconds;
        -: 1933:		using millsecond = millseconds;
        -: 1934:		using minute = minutes;
        -: 1935:		using hour = hours;
        -: 1936:		using day = days;
        -: 1937:		using week = weeks;
        -: 1938:		using year = years;
        -: 1939:		/** @} */
        -: 1940:
        -: 1941:		/**
        -: 1942:		 * @name Units (abbreviated names)
        -: 1943:		 * @{
        -: 1944:		 */
        -: 1945:		using s = seconds;
        -: 1946:		using ns = nanoseconds;
        -: 1947:		using us = microseconds;
        -: 1948:		using ms = millseconds;
        -: 1949:		using m = minutes;
        -: 1950:		using hr = hours;
        -: 1951:		using d = days;
        -: 1952:		using wk = weeks;
        -: 1953:		using yr = years;
        -: 1954:		/** @} */
        -: 1955:
        -: 1956:		/**
        -: 1957:		 * @name Unit Containers
        -: 1958:		 * @anchor timeContainers
        -: 1959:		 * @{
        -: 1960:		 */
        -: 1961:		using second_t = unit_t<second>;
        -: 1962:		using nanosecond_t = unit_t<nanosecond>;
        -: 1963:		using microsecond_t = unit_t<microsecond>;
        -: 1964:		using millsecond_t = unit_t<millsecond>;
        -: 1965:		using minute_t = unit_t<minute>;
        -: 1966:		using hour_t = unit_t<hour>;
        -: 1967:		using day_t = unit_t<day>;
        -: 1968:		using week_t = unit_t<week>;
        -: 1969:		using year_t = unit_t<year>;
        -: 1970:		/** @} */
        -: 1971:	}
        -: 1972:
        -: 1973:	namespace detail
        -: 1974:	{
        -: 1975:		template<typename T> struct is_time_unit_impl : std::false_type {};
        -: 1976:		template<typename C, typename U, typename P, typename T>
        -: 1977:		struct is_time_unit_impl<unit<C, U, P, T>> : std::is_same<base_unit_of<typename unit_traits<unit<C, U, P, T>>::base_unit_type>, category::time_unit>::type {};
        -: 1978:		template<typename U, typename S, template<typename> class N>
        -: 1979:		struct is_time_unit_impl<unit_t<U, S, N>> : std::is_same<base_unit_of<typename unit_t_traits<unit_t<U, S, N>>::unit_type>, category::time_unit>::type {};
        -: 1980:	}
        -: 1981:
        -: 1982:	/**
        -: 1983:	 * @ingroup		TypeTraits
        -: 1984:	 * @brief		Trait which tests whether a type represents a unit of time
        -: 1985:	 * @details		Inherits from `std::true_type` or `std::false_type`. Use `is_time_unit<T>::value` to test
        -: 1986:	 *				the unit represents a time quantity.
        -: 1987:	 * @tparam		T	one or more types to test
        -: 1988:	 */
        -: 1989:	template<typename... T> struct is_time_unit : std::integral_constant<bool, all_true<detail::is_time_unit_impl<typename std::decay<T>::type>::value...>::value> {};
        -: 1990:
        -: 1991:	//------------------------------
        -: 1992:	//	ANGLE UNITS
        -: 1993:	//------------------------------
        -: 1994:
        -: 1995:	/**
        -: 1996:	 * @brief		namespace for unit types and containers representing angle values
        -: 1997:	 * @details		The SI unit for angle is `radians`, and the corresponding `base_unit` category is
        -: 1998:	 *				`angle_unit`.
        -: 1999:	 * @sa			See unit_t for more information on unit type containers.
        -: 2000:	 */
        -: 2001:	namespace angle
        -: 2002:	{
        -: 2003:		/**
        -: 2004:		 * @name Units (full names plural)
        -: 2005:		 * @{
        -: 2006:		 */
        -: 2007:		using radians = unit<std::ratio<1>, category::angle_unit>;
        -: 2008:		using milliradians = milli<radians>;
        -: 2009:		using degrees = unit<std::ratio<1, 180>, radians, std::ratio<1>>;
        -: 2010:		using arcminutes = unit<std::ratio<1, 60>, degrees>;
        -: 2011:		using arcseconds = unit<std::ratio<1, 60>, arcminutes>;
        -: 2012:		using milliarcseconds = milli<arcseconds>;
        -: 2013:		using turns = unit<std::ratio<2>, radians, std::ratio<1>>;
        -: 2014:		using mils = unit<std::ratio<1, 6400>, radians>;	// 1/6400 of a circle
        -: 2015:		using gradians = unit<std::ratio<1, 400>, turns>;
        -: 2016:		/** @} */
        -: 2017:
        -: 2018:		/**
        -: 2019:		 * @name Units (full names singular)
        -: 2020:		 * @{
        -: 2021:		 */
        -: 2022:		using radian = radians;
        -: 2023:		using milliradian = milliradians;
        -: 2024:		using degree = degrees;
        -: 2025:		using arcminute = arcminutes;
        -: 2026:		using arcsecond = arcseconds;
        -: 2027:		using milliarcsecond = milliarcseconds;
        -: 2028:		using turn = turns;
        -: 2029:		using mil = mils;
        -: 2030:		using gradian = gradians;
        -: 2031:		/** @} */
        -: 2032:
        -: 2033:		/**
        -: 2034:		 * @name Units (abbreviated names)
        -: 2035:		 * @{
        -: 2036:		 */
        -: 2037:		using rad = radians;
        -: 2038:		using mrad = milliradians;
        -: 2039:		using deg = degrees;
        -: 2040:		using min = arcminutes;
        -: 2041:		using sec = arcseconds;
        -: 2042:		using mas = milliarcseconds;
        -: 2043:		using tr = turn;
        -: 2044:		using gon = gradians;
        -: 2045:		using grad = gradians;
        -: 2046:		/** @} */
        -: 2047:
        -: 2048:		/**
        -: 2049:		 * @name Unit Containers
        -: 2050:		 * @anchor angleContainers
        -: 2051:		 * @{
        -: 2052:		 */
        -: 2053:		using radian_t = unit_t<radian>;
        -: 2054:		using milliradian_t = unit_t<milliradian>;
        -: 2055:		using degree_t = unit_t<degree>;
        -: 2056:		using minute_t = unit_t<arcminute>;
        -: 2057:		using second_t = unit_t<arcsecond>;
        -: 2058:		using turn_t = unit_t<turn>;
        -: 2059:		using mil_t = unit_t<mil>;
        -: 2060:		using gradian_t = unit_t<gradian>;
        -: 2061:		/** @} */
        -: 2062:	}
        -: 2063:
        -: 2064:	namespace detail
        -: 2065:	{
        -: 2066:		template<typename T> struct is_angle_unit_impl : std::false_type {};
        -: 2067:		template<typename C, typename U, typename P, typename T>
        -: 2068:		struct is_angle_unit_impl<unit<C, U, P, T>> : std::is_same<base_unit_of<typename unit_traits<unit<C, U, P, T>>::base_unit_type>, category::angle_unit>::type {};
        -: 2069:		template<typename U, typename S, template<typename> class N>
        -: 2070:		struct is_angle_unit_impl<unit_t<U, S, N>> : std::is_same<base_unit_of<typename unit_t_traits<unit_t<U, S, N>>::unit_type>, category::angle_unit>::type {};
        -: 2071:	}
        -: 2072:
        -: 2073:	/**
        -: 2074:	 * @ingroup		TypeTraits
        -: 2075:	 * @brief		Trait which tests whether a type represents a unit of angle
        -: 2076:	 * @details		Inherits from `std::true_type` or `std::false_type`. Use `is_angle_unit<T>::value` to test
        -: 2077:	 *				the unit represents a angle quantity.
        -: 2078:	 * @tparam		T	one or more types to test
        -: 2079:	 */
        -: 2080:	template<typename... T> struct is_angle_unit : std::integral_constant<bool, all_true<detail::is_angle_unit_impl<typename std::decay<T>::type>::value...>::value> {};
        -: 2081:
        -: 2082:	//------------------------------
        -: 2083:	//	UNITS OF CURRENT
        -: 2084:	//------------------------------
        -: 2085:	/**
        -: 2086:	 * @brief		namespace for unit types and containers representing current values
        -: 2087:	 * @details		The SI unit for current is `amperes`, and the corresponding `base_unit` category is
        -: 2088:	 *				`current_unit`.
        -: 2089:	 * @sa			See unit_t for more information on unit type containers.
        -: 2090:	 */
        -: 2091:	namespace current
        -: 2092:	{
        -: 2093:		/**
        -: 2094:		 * @name Units (full names plural)
        -: 2095:		 * @{
        -: 2096:		 */
        -: 2097:		using amperes = unit<std::ratio<1>, category::current_unit>;
        -: 2098:		using milliamps = milli<amperes>;
        -: 2099:		using microamps = micro<amperes>;
        -: 2100:		using nanoamps = nano<amperes>;
        -: 2101:		/** @} */
        -: 2102:
        -: 2103:		/**
        -: 2104:		 * @name Units (full names singular)
        -: 2105:		 * @{
        -: 2106:		 */
        -: 2107:		using ampere = amperes;
        -: 2108:		using amps = amperes;
        -: 2109:		using amp = amperes;
        -: 2110:		using milliamp = milliamps;
        -: 2111:		using microamp = microamps;
        -: 2112:		using nanoamp = nanoamps;
        -: 2113:		/** @} */
        -: 2114:
        -: 2115:		/**
        -: 2116:		 * @name Units (abbreviated names)
        -: 2117:		 * @{
        -: 2118:		 */
        -: 2119:		using A = amperes;
        -: 2120:		using mA = milliamps;
        -: 2121:		using uA = microamps;
        -: 2122:		using nA = nanoamps;
        -: 2123:		/** @} */
        -: 2124:
        -: 2125:		/**
        -: 2126:		 * @name Unit Containers
        -: 2127:		 * @anchor currentContainers
        -: 2128:		 * @{
        -: 2129:		 */
        -: 2130:		using ampere_t = unit_t<ampere>;
        -: 2131:		using amps_t = unit_t<amps>;
        -: 2132:		using amp_t = unit_t<amp>;
        -: 2133:		using milliamp_t = unit_t<milliamp>;
        -: 2134:		using microamp_t = unit_t<microamp>;
        -: 2135:		using nanoamp_t = unit_t<nanoamp>;
        -: 2136:		/** @} */
        -: 2137:	}
        -: 2138:
        -: 2139:	namespace detail
        -: 2140:	{
        -: 2141:		template<typename T> struct is_current_unit_impl : std::false_type {};
        -: 2142:		template<typename C, typename U, typename P, typename T>
        -: 2143:		struct is_current_unit_impl<unit<C, U, P, T>> : std::is_same<base_unit_of<typename unit_traits<unit<C, U, P, T>>::base_unit_type>, category::current_unit>::type {};
        -: 2144:		template<typename U, typename S, template<typename> class N>
        -: 2145:		struct is_current_unit_impl<unit_t<U, S, N>> : std::is_same<base_unit_of<typename unit_t_traits<unit_t<U, S, N>>::unit_type>, category::current_unit>::type {};
        -: 2146:	}
        -: 2147:
        -: 2148:	/**
        -: 2149:	 * @ingroup		TypeTraits
        -: 2150:	 * @brief		Trait which tests whether a type represents a unit of current
        -: 2151:	 * @details		Inherits from `std::true_type` or `std::false_type`. Use `is_current_unit<T>::value` to test
        -: 2152:	 *				the unit represents a current quantity.
        -: 2153:	 * @tparam		T	one or more types to test
        -: 2154:	 */
        -: 2155:	template<typename... T> struct is_current_unit : std::integral_constant<bool, all_true<detail::is_current_unit_impl<typename std::decay<T>::type>::value...>::value> {};
        -: 2156:
        -: 2157:	//------------------------------
        -: 2158:	//	UNITS OF TEMPERATURE
        -: 2159:	//------------------------------
        -: 2160:
        -: 2161:	// NOTE: temperature units have special conversion overloads, since they
        -: 2162:	// require translations and aren't a reversible transform.
        -: 2163:
        -: 2164:	/**
        -: 2165:	 * @brief		namespace for unit types and containers representing temperature values
        -: 2166:	 * @details		The SI unit for temperature is `kelvin`, and the corresponding `base_unit` category is
        -: 2167:	 *				`temperature_unit`.
        -: 2168:	 * @sa			See unit_t for more information on unit type containers.
        -: 2169:	 */
        -: 2170:	namespace temperature
        -: 2171:	{
        -: 2172:		/**
        -: 2173:		 * @name Units (full names plural)
        -: 2174:		 * @{
        -: 2175:		 */
        -: 2176:		using kelvin = unit<std::ratio<1>, category::temperature_unit>;
        -: 2177:		using celsius = unit<std::ratio<1>, kelvin, std::ratio<0>, std::ratio<27315, 100>>;
        -: 2178:		using fahrenheit = unit<std::ratio<5, 9>, celsius, std::ratio<0>, std::ratio<-160, 9>>;
        -: 2179:		using reaumur = unit<std::ratio<10, 8>, celsius>;
        -: 2180:		using rankine = unit<std::ratio<5, 9>, kelvin>;
        -: 2181:		/** @} */
        -: 2182:
        -: 2183:		/**
        -: 2184:		 * @name Units (full names singular)
        -: 2185:		 * @{
        -: 2186:		 */
        -: 2187:		using centigrade = celsius;
        -: 2188:		/** @} */
        -: 2189:
        -: 2190:		/**
        -: 2191:		 * @name Units (abbreviated names)
        -: 2192:		 * @{
        -: 2193:		 */
        -: 2194:		using K = kelvin;
        -: 2195:		using F = fahrenheit;
        -: 2196:		using C = celsius;
        -: 2197:		using Ra = rankine;
        -: 2198:		using Re = reaumur;
        -: 2199:		/** @} */
        -: 2200:
        -: 2201:		/**
        -: 2202:		 * @name Unit Containers
        -: 2203:		 * @anchor temperatureContainers
        -: 2204:		 * @{
        -: 2205:		 */
        -: 2206:		using kelvin_t = unit_t<kelvin>;
        -: 2207:		using celsius_t = unit_t<celsius>;
        -: 2208:		using fahrenheit_t = unit_t<fahrenheit>;
        -: 2209:		using reaumur_t = unit_t<reaumur>;
        -: 2210:		using rankine_t = unit_t<rankine>;
        -: 2211:		using centigrade_t = unit_t<centigrade>;
        -: 2212:		/** @} */
        -: 2213:	}
        -: 2214:
        -: 2215:	namespace detail
        -: 2216:	{
        -: 2217:		template<typename T> struct is_temperature_unit_impl : std::false_type {};
        -: 2218:		template<typename C, typename U, typename P, typename T>
        -: 2219:		struct is_temperature_unit_impl<unit<C, U, P, T>> : std::is_same<base_unit_of<typename unit_traits<unit<C, U, P, T>>::base_unit_type>, category::temperature_unit>::type {};
        -: 2220:		template<typename U, typename S, template<typename> class N>
        -: 2221:		struct is_temperature_unit_impl<unit_t<U, S, N>> : std::is_same<base_unit_of<typename unit_t_traits<unit_t<U, S, N>>::unit_type>, category::temperature_unit>::type {};
        -: 2222:	}
        -: 2223:
        -: 2224:	/**
        -: 2225:	 * @ingroup		TypeTraits
        -: 2226:	 * @brief		Trait which tests whether a type represents a unit of temperature
        -: 2227:	 * @details		Inherits from `std::true_type` or `std::false_type`. Use `is_temperature_unit<T>::value` to test
        -: 2228:	 *				the unit represents a temperature quantity.
        -: 2229:	 * @tparam		T	one or more types to test
        -: 2230:	 */
        -: 2231:	template<typename... T> struct is_temperature_unit : std::integral_constant<bool, all_true<detail::is_temperature_unit_impl<typename std::decay<T>::type>::value...>::value> {};
        -: 2232:
        -: 2233:	//------------------------------
        -: 2234:	//	UNITS OF AMOUNT OF SUBSTANCE
        -: 2235:	//------------------------------
        -: 2236:
        -: 2237:	/**
        -: 2238:	 * @brief		namespace for unit types and containers representing substance values
        -: 2239:	 * @details		The SI unit for substance is `moles`, and the corresponding `base_unit` category is
        -: 2240:	 *				`substance_unit`.
        -: 2241:	 * @sa			See unit_t for more information on unit type containers.
        -: 2242:	 */
        -: 2243:	namespace substance
        -: 2244:	{
        -: 2245:		/**
        -: 2246:		 * @name Units (full names plural)
        -: 2247:		 * @{
        -: 2248:		 */
        -: 2249:		using moles = unit<std::ratio<1>, category::substance_unit>;
        -: 2250:		/** @} */
        -: 2251:
        -: 2252:		/**
        -: 2253:		 * @name Units (full names singular)
        -: 2254:		 * @{
        -: 2255:		 */
        -: 2256:		using mole = moles;
        -: 2257:		/** @} */
        -: 2258:
        -: 2259:		/**
        -: 2260:		 * @name Units (abbreviated names)
        -: 2261:		 * @{
        -: 2262:		 */
        -: 2263:		using mol = mole;
        -: 2264:		/** @} */
        -: 2265:
        -: 2266:		/**
        -: 2267:		 * @name Unit Containers
        -: 2268:		 * @anchor substanceContainers
        -: 2269:		 * @{
        -: 2270:		 */
        -: 2271:		using mole_t = unit_t<mole>;
        -: 2272:		/** @} */
        -: 2273:	}
        -: 2274:
        -: 2275:	namespace detail
        -: 2276:	{
        -: 2277:		template<typename T> struct is_substance_unit_impl : std::false_type {};
        -: 2278:		template<typename C, typename U, typename P, typename T>
        -: 2279:		struct is_substance_unit_impl<unit<C, U, P, T>> : std::is_same<base_unit_of<typename unit_traits<unit<C, U, P, T>>::base_unit_type>, category::substance_unit>::type {};
        -: 2280:		template<typename U, typename S, template<typename> class N>
        -: 2281:		struct is_substance_unit_impl<unit_t<U, S, N>> : std::is_same<base_unit_of<typename unit_t_traits<unit_t<U, S, N>>::unit_type>, category::substance_unit>::type {};
        -: 2282:	}
        -: 2283:
        -: 2284:	/**
        -: 2285:	 * @ingroup		TypeTraits
        -: 2286:	 * @brief		Trait which tests whether a type represents a unit of substance
        -: 2287:	 * @details		Inherits from `std::true_type` or `std::false_type`. Use `is_substance_unit<T>::value` to test
        -: 2288:	 *				the unit represents a substance quantity.
        -: 2289:	 * @tparam		T	one or more types to test
        -: 2290:	 */
        -: 2291:	template<typename... T> struct is_substance_unit : std::integral_constant<bool, all_true<detail::is_substance_unit_impl<typename std::decay<T>::type>::value...>::value> {};
        -: 2292:
        -: 2293:	//------------------------------
        -: 2294:	//	UNITS OF LUMINOUS INTENSITY
        -: 2295:	//------------------------------
        -: 2296:
        -: 2297:	/**
        -: 2298:	 * @brief		namespace for unit types and containers representing luminous_intensity values
        -: 2299:	 * @details		The SI unit for luminous_intensity is `candelas`, and the corresponding `base_unit` category is
        -: 2300:	 *				`luminous_intensity_unit`.
        -: 2301:	 * @sa			See unit_t for more information on unit type containers.
        -: 2302:	 */
        -: 2303:	namespace luminous_intensity
        -: 2304:	{
        -: 2305:		/**
        -: 2306:		 * @name Units (full names plural)
        -: 2307:		 * @{
        -: 2308:		 */
        -: 2309:		using candelas = unit<std::ratio<1>, category::luminous_intensity_unit>;
        -: 2310:		using millicandelas = milli<candelas>;
        -: 2311:		/** @} */
        -: 2312:
        -: 2313:		/**
        -: 2314:		 * @name Units (full names singular)
        -: 2315:		 * @{
        -: 2316:		 */
        -: 2317:		using candela = candelas;
        -: 2318:		using millicandela = millicandelas;
        -: 2319:		/** @} */
        -: 2320:
        -: 2321:		/**
        -: 2322:		 * @name Units (abbreviated names)
        -: 2323:		 * @{
        -: 2324:		 */
        -: 2325:		using cd = candela;
        -: 2326:		using mcd = millicandela;
        -: 2327:		/** @} */
        -: 2328:
        -: 2329:		/**
        -: 2330:		 * @name Unit Containers
        -: 2331:		 * @anchor luminousIntensityContainers
        -: 2332:		 * @{
        -: 2333:		 */
        -: 2334:		using candela_t = unit_t<candela>;
        -: 2335:		using millicandela_t = unit_t<millicandela>;
        -: 2336:		/** @} */
        -: 2337:	}
        -: 2338:
        -: 2339:	namespace detail
        -: 2340:	{
        -: 2341:		template<typename T> struct is_luminous_intensity_unit_impl : std::false_type {};
        -: 2342:		template<typename C, typename U, typename P, typename T>
        -: 2343:		struct is_luminous_intensity_unit_impl<unit<C, U, P, T>> : std::is_same<base_unit_of<typename unit_traits<unit<C, U, P, T>>::base_unit_type>, category::luminous_intensity_unit>::type {};
        -: 2344:		template<typename U, typename S, template<typename> class N>
        -: 2345:		struct is_luminous_intensity_unit_impl<unit_t<U, S, N>> : std::is_same<base_unit_of<typename unit_t_traits<unit_t<U, S, N>>::unit_type>, category::luminous_intensity_unit>::type {};
        -: 2346:	}
        -: 2347:
        -: 2348:	/**
        -: 2349:	 * @ingroup		TypeTraits
        -: 2350:	 * @brief		Trait which tests whether a type represents a unit of luminous_intensity
        -: 2351:	 * @details		Inherits from `std::true_type` or `std::false_type`. Use `is_luminous_intensity_unit<T>::value` to test
        -: 2352:	 *				the unit represents a luminous_intensity quantity.
        -: 2353:	 * @tparam		T	one or more types to test
        -: 2354:	 */
        -: 2355:	template<typename... T> struct is_luminous_intensity_unit : std::integral_constant<bool, all_true<detail::is_luminous_intensity_unit_impl<typename std::decay<T>::type>::value...>::value> {};
        -: 2356:
        -: 2357:	//------------------------------
        -: 2358:	//	UNITS OF SOLID ANGLE
        -: 2359:	//------------------------------
        -: 2360:
        -: 2361:	/**
        -: 2362:	 * @brief		namespace for unit types and containers representing solid_angle values
        -: 2363:	 * @details		The SI unit for solid_angle is `steradians`, and the corresponding `base_unit` category is
        -: 2364:	 *				`solid_angle_unit`.
        -: 2365:	 * @sa			See unit_t for more information on unit type containers.
        -: 2366:	 */
        -: 2367:	namespace solid_angle
        -: 2368:	{
        -: 2369:		/**
        -: 2370:		 * @name Units (full names plural)
        -: 2371:		 * @{
        -: 2372:		 */
        -: 2373:		using steradians = unit<std::ratio<1>, category::solid_angle_unit>;
        -: 2374:		using degrees_squared = squared<angle::degrees>;
        -: 2375:		using spats = unit<std::ratio<4>, steradians, std::ratio<1>>;
        -: 2376:		/** @} */
        -: 2377:
        -: 2378:		/**
        -: 2379:		 * @name Units (full names singular)
        -: 2380:		 * @{
        -: 2381:		 */
        -: 2382:		using steradian = steradians;
        -: 2383:		using degree_squared = degrees_squared;
        -: 2384:		using spat = spats;
        -: 2385:		/** @} */
        -: 2386:
        -: 2387:		/**
        -: 2388:		 * @name Units (abbreviated names)
        -: 2389:		 * @{
        -: 2390:		 */
        -: 2391:		using sr = steradians;
        -: 2392:		using sq_deg = degrees_squared;
        -: 2393:		using sp = spat;
        -: 2394:		/** @} */
        -: 2395:
        -: 2396:		/**
        -: 2397:		 * @name Unit Containers
        -: 2398:		 * @anchor solidAngleContainers
        -: 2399:		 * @{
        -: 2400:		 */
        -: 2401:		using steradian_t = unit_t<steradian>;
        -: 2402:		using degree_squared_t = unit_t<degree_squared>;
        -: 2403:		using spat_t = unit_t<spat>;
        -: 2404:		/** @} */
        -: 2405:	}
        -: 2406:
        -: 2407:	namespace detail
        -: 2408:	{
        -: 2409:		template<typename T> struct is_solid_angle_unit_impl : std::false_type {};
        -: 2410:		template<typename C, typename U, typename P, typename T>
        -: 2411:		struct is_solid_angle_unit_impl<unit<C, U, P, T>> : std::is_same<base_unit_of<typename unit_traits<unit<C, U, P, T>>::base_unit_type>, category::solid_angle_unit>::type {};
        -: 2412:		template<typename U, typename S, template<typename> class N>
        -: 2413:		struct is_solid_angle_unit_impl<unit_t<U, S, N>> : std::is_same<base_unit_of<typename unit_t_traits<unit_t<U, S, N>>::unit_type>, category::solid_angle_unit>::type {};
        -: 2414:	}
        -: 2415:
        -: 2416:	/**
        -: 2417:	 * @ingroup		TypeTraits
        -: 2418:	 * @brief		Trait which tests whether a type represents a unit of solid_angle
        -: 2419:	 * @details		Inherits from `std::true_type` or `std::false_type`. Use `is_solid_angle_unit<T>::value` to test
        -: 2420:	 *				the unit represents a solid_angle quantity.
        -: 2421:	 * @tparam		T	one or more types to test
        -: 2422:	 */
        -: 2423:	template<typename... T> struct is_solid_angle_unit : std::integral_constant<bool, all_true<detail::is_solid_angle_unit_impl<typename std::decay<T>::type>::value...>::value> {};
        -: 2424:
        -: 2425:	//------------------------------
        -: 2426:	//	FREQUENCY UNITS
        -: 2427:	//------------------------------
        -: 2428:
        -: 2429:	/**
        -: 2430:	 * @brief		namespace for unit types and containers representing frequency values
        -: 2431:	 * @details		The SI unit for frequency is `hertz`, and the corresponding `base_unit` category is
        -: 2432:	 *				`frequency_unit`.
        -: 2433:	 * @sa			See unit_t for more information on unit type containers.
        -: 2434:	 */
        -: 2435:	namespace frequency
        -: 2436:	{
        -: 2437:		/**
        -: 2438:		 * @name Units (full names)
        -: 2439:		 * @{
        -: 2440:		 */
        -: 2441:		using hertz = unit<std::ratio<1>, category::frequency_unit>;
        -: 2442:		using kilohertz = kilo<hertz>;
        -: 2443:		using megahertz = mega<hertz>;
        -: 2444:		using gigahertz = giga<hertz>;
        -: 2445:		/** @} */
        -: 2446:
        -: 2447:		/**
        -: 2448:		 * @name Units (abbreviated names)
        -: 2449:		 * @{
        -: 2450:		 */
        -: 2451:		using Hz = hertz;
        -: 2452:		using kHz = kilohertz;
        -: 2453:		using MHz = megahertz;
        -: 2454:		using GHz = gigahertz;
        -: 2455:		/** @} */
        -: 2456:
        -: 2457:		/**
        -: 2458:		 * @name Unit Containers
        -: 2459:		 * @anchor frequencyContainers
        -: 2460:		 * @{
        -: 2461:		 */
        -: 2462:		using hertz_t = unit_t<hertz>;
        -: 2463:		using kilohertz_t = unit_t<kilohertz>;
        -: 2464:		using megahertz_t = unit_t<megahertz>;
        -: 2465:		using gigahertz_t = unit_t<gigahertz>;
        -: 2466:		/** @} */
        -: 2467:	}
        -: 2468:
        -: 2469:	namespace detail
        -: 2470:	{
        -: 2471:		template<typename T> struct is_frequency_unit_impl : std::false_type {};
        -: 2472:		template<typename C, typename U, typename P, typename T>
        -: 2473:		struct is_frequency_unit_impl<unit<C, U, P, T>> : std::is_same<base_unit_of<typename unit_traits<unit<C, U, P, T>>::base_unit_type>, category::frequency_unit>::type {};
        -: 2474:		template<typename U, typename S, template<typename> class N>
        -: 2475:		struct is_frequency_unit_impl<unit_t<U, S, N>> : std::is_same<base_unit_of<typename unit_t_traits<unit_t<U, S, N>>::unit_type>, category::frequency_unit>::type {};
        -: 2476:	}
        -: 2477:
        -: 2478:	/**
        -: 2479:	 * @ingroup		TypeTraits
        -: 2480:	 * @brief		Trait which tests whether a type represents a unit of frequency
        -: 2481:	 * @details		Inherits from `std::true_type` or `std::false_type`. Use `is_frequency_unit<T>::value` to test
        -: 2482:	 *				the unit represents a frequency quantity.
        -: 2483:	 * @tparam		T	one or more types to test
        -: 2484:	 */
        -: 2485:	template<typename... T> struct is_frequency_unit : std::integral_constant<bool, all_true<detail::is_frequency_unit_impl<typename std::decay<T>::type>::value...>::value> {};
        -: 2486:
        -: 2487:	//------------------------------
        -: 2488:	//	VELOCITY UNITS
        -: 2489:	//------------------------------
        -: 2490:
        -: 2491:	/**
        -: 2492:	 * @brief		namespace for unit types and containers representing velocity values
        -: 2493:	 * @details		The SI unit for velocity is `meters_per_second`, and the corresponding `base_unit` category is
        -: 2494:	 *				`velocity_unit`.
        -: 2495:	 * @sa			See unit_t for more information on unit type containers.
        -: 2496:	 */
        -: 2497:	namespace velocity
        -: 2498:	{
        -: 2499:		/**
        -: 2500:		 * @name  Units (full names plural)
        -: 2501:		 * @{
        -: 2502:		 */
        -: 2503:		using meters_per_second = unit<std::ratio<1>, category::velocity_unit>;
        -: 2504:		using feet_per_second = compound_unit<length::feet, inverse<time::seconds>>;
        -: 2505:		using miles_per_hour = compound_unit<length::miles, inverse<time::hour>>;
        -: 2506:		using kilometers_per_hour = compound_unit<length::kilometers, inverse<time::hour>>;
        -: 2507:		using knots = compound_unit<length::nauticalMiles, inverse<time::hour>>;
        -: 2508:		/** @} */
        -: 2509:
        -: 2510:		/**
        -: 2511:		 * @name Units (full names singular)
        -: 2512:		 * @{
        -: 2513:		 */
        -: 2514:		using knot = knots;
        -: 2515:		/** @} */
        -: 2516:
        -: 2517:		/**
        -: 2518:		 * @name Units (abbreviated names)
        -: 2519:		 * @{
        -: 2520:		 */
        -: 2521:		using mps = meters_per_second;
        -: 2522:		using mph = miles_per_hour;
        -: 2523:		using fps = feet_per_second;
        -: 2524:		using kmph = kilometers_per_hour;
        -: 2525:		/** @} */
        -: 2526:
        -: 2527:		/**
        -: 2528:		 * @name Unit Containers
        -: 2529:		 * @anchor velocityContainers
        -: 2530:		 * @{
        -: 2531:		 */
        -: 2532:		using meters_per_second_t = unit_t<meters_per_second>;
        -: 2533:		using feet_per_second_t = unit_t<feet_per_second>;
        -: 2534:		using miles_per_hour_t = unit_t<miles_per_hour>;
        -: 2535:		using kilometers_per_hour_t = unit_t<kilometers_per_hour>;
        -: 2536:		using knot_t = unit_t<knot>;
        -: 2537:		/** @} */
        -: 2538:	}
        -: 2539:
        -: 2540:	namespace detail
        -: 2541:	{
        -: 2542:		template<typename T> struct is_velocity_unit_impl : std::false_type {};
        -: 2543:		template<typename C, typename U, typename P, typename T>
        -: 2544:		struct is_velocity_unit_impl<unit<C, U, P, T>> : std::is_same<base_unit_of<typename unit_traits<unit<C, U, P, T>>::base_unit_type>, category::velocity_unit>::type {};
        -: 2545:		template<typename U, typename S, template<typename> class N>
        -: 2546:		struct is_velocity_unit_impl<unit_t<U, S, N>> : std::is_same<base_unit_of<typename unit_t_traits<unit_t<U, S, N>>::unit_type>, category::velocity_unit>::type {};
        -: 2547:	}
        -: 2548:
        -: 2549:	/**
        -: 2550:	 * @ingroup		TypeTraits
        -: 2551:	 * @brief		Trait which tests whether a type represents a unit of velocity
        -: 2552:	 * @details		Inherits from `std::true_type` or `std::false_type`. Use `is_velocity_unit<T>::value` to test
        -: 2553:	 *				the unit represents a velocity quantity.
        -: 2554:	 * @tparam		T	one or more types to test
        -: 2555:	 */
        -: 2556:	template<typename... T> struct is_velocity_unit : std::integral_constant<bool, all_true<detail::is_velocity_unit_impl<typename std::decay<T>::type>::value...>::value> {};
        -: 2557:
        -: 2558:	//------------------------------
        -: 2559:	//	ANGULAR VELOCITY UNITS
        -: 2560:	//------------------------------
        -: 2561:
        -: 2562:	/**
        -: 2563:	* @brief		namespace for unit types and containers representing angular velocity values
        -: 2564:	* @details		The SI unit for angular velocity is `radians_per_second`, and the corresponding `base_unit` category is
        -: 2565:	*				`angular_velocity_unit`.
        -: 2566:	* @sa			See unit_t for more information on unit type containers.
        -: 2567:	*/
        -: 2568:	namespace angular_velocity
        -: 2569:	{
        -: 2570:		/**
        -: 2571:		* @name  Units (full names plural)
        -: 2572:		* @{
        -: 2573:		*/
        -: 2574:		using radians_per_second = unit<std::ratio<1>, category::angular_velocity_unit>;
        -: 2575:		using degrees_per_second = compound_unit<angle::degrees, inverse<time::seconds>>;
        -: 2576:		using revolutions_per_minute = unit<std::ratio<2, 60>, radians_per_second, std::ratio<1>>;
        -: 2577:		using milliarcseconds_per_year = compound_unit<angle::milliarcseconds, inverse<time::year>>;
        -: 2578:		/** @} */
        -: 2579:
        -: 2580:		/**
        -: 2581:		* @name Units (full names singular)
        -: 2582:		* @{
        -: 2583:		*/
        -: 2584:		using radian_per_second = radians_per_second;
        -: 2585:		using degree_per_second = degrees_per_second;
        -: 2586:		using revolution_per_minute = revolutions_per_minute;
        -: 2587:		using milliarcsecond_per_year = milliarcseconds_per_year;
        -: 2588:		/** @} */
        -: 2589:
        -: 2590:		/**
        -: 2591:		* @name Units (abbreviated names)
        -: 2592:		* @{
        -: 2593:		*/
        -: 2594:		using rpm = revolutions_per_minute;
        -: 2595:		/** @} */
        -: 2596:
        -: 2597:		/**
        -: 2598:		* @name Unit Containers
        -: 2599:		* @anchor angular_velocityContainers
        -: 2600:		* @{
        -: 2601:		*/
        -: 2602:		using radians_per_second_t = unit_t<radians_per_second>;
        -: 2603:		using degrees_per_second_t = unit_t<degrees_per_second>;
        -: 2604:		using revolutions_per_minute_t = unit_t<revolutions_per_minute>;
        -: 2605:		using milliarcseconds_per_year_t = unit_t<milliarcseconds_per_year>;
        -: 2606:		/** @} */
        -: 2607:	}
        -: 2608:
        -: 2609:	/**
        -: 2610:	* @ingroup		TypeTraits
        -: 2611:	* @brief		Trait which tests whether a type represents a unit of angular_velocity
        -: 2612:	* @details		Inherits from `std::true_type` or `std::false_type`. Use `is_angular_velocity_unit<T>::value` to test
        -: 2613:	*				the unit represents a angular_velocity quantity.
        -: 2614:	* @tparam		T	one or more types to test
        -: 2615:	*/
        -: 2616:	template<typename T> struct is_angular_velocity_unit : std::false_type {};
        -: 2617:	template<typename C, typename U, typename P, typename T>
        -: 2618:	struct is_angular_velocity_unit<unit<C, U, P, T>> : std::is_same<base_unit_of<typename unit_traits<unit<C, U, P, T>>::base_unit_type>, category::angular_velocity_unit>::type {};
        -: 2619:	template<typename U, typename S, template<typename> class N>
        -: 2620:	struct is_angular_velocity_unit<unit_t<U, S, N>> : std::is_same<base_unit_of<typename unit_t_traits<unit_t<U, S, N>>::unit_type>, category::angular_velocity_unit>::type {};
        -: 2621:
        -: 2622:	//------------------------------
        -: 2623:	//	UNITS OF ACCELERATION
        -: 2624:	//------------------------------
        -: 2625:
        -: 2626:	/**
        -: 2627:	 * @brief		namespace for unit types and containers representing acceleration values
        -: 2628:	 * @details		The SI unit for acceleration is `meters_per_second_squared`, and the corresponding `base_unit` category is
        -: 2629:	 *				`acceleration_unit`.
        -: 2630:	 * @sa			See unit_t for more information on unit type containers.
        -: 2631:	 */
        -: 2632:	namespace acceleration
        -: 2633:	{
        -: 2634:		/**
        -: 2635:		 * @name Units (full names plural)
        -: 2636:		 * @{
        -: 2637:		 */
        -: 2638:		using meters_per_second_squared = unit<std::ratio<1>, category::acceleration_unit>;
        -: 2639:		using feet_per_second_squared = compound_unit<length::feet, inverse<squared<time::seconds>>>;
        -: 2640:		using standard_gravity = unit<std::ratio<980665, 100000>, meters_per_second_squared>;
        -: 2641:		/** @} */
        -: 2642:
        -: 2643:		/**
        -: 2644:		 * @name Unit Containers
        -: 2645:		 * @anchor accelerationContainers
        -: 2646:		 * @{
        -: 2647:		 */
        -: 2648:		using meters_per_second_squared_t = unit_t<meters_per_second_squared>;
        -: 2649:		using feet_per_second_squared_t = unit_t<feet_per_second_squared>;
        -: 2650:		using standard_gravity_t = unit_t<standard_gravity>;
        -: 2651:		/** @} */
        -: 2652:	}
        -: 2653:
        -: 2654:	namespace detail
        -: 2655:	{
        -: 2656:		template<typename T> struct is_acceleration_unit_impl : std::false_type {};
        -: 2657:		template<typename C, typename U, typename P, typename T>
        -: 2658:		struct is_acceleration_unit_impl<unit<C, U, P, T>> : std::is_same<base_unit_of<typename unit_traits<unit<C, U, P, T>>::base_unit_type>, category::acceleration_unit>::type {};
        -: 2659:		template<typename U, typename S, template<typename> class N>
        -: 2660:		struct is_acceleration_unit_impl<unit_t<U, S, N>> : std::is_same<base_unit_of<typename unit_t_traits<unit_t<U, S, N>>::unit_type>, category::acceleration_unit>::type {};
        -: 2661:	}
        -: 2662:
        -: 2663:	/**
        -: 2664:	 * @ingroup		TypeTraits
        -: 2665:	 * @brief		Trait which tests whether a type represents a unit of acceleration
        -: 2666:	 * @details		Inherits from `std::true_type` or `std::false_type`. Use `is_acceleration_unit<T>::value` to test
        -: 2667:	 *				the unit represents a acceleration quantity.
        -: 2668:	 * @tparam		T	one or more types to test
        -: 2669:	 */
        -: 2670:	template<typename... T> struct is_acceleration_unit : std::integral_constant<bool, all_true<detail::is_acceleration_unit_impl<typename std::decay<T>::type>::value...>::value> {};
        -: 2671:
        -: 2672:	//------------------------------
        -: 2673:	//	UNITS OF FORCE
        -: 2674:	//------------------------------
        -: 2675:
        -: 2676:	/**
        -: 2677:	 * @brief		namespace for unit types and containers representing force values
        -: 2678:	 * @details		The SI unit for force is `newtons`, and the corresponding `base_unit` category is
        -: 2679:	 *				`force_unit`.
        -: 2680:	 * @sa			See unit_t for more information on unit type containers.
        -: 2681:	 */
        -: 2682:	namespace force
        -: 2683:	{
        -: 2684:		/**
        -: 2685:		 * @name Units (full names plural)
        -: 2686:		 * @{
        -: 2687:		 */
        -: 2688:		using newtons = unit<std::ratio<1>, category::force_unit>;
        -: 2689:		using pounds = compound_unit<mass::slug, length::foot, inverse<squared<time::seconds>>>;
        -: 2690:		using dynes = unit<std::ratio<1, 100000>, newtons>;
        -: 2691:		using kiloponds = compound_unit<acceleration::standard_gravity, mass::kilograms>;
        -: 2692:		using poundals = compound_unit<mass::pound, length::foot, inverse<squared<time::seconds>>>;
        -: 2693:		/** @} */
        -: 2694:
        -: 2695:		/**
        -: 2696:		 * @name Units (full names singular)
        -: 2697:		 * @{
        -: 2698:		 */
        -: 2699:		using newton = newtons;
        -: 2700:		using pound = pounds;
        -: 2701:		using dyne = dynes;
        -: 2702:		using kilopond = kiloponds;
        -: 2703:		using poundal = poundals;
        -: 2704:		/** @} */
        -: 2705:
        -: 2706:		/**
        -: 2707:		 * @name Units (abbreviated names)
        -: 2708:		 * @{
        -: 2709:		 */
        -: 2710:		using N = newtons;
        -: 2711:		using lbf = pounds;
        -: 2712:		using dyn = dynes;
        -: 2713:		using kp = kiloponds;
        -: 2714:		using pdl = poundals;
        -: 2715:		/** @} */
        -: 2716:
        -: 2717:		/**
        -: 2718:		 * @name Unit Containers
        -: 2719:		 * @anchor forceContainers
        -: 2720:		 * @{
        -: 2721:		 */
        -: 2722:		using newton_t = unit_t<newton>;
        -: 2723:		using pound_t = unit_t<pound>;
        -: 2724:		using dyne_t = unit_t<dyne>;
        -: 2725:		using kilopond_t = unit_t<kilopond>;
        -: 2726:		using poundal_t = unit_t<poundal>;
        -: 2727:		/** @} */
        -: 2728:	}
        -: 2729:
        -: 2730:	namespace detail
        -: 2731:	{
        -: 2732:		template<typename T> struct is_force_unit_impl : std::false_type {};
        -: 2733:		template<typename C, typename U, typename P, typename T>
        -: 2734:		struct is_force_unit_impl<unit<C, U, P, T>> : std::is_same<base_unit_of<typename unit_traits<unit<C, U, P, T>>::base_unit_type>, category::force_unit>::type {};
        -: 2735:		template<typename U, typename S, template<typename> class N>
        -: 2736:		struct is_force_unit_impl<unit_t<U, S, N>> : std::is_same<base_unit_of<typename unit_t_traits<unit_t<U, S, N>>::unit_type>, category::force_unit>::type {};
        -: 2737:	}
        -: 2738:
        -: 2739:	/**
        -: 2740:	 * @ingroup		TypeTraits
        -: 2741:	 * @brief		Trait which tests whether a type represents a unit of force
        -: 2742:	 * @details		Inherits from `std::true_type` or `std::false_type`. Use `is_force_unit<T>::value` to test
        -: 2743:	 *				the unit represents a force quantity.
        -: 2744:	 * @tparam		T	one or more types to test
        -: 2745:	 */
        -: 2746:	template<typename... T> struct is_force_unit : std::integral_constant<bool, all_true<detail::is_force_unit_impl<typename std::decay<T>::type>::value...>::value> {};
        -: 2747:
        -: 2748:	//------------------------------
        -: 2749:	//	UNITS OF PRESSURE
        -: 2750:	//------------------------------
        -: 2751:
        -: 2752:	/**
        -: 2753:	 * @brief		namespace for unit types and containers representing pressure values
        -: 2754:	 * @details		The SI unit for pressure is `pascals`, and the corresponding `base_unit` category is
        -: 2755:	 *				`pressure_unit`.
        -: 2756:	 * @sa			See unit_t for more information on unit type containers.
        -: 2757:	 */
        -: 2758:	namespace pressure
        -: 2759:	{
        -: 2760:		/**
        -: 2761:		 * @name Units (full names plural)
        -: 2762:		 * @{
        -: 2763:		 */
        -: 2764:		using pascals = unit<std::ratio<1>, category::pressure_unit>;
        -: 2765:		using bars = unit<std::ratio<100>, kilo<pascals>>;
        -: 2766:		using atmospheres = unit<std::ratio<101325>, pascals>;
        -: 2767:		using pounds_per_square_inch = compound_unit<force::pounds, inverse<squared<length::inch>>>;
        -: 2768:		using torrs = unit<std::ratio<1, 760>, atmospheres>;
        -: 2769:		/** @} */
        -: 2770:
        -: 2771:		/**
        -: 2772:		 * @name  Units (full names singular)
        -: 2773:		 * @{
        -: 2774:		 */
        -: 2775:		using pascal = pascals;
        -: 2776:		using bar = bars;
        -: 2777:		using atmosphere = atmospheres;
        -: 2778:		using pound_per_square_inch = pounds_per_square_inch;
        -: 2779:		using torr = torrs;
        -: 2780:		/** @} */
        -: 2781:
        -: 2782:		/**
        -: 2783:		 * @name Units (abbreviated names)
        -: 2784:		 * @{
        -: 2785:		 */
        -: 2786:		using Pa = pascals;
        -: 2787:		using atm = atmospheres;
        -: 2788:		using psi = pound_per_square_inch;
        -: 2789:		/** @} */
        -: 2790:
        -: 2791:		/**
        -: 2792:		 * @name Unit Containers
        -: 2793:		 * @anchor pressureContainers
        -: 2794:		 * @{
        -: 2795:		 */
        -: 2796:		using pascal_t = unit_t<pascal>;
        -: 2797:		using bar_t = unit_t<bar>;
        -: 2798:		using atmosphere_t = unit_t<atmosphere>;
        -: 2799:		using pound_per_square_inch_t = unit_t<pound_per_square_inch>;
        -: 2800:		using torr_t = unit_t<torr>;
        -: 2801:		/** @} */
        -: 2802:	}
        -: 2803:
        -: 2804:	namespace detail
        -: 2805:	{
        -: 2806:		template<typename T> struct is_pressure_unit_impl : std::false_type {};
        -: 2807:		template<typename C, typename U, typename P, typename T>
        -: 2808:		struct is_pressure_unit_impl<unit<C, U, P, T>> : std::is_same<base_unit_of<typename unit_traits<unit<C, U, P, T>>::base_unit_type>, category::pressure_unit>::type {};
        -: 2809:		template<typename U, typename S, template<typename> class N>
        -: 2810:		struct is_pressure_unit_impl<unit_t<U, S, N>> : std::is_same<base_unit_of<typename unit_t_traits<unit_t<U, S, N>>::unit_type>, category::pressure_unit>::type {};
        -: 2811:	}
        -: 2812:
        -: 2813:	/**
        -: 2814:	 * @ingroup		TypeTraits
        -: 2815:	 * @brief		Trait which tests whether a type represents a unit of pressure
        -: 2816:	 * @details		Inherits from `std::true_type` or `std::false_type`. Use `is_pressure_unit<T>::value` to test
        -: 2817:	 *				the unit represents a pressure quantity.
        -: 2818:	 * @tparam		T	one or more types to test
        -: 2819:	 */
        -: 2820:	template<typename... T> struct is_pressure_unit : std::integral_constant<bool, all_true<detail::is_pressure_unit_impl<typename std::decay<T>::type>::value...>::value> {};
        -: 2821:
        -: 2822:	//------------------------------
        -: 2823:	//	UNITS OF CHARGE
        -: 2824:	//------------------------------
        -: 2825:
        -: 2826:	/**
        -: 2827:	 * @brief		namespace for unit types and containers representing charge values
        -: 2828:	 * @details		The SI unit for charge is `coulombs`, and the corresponding `base_unit` category is
        -: 2829:	 *				`charge_unit`.
        -: 2830:	 * @sa			See unit_t for more information on unit type containers.
        -: 2831:	 */
        -: 2832:	namespace charge
        -: 2833:	{
        -: 2834:		/**
        -: 2835:		 * @name Units (full names plural)
        -: 2836:		 * @{
        -: 2837:		 */
        -: 2838:		using coulombs = unit<std::ratio<1>, category::charge_unit>;
        -: 2839:		using ampere_hours = compound_unit<current::ampere, time::hours>;
        -: 2840:		/** @} */
        -: 2841:
        -: 2842:		/**
        -: 2843:		 * @name Units (full names singular)
        -: 2844:		 * @{
        -: 2845:		 */
        -: 2846:		using coulomb = coulombs;
        -: 2847:		using ampere_hour = ampere_hours;
        -: 2848:		/** @} */
        -: 2849:
        -: 2850:		/**
        -: 2851:		 * @name Units (abbreviated names)
        -: 2852:		 * @{
        -: 2853:		 */
        -: 2854:		using C = coulombs;
        -: 2855:		using Ah = ampere_hours;
        -: 2856:		/** @} */
        -: 2857:
        -: 2858:		/**
        -: 2859:		 * @name Unit Containers
        -: 2860:		 * @anchor chargeContainers
        -: 2861:		 * @{
        -: 2862:		 */
        -: 2863:		using coulomb_t = unit_t<coulomb>;
        -: 2864:		using ampere_hour_t = unit_t<ampere_hour>;
        -: 2865:		/** @} */
        -: 2866:	}
        -: 2867:
        -: 2868:	namespace detail
        -: 2869:	{
        -: 2870:		template<typename T> struct is_charge_unit_impl : std::false_type {};
        -: 2871:		template<typename C, typename U, typename P, typename T>
        -: 2872:		struct is_charge_unit_impl<unit<C, U, P, T>> : std::is_same<base_unit_of<typename unit_traits<unit<C, U, P, T>>::base_unit_type>, category::charge_unit>::type {};
        -: 2873:		template<typename U, typename S, template<typename> class N>
        -: 2874:		struct is_charge_unit_impl<unit_t<U, S, N>> : std::is_same<base_unit_of<typename unit_t_traits<unit_t<U, S, N>>::unit_type>, category::charge_unit>::type {};
        -: 2875:	}
        -: 2876:
        -: 2877:	/**
        -: 2878:	 * @ingroup		TypeTraits
        -: 2879:	 * @brief		Trait which tests whether a type represents a unit of charge
        -: 2880:	 * @details		Inherits from `std::true_type` or `std::false_type`. Use `is_charge_unit<T>::value` to test
        -: 2881:	 *				the unit represents a charge quantity.
        -: 2882:	 * @tparam		T	one or more types to test
        -: 2883:	 */
        -: 2884:	template<typename... T> struct is_charge_unit : std::integral_constant<bool, all_true<detail::is_charge_unit_impl<typename std::decay<T>::type>::value...>::value> {};
        -: 2885:
        -: 2886:	//------------------------------
        -: 2887:	//	UNITS OF ENERGY
        -: 2888:	//------------------------------
        -: 2889:
        -: 2890:	/**
        -: 2891:	 * @brief		namespace for unit types and containers representing energy values
        -: 2892:	 * @details		The SI unit for energy is `joules`, and the corresponding `base_unit` category is
        -: 2893:	 *				`energy_unit`.
        -: 2894:	 * @sa			See unit_t for more information on unit type containers.
        -: 2895:	 */
        -: 2896:	namespace energy
        -: 2897:	{
        -: 2898:		/**
        -: 2899:		 * @name Units (full names plural)
        -: 2900:		 * @{
        -: 2901:		 */
        -: 2902:		using joules = unit<std::ratio<1>, category::energy_unit>;
        -: 2903:		using megajoules = mega<joules>;
        -: 2904:		using kilojoules = kilo<joules>;
        -: 2905:		using calories = unit<std::ratio<4184, 1000>, joules>;
        -: 2906:		using kilocalories = kilo<calories>;
        -: 2907:		using kilowatt_hours = unit<std::ratio<36, 10>, megajoules>;
        -: 2908:		using watt_hours = unit<std::ratio<1, 1000>, kilowatt_hours>;
        -: 2909:		using british_thermal_units = unit<std::ratio<105505585262, 100000000>, joules>;
        -: 2910:		using british_thermal_units_iso = unit<std::ratio<1055056, 1000>, joules>;
        -: 2911:		using british_thermal_units_59 = unit<std::ratio<1054804, 1000>, joules>;
        -: 2912:		using therms = unit<std::ratio<100000>, british_thermal_units_59>;
        -: 2913:		using foot_pounds = unit<std::ratio<13558179483314004, 10000000000000000>, joules>;
        -: 2914:		/** @} */
        -: 2915:
        -: 2916:		/**
        -: 2917:		 * @name Units (full names singular)
        -: 2918:		 * @{
        -: 2919:		 */
        -: 2920:		using joule = joules;
        -: 2921:		using megajoule = megajoules;
        -: 2922:		using kilojoule = kilojoules;
        -: 2923:		using calorie = calories;
        -: 2924:		using kilocalorie = kilocalories;
        -: 2925:		using watt_hour = watt_hours;
        -: 2926:		using kilowatt_hour = kilowatt_hours;
        -: 2927:		using british_thermal_unit = british_thermal_units;
        -: 2928:		using therm = therms;
        -: 2929:		using foot_pound = foot_pounds;
        -: 2930:		/** @} */
        -: 2931:
        -: 2932:		/**
        -: 2933:		 * @name Units (abbreviated names)
        -: 2934:		 * @{
        -: 2935:		 */
        -: 2936:		using J = joules;
        -: 2937:		using MJ = megajoules;
        -: 2938:		using kJ = kilojoules;
        -: 2939:		using cal = calories;
        -: 2940:		using kcal = kilocalories;
        -: 2941:		using Wh = watt_hours;
        -: 2942:		using kWh = kilowatt_hours;
        -: 2943:		using BTU = british_thermal_units;
        -: 2944:		using thm = therms;
        -: 2945:		using ftlbf = foot_pounds;
        -: 2946:		/** @} */
        -: 2947:
        -: 2948:		/**
        -: 2949:		 * @name Unit Containers
        -: 2950:		 * @anchor energyContainers
        -: 2951:		 * @{
        -: 2952:		 */
        -: 2953:		using joule_t = unit_t<joule>;
        -: 2954:		using megajoule_t = unit_t<megajoule>;
        -: 2955:		using kilojoule_t = unit_t<kilojoule>;
        -: 2956:		using calorie_t = unit_t<calorie>;
        -: 2957:		using kilocalorie_t = unit_t<kilocalorie>;
        -: 2958:		using watt_hour_t = unit_t<watt_hour>;
        -: 2959:		using kilowatt_hour_t = unit_t<kilowatt_hour>;
        -: 2960:		using british_thermal_unit_t = unit_t<british_thermal_unit>;
        -: 2961:		using therm_t = unit_t<therm>;
        -: 2962:		using foot_pound_t = unit_t<foot_pound>;
        -: 2963:		/** @} */
        -: 2964:	}
        -: 2965:
        -: 2966:	namespace detail
        -: 2967:	{
        -: 2968:		template<typename T> struct is_energy_unit_impl : std::false_type {};
        -: 2969:		template<typename C, typename U, typename P, typename T>
        -: 2970:		struct is_energy_unit_impl<unit<C, U, P, T>> : std::is_same<base_unit_of<typename unit_traits<unit<C, U, P, T>>::base_unit_type>, category::energy_unit>::type {};
        -: 2971:		template<typename U, typename S, template<typename> class N>
        -: 2972:		struct is_energy_unit_impl<unit_t<U, S, N>> : std::is_same<base_unit_of<typename unit_t_traits<unit_t<U, S, N>>::unit_type>, category::energy_unit>::type {};
        -: 2973:	}
        -: 2974:
        -: 2975:	/**
        -: 2976:	 * @ingroup		TypeTraits
        -: 2977:	 * @brief		Trait which tests whether a type represents a unit of energy
        -: 2978:	 * @details		Inherits from `std::true_type` or `std::false_type`. Use `is_energy_unit<T>::value` to test
        -: 2979:	 *				the unit represents a energy quantity.
        -: 2980:	 * @tparam		T	one or more types to test
        -: 2981:	 */
        -: 2982:	template<typename... T> struct is_energy_unit : std::integral_constant<bool, all_true<detail::is_energy_unit_impl<typename std::decay<T>::type>::value...>::value> {};
        -: 2983:
        -: 2984:	//------------------------------
        -: 2985:	//	UNITS OF POWER
        -: 2986:	//------------------------------
        -: 2987:
        -: 2988:	/**
        -: 2989:	 * @brief		namespace for unit types and containers representing power values
        -: 2990:	 * @details		The SI unit for power is `watts`, and the corresponding `base_unit` category is
        -: 2991:	 *				`power_unit`.
        -: 2992:	 * @sa			See unit_t for more information on unit type containers.
        -: 2993:	 */
        -: 2994:	namespace power
        -: 2995:	{
        -: 2996:		/**
        -: 2997:		 * @name Units (full names plural)
        -: 2998:		 * @{
        -: 2999:		 */
        -: 3000:		using watts = unit<std::ratio<1>, category::power_unit>;
        -: 3001:		using nanowatts = nano<watts>;
        -: 3002:		using microwatts = micro<watts>;
        -: 3003:		using milliwatts = milli<watts>;
        -: 3004:		using kilowatts = kilo<watts>;
        -: 3005:		using megawatts = mega<watts>;
        -: 3006:		using gigawatts = giga<watts>;
        -: 3007:		using horsepower = unit<std::ratio<7457, 10>, watts>;
        -: 3008:		/** @} */
        -: 3009:
        -: 3010:		/**
        -: 3011:		 * @name Units (full names singular)
        -: 3012:		 * @{
        -: 3013:		 */
        -: 3014:		using watt = watts;
        -: 3015:		using nanowatt = nanowatts;
        -: 3016:		using microwatt = microwatts;
        -: 3017:		using milliwatt = milliwatts;
        -: 3018:		using kilwatt = kilowatts;
        -: 3019:		using megawatt = megawatts;
        -: 3020:		using gigawatt = gigawatts;
        -: 3021:		/** @} */
        -: 3022:
        -: 3023:		/**
        -: 3024:		 * @name Units (abbreviated names)
        -: 3025:		 * @{
        -: 3026:		 */
        -: 3027:		using W = watts;
        -: 3028:		using nW = nanowatts;
        -: 3029:		using uW = microwatts;
        -: 3030:		using mW = milliwatts;
        -: 3031:		using kW = kilowatts;
        -: 3032:		using MW = megawatts;
        -: 3033:		using GW = gigawatts;
        -: 3034:		using hp = horsepower;
        -: 3035:		/** @} */
        -: 3036:
        -: 3037:		/**
        -: 3038:		 * @name Unit Containers
        -: 3039:		 * @anchor powerContainers
        -: 3040:		 * @{
        -: 3041:		 */
        -: 3042:		using watt_t = unit_t<watt>;
        -: 3043:		using nanowatt_t = unit_t<nanowatt>;
        -: 3044:		using microwatt_t = unit_t<microwatt>;
        -: 3045:		using milliwatt_t = unit_t<milliwatt>;
        -: 3046:		using kilwatt_t = unit_t<kilwatt>;
        -: 3047:		using megawatt_t = unit_t<megawatt>;
        -: 3048:		using gigawatt_t = unit_t<gigawatt>;
        -: 3049:
        -: 3050:		using dBW_t = unit_t<watt, double, decibel_scale>;
        -: 3051:		using dBm_t = unit_t<milliwatt, double, decibel_scale>;
        -: 3052:		/** @} */
        -: 3053:	}
        -: 3054:
        -: 3055:	namespace detail
        -: 3056:	{
        -: 3057:		template<typename T> struct is_power_unit_impl : std::false_type {};
        -: 3058:		template<typename C, typename U, typename P, typename T>
        -: 3059:		struct is_power_unit_impl<unit<C, U, P, T>> : std::is_same<base_unit_of<typename unit_traits<unit<C, U, P, T>>::base_unit_type>, category::power_unit>::type {};
        -: 3060:		template<typename U, typename S, template<typename> class N>
        -: 3061:		struct is_power_unit_impl<unit_t<U, S, N>> : std::is_same<base_unit_of<typename unit_t_traits<unit_t<U, S, N>>::unit_type>, category::power_unit>::type {};
        -: 3062:	}
        -: 3063:
        -: 3064:	/**
        -: 3065:	 * @ingroup		TypeTraits
        -: 3066:	 * @brief		Trait which tests whether a type represents a unit of power
        -: 3067:	 * @details		Inherits from `std::true_type` or `std::false_type`. Use `is_power_unit<T>::value` to test
        -: 3068:	 *				the unit represents a power quantity.
        -: 3069:	 * @tparam		T	one or more types to test
        -: 3070:	 */
        -: 3071:	template<typename... T> struct is_power_unit : std::integral_constant<bool, all_true<detail::is_power_unit_impl<typename std::decay<T>::type>::value...>::value> {};
        -: 3072:
        -: 3073:	//------------------------------
        -: 3074:	//	UNITS OF VOLTAGE
        -: 3075:	//------------------------------
        -: 3076:
        -: 3077:	/**
        -: 3078:	 * @brief		namespace for unit types and containers representing voltage values
        -: 3079:	 * @details		The SI unit for voltage is `volts`, and the corresponding `base_unit` category is
        -: 3080:	 *				`voltage_unit`.
        -: 3081:	 * @sa			See unit_t for more information on unit type containers.
        -: 3082:	 */
        -: 3083:	namespace voltage
        -: 3084:	{
        -: 3085:		/**
        -: 3086:		 * @name Units (full names plural)
        -: 3087:		 * @{
        -: 3088:		 */
        -: 3089:		using volts = unit<std::ratio<1>, category::voltage_unit>;
        -: 3090:		using picovolts = pico<volts>;
        -: 3091:		using nanovolts = nano<volts>;
        -: 3092:		using microvolts = micro<volts>;
        -: 3093:		using millivolts = milli<volts>;
        -: 3094:		using kilovolts = kilo<volts>;
        -: 3095:		using megavolts = mega<volts>;
        -: 3096:		using gigavolts = giga<volts>;
        -: 3097:		using statvolts = unit<std::ratio<1000000, 299792458>, volts>;
        -: 3098:		using abvolts = unit<std::ratio<1, 100000000>, volts>;
        -: 3099:		/** @} */
        -: 3100:
        -: 3101:		/**
        -: 3102:		 * @name Units (full names singular)
        -: 3103:		 * @{
        -: 3104:		 */
        -: 3105:		using volt = volts;
        -: 3106:		using picovolt = picovolts;
        -: 3107:		using nanovolt = nanovolts;
        -: 3108:		using microvolt = microvolts;
        -: 3109:		using millivolt = millivolts;
        -: 3110:		using kilovolt = kilovolts;
        -: 3111:		using megavolt = megavolts;
        -: 3112:		using gigavolt = gigavolts;
        -: 3113:		using statvolt = statvolts;
        -: 3114:		using abvolt = abvolts;
        -: 3115:		/** @} */
        -: 3116:
        -: 3117:		/**
        -: 3118:		 * @name Units (abbreviated names)
        -: 3119:		 * @{
        -: 3120:		 */
        -: 3121:		using volt_t = unit_t<volt>;
        -: 3122:		using picovolt_t = unit_t<picovolt>;
        -: 3123:		using nanovolt_t = unit_t<nanovolt>;
        -: 3124:		using microvolt_t = unit_t<microvolt>;
        -: 3125:		using millivolt_t = unit_t<millivolt>;
        -: 3126:		using kilovolt_t = unit_t<kilovolt>;
        -: 3127:		using megavolt_t = unit_t<megavolt>;
        -: 3128:		using gigavolt_t = unit_t<gigavolt>;
        -: 3129:		using statvolt_t = unit_t<statvolt>;
        -: 3130:		using abvolt_t = unit_t<abvolt>;
        -: 3131:		/** @} */
        -: 3132:
        -: 3133:		/**
        -: 3134:		 * @name Unit Containers
        -: 3135:		 * @anchor voltageContainers
        -: 3136:		 * @{
        -: 3137:		 */
        -: 3138:		using V = volts;
        -: 3139:		using pV = picovolts;
        -: 3140:		using nV = nanovolts;
        -: 3141:		using uV = microvolts;
        -: 3142:		using mV = millivolts;
        -: 3143:		using kV = kilovolts;
        -: 3144:		using MV = megavolts;
        -: 3145:		using GV = gigavolts;
        -: 3146:		using statV = statvolts;
        -: 3147:		using abV = abvolts;
        -: 3148:		/** @} */
        -: 3149:	}
        -: 3150:
        -: 3151:	namespace detail
        -: 3152:	{
        -: 3153:		template<typename T> struct is_voltage_unit_impl : std::false_type {};
        -: 3154:		template<typename C, typename U, typename P, typename T>
        -: 3155:		struct is_voltage_unit_impl<unit<C, U, P, T>> : std::is_same<base_unit_of<typename unit_traits<unit<C, U, P, T>>::base_unit_type>, category::voltage_unit>::type {};
        -: 3156:		template<typename U, typename S, template<typename> class N>
        -: 3157:		struct is_voltage_unit_impl<unit_t<U, S, N>> : std::is_same<base_unit_of<typename unit_t_traits<unit_t<U, S, N>>::unit_type>, category::voltage_unit>::type {};
        -: 3158:	}
        -: 3159:
        -: 3160:	/**
        -: 3161:	 * @ingroup		TypeTraits
        -: 3162:	 * @brief		Trait which tests whether a type represents a unit of voltage
        -: 3163:	 * @details		Inherits from `std::true_type` or `std::false_type`. Use `is_voltage_unit<T>::value` to test
        -: 3164:	 *				the unit represents a voltage quantity.
        -: 3165:	 * @tparam		T	one or more types to test
        -: 3166:	 */
        -: 3167:	template<typename... T> struct is_voltage_unit : std::integral_constant<bool, all_true<detail::is_voltage_unit_impl<typename std::decay<T>::type>::value...>::value> {};
        -: 3168:
        -: 3169:	//------------------------------
        -: 3170:	//	UNITS OF CAPACITANCE
        -: 3171:	//------------------------------
        -: 3172:
        -: 3173:	/**
        -: 3174:	 * @brief		namespace for unit types and containers representing capacitance values
        -: 3175:	 * @details		The SI unit for capacitance is `farads`, and the corresponding `base_unit` category is
        -: 3176:	 *				`capacitance_unit`.
        -: 3177:	 * @sa			See unit_t for more information on unit type containers.
        -: 3178:	 */
        -: 3179:	namespace capacitance
        -: 3180:	{
        -: 3181:		/**
        -: 3182:		 * @name Units (full names plural)
        -: 3183:		 * @{
        -: 3184:		 */
        -: 3185:		using farads = unit<std::ratio<1>, category::capacitance_unit>;
        -: 3186:		using picofarads = pico<farads>;
        -: 3187:		using nanofarads = nano<farads>;
        -: 3188:		using microfarads = micro<farads>;
        -: 3189:		using millifarads = milli<farads>;
        -: 3190:		using kilofarads = kilo<farads>;
        -: 3191:		using megafarads = mega<farads>;
        -: 3192:		using gigafarads = giga<farads>;
        -: 3193:		/** @} */
        -: 3194:
        -: 3195:		/**
        -: 3196:		 * @name Units (full names singular)
        -: 3197:		 * @{
        -: 3198:		 */
        -: 3199:		using farad = farads;
        -: 3200:		using picofarad = picofarads;
        -: 3201:		using nanofarad = nanofarads;
        -: 3202:		using microfarad = microfarads;
        -: 3203:		using millifarad = millifarads;
        -: 3204:		using kilofarad = kilofarads;
        -: 3205:		using megafarad = megafarads;
        -: 3206:		using gigafarad = gigafarads;
        -: 3207:		/** @} */
        -: 3208:
        -: 3209:		/**
        -: 3210:		 * @name  Units (abbreviated names)
        -: 3211:		 * @{
        -: 3212:		 */
        -: 3213:		using F = farads;
        -: 3214:		using pF = picofarads;
        -: 3215:		using nF = nanofarads;
        -: 3216:		using uF = microfarads;
        -: 3217:		using mF = millifarads;
        -: 3218:		using kF = kilofarads;
        -: 3219:		using MF = megafarads;
        -: 3220:		using GF = gigafarads;
        -: 3221:		/** @} */
        -: 3222:
        -: 3223:		/**
        -: 3224:		 * @name Unit Containers
        -: 3225:		 * @anchor capacitanceContainers
        -: 3226:		 * @{
        -: 3227:		 */
        -: 3228:		using farad_t = unit_t<farad>;
        -: 3229:		using picofarad_t = unit_t<picofarad>;
        -: 3230:		using nanofarad_t = unit_t<nanofarad>;
        -: 3231:		using microfarad_t = unit_t<microfarad>;
        -: 3232:		using millifarad_t = unit_t<millifarad>;
        -: 3233:		using kilofarad_t = unit_t<kilofarad>;
        -: 3234:		using megafarad_t = unit_t<megafarad>;
        -: 3235:		using gigafarad_t = unit_t<gigafarad>;
        -: 3236:		/** @} */
        -: 3237:	}
        -: 3238:
        -: 3239:	namespace detail
        -: 3240:	{
        -: 3241:		template<typename T> struct is_capacitance_unit_impl : std::false_type {};
        -: 3242:		template<typename C, typename U, typename P, typename T>
        -: 3243:		struct is_capacitance_unit_impl<unit<C, U, P, T>> : std::is_same<base_unit_of<typename unit_traits<unit<C, U, P, T>>::base_unit_type>, category::capacitance_unit>::type {};
        -: 3244:		template<typename U, typename S, template<typename> class N>
        -: 3245:		struct is_capacitance_unit_impl<unit_t<U, S, N>> : std::is_same<base_unit_of<typename unit_t_traits<unit_t<U, S, N>>::unit_type>, category::capacitance_unit>::type {};
        -: 3246:	}
        -: 3247:
        -: 3248:	/**
        -: 3249:	 * @ingroup		TypeTraits
        -: 3250:	 * @brief		Trait which tests whether a type represents a unit of capacitance
        -: 3251:	 * @details		Inherits from `std::true_type` or `std::false_type`. Use `is_capacitance_unit<T>::value` to test
        -: 3252:	 *				the unit represents a capacitance quantity.
        -: 3253:	 * @tparam		T	one or more types to test
        -: 3254:	 */
        -: 3255:	template<typename... T> struct is_capacitance_unit : std::integral_constant<bool, all_true<detail::is_capacitance_unit_impl<typename std::decay<T>::type>::value...>::value> {};
        -: 3256:
        -: 3257:	//------------------------------
        -: 3258:	//	UNITS OF IMPEDANCE
        -: 3259:	//------------------------------
        -: 3260:
        -: 3261:	/**
        -: 3262:	 * @brief		namespace for unit types and containers representing impedance values
        -: 3263:	 * @details		The SI unit for impedance is `ohms`, and the corresponding `base_unit` category is
        -: 3264:	 *				`impedance_unit`.
        -: 3265:	 * @sa			See unit_t for more information on unit type containers.
        -: 3266:	 */
        -: 3267:	namespace impedance
        -: 3268:	{
        -: 3269:		/**
        -: 3270:		 * @name Units (full names plural)
        -: 3271:		 * @{
        -: 3272:		 */
        -: 3273:		using ohms = unit<std::ratio<1>, category::impedance_unit>;
        -: 3274:		using picoohms = pico<ohms>;
        -: 3275:		using nanoohms = nano<ohms>;
        -: 3276:		using microohms = micro<ohms>;
        -: 3277:		using milliohms = milli<ohms>;
        -: 3278:		using kiloohms = kilo<ohms>;
        -: 3279:		using megaohms = mega<ohms>;
        -: 3280:		using gigaohms = giga<ohms>;
        -: 3281:		/** @} */
        -: 3282:
        -: 3283:		/**
        -: 3284:		 * @name Units (full names singular)
        -: 3285:		 * @{
        -: 3286:		 */
        -: 3287:		using ohm = ohms;
        -: 3288:		using picoohm = picoohms;
        -: 3289:		using nanoohm = nanoohms;
        -: 3290:		using microohm = microohms;
        -: 3291:		using milliohm = milliohms;
        -: 3292:		using kiloohm = kiloohms;
        -: 3293:		using megaohm = megaohms;
        -: 3294:		using gigaohm = gigaohms;
        -: 3295:		/** @} */
        -: 3296:
        -: 3297:		/**
        -: 3298:		 * @name Unit Containers
        -: 3299:		 * @anchor impedanceContainers
        -: 3300:		 * @{
        -: 3301:		 */
        -: 3302:		using ohm_t = unit_t<ohm>;
        -: 3303:		using picoohm_t = unit_t<picoohm>;
        -: 3304:		using nanoohm_t = unit_t<nanoohm>;
        -: 3305:		using microohm_t = unit_t<microohm>;
        -: 3306:		using milliohm_t = unit_t<milliohm>;
        -: 3307:		using kiloohm_t = unit_t<kiloohm>;
        -: 3308:		using megaohm_t = unit_t<megaohm>;
        -: 3309:		using gigaohm_t = unit_t<gigaohm>;
        -: 3310:		/** @} */
        -: 3311:
        -: 3312:		/**
        -: 3313:		 * @name  Units (abbreviated names)
        -: 3314:		 * @{
        -: 3315:		 */
        -: 3316:		using Ohm = ohms;
        -: 3317:		using pOhm = picoohms;
        -: 3318:		using nOhm = nanoohms;
        -: 3319:		using uOhm = microohms;
        -: 3320:		using mOhm = milliohms;
        -: 3321:		using kOhm = kiloohms;
        -: 3322:		using MOhm = megaohms;
        -: 3323:		using GOhm = gigaohms;
        -: 3324:		/** @} */
        -: 3325:	}
        -: 3326:
        -: 3327:	namespace detail
        -: 3328:	{
        -: 3329:		template<typename T> struct is_impedance_unit_impl : std::false_type {};
        -: 3330:		template<typename C, typename U, typename P, typename T>
        -: 3331:		struct is_impedance_unit_impl<unit<C, U, P, T>> : std::is_same<base_unit_of<typename unit_traits<unit<C, U, P, T>>::base_unit_type>, category::impedance_unit>::type {};
        -: 3332:		template<typename U, typename S, template<typename> class N>
        -: 3333:		struct is_impedance_unit_impl<unit_t<U, S, N>> : std::is_same<base_unit_of<typename unit_t_traits<unit_t<U, S, N>>::unit_type>, category::impedance_unit>::type {};
        -: 3334:	}
        -: 3335:
        -: 3336:	/**
        -: 3337:	 * @ingroup		TypeTraits
        -: 3338:	 * @brief		Trait which tests whether a type represents a unit of impedance
        -: 3339:	 * @details		Inherits from `std::true_type` or `std::false_type`. Use `is_impedance_unit<T>::value` to test
        -: 3340:	 *				the unit represents a impedance quantity.
        -: 3341:	 * @tparam		T	one or more types to test
        -: 3342:	 */
        -: 3343:	template<typename... T> struct is_impedance_unit : std::integral_constant<bool, all_true<detail::is_impedance_unit_impl<typename std::decay<T>::type>::value...>::value> {};
        -: 3344:
        -: 3345:	//------------------------------
        -: 3346:	//	UNITS OF CONDUCTANCE
        -: 3347:	//------------------------------
        -: 3348:
        -: 3349:	/**
        -: 3350:	 * @brief		namespace for unit types and containers representing conductance values
        -: 3351:	 * @details		The SI unit for conductance is `siemens`, and the corresponding `base_unit` category is
        -: 3352:	 *				`conductance_unit`.
        -: 3353:	 * @sa			See unit_t for more information on unit type containers.
        -: 3354:	 */
        -: 3355:	namespace conductance
        -: 3356:	{
        -: 3357:		/**
        -: 3358:		 * @name Units (full names plural)
        -: 3359:		 * @{
        -: 3360:		 */
        -: 3361:		using siemens = unit<std::ratio<1>, category::conductance_unit>;
        -: 3362:		using picosiemens = pico<siemens>;
        -: 3363:		using nanosiemens = nano<siemens>;
        -: 3364:		using microsiemens = micro<siemens>;
        -: 3365:		using millisiemens = milli<siemens>;
        -: 3366:		using kilosiemens = kilo<siemens>;
        -: 3367:		using megasiemens = mega<siemens>;
        -: 3368:		using gigasiemens = giga<siemens>;
        -: 3369:		/** @} */
        -: 3370:
        -: 3371:		/**
        -: 3372:		 * @name Units (full names singular)
        -: 3373:		 * @{
        -: 3374:		 */
        -: 3375:		using siemen = siemens;
        -: 3376:		using picosiemen = picosiemens;
        -: 3377:		using nanosiemen = nanosiemens;
        -: 3378:		using microsiemen = microsiemens;
        -: 3379:		using millisiemen = millisiemens;
        -: 3380:		using kilosiemen = kilosiemens;
        -: 3381:		using megasiemen = megasiemens;
        -: 3382:		using gigasiemen = gigasiemens;
        -: 3383:		/** @} */
        -: 3384:
        -: 3385:		/**
        -: 3386:		 * @name Unit Containers
        -: 3387:		 * @anchor conductanceContainers
        -: 3388:		 * @{
        -: 3389:		 */
        -: 3390:		using siemen_t = unit_t<siemen>;
        -: 3391:		using picosiemen_t = unit_t<picosiemen>;
        -: 3392:		using nanosiemen_t = unit_t<nanosiemen>;
        -: 3393:		using microsiemen_t = unit_t<microsiemen>;
        -: 3394:		using millisiemen_t = unit_t<millisiemen>;
        -: 3395:		using kilosiemen_t = unit_t<kilosiemen>;
        -: 3396:		using megasiemen_t = unit_t<megasiemen>;
        -: 3397:		using gigasiemen_t = unit_t<gigasiemen>;
        -: 3398:		/** @} */
        -: 3399:
        -: 3400:		/**
        -: 3401:		 * @name  Units (abbreviated names)
        -: 3402:		 * @{
        -: 3403:		 */
        -: 3404:		using S = siemens;
        -: 3405:		using pS = picosiemens;
        -: 3406:		using nS = nanosiemens;
        -: 3407:		using uS = microsiemens;
        -: 3408:		using mS = millisiemens;
        -: 3409:		using kS = kilosiemens;
        -: 3410:		using MS = megasiemens;
        -: 3411:		using GS = gigasiemens;
        -: 3412:		/** @} */
        -: 3413:	}
        -: 3414:
        -: 3415:	namespace detail
        -: 3416:	{
        -: 3417:		template<typename T> struct is_conductance_unit_impl : std::false_type {};
        -: 3418:		template<typename C, typename U, typename P, typename T>
        -: 3419:		struct is_conductance_unit_impl<unit<C, U, P, T>> : std::is_same<base_unit_of<typename unit_traits<unit<C, U, P, T>>::base_unit_type>, category::conductance_unit>::type {};
        -: 3420:		template<typename U, typename S, template<typename> class N>
        -: 3421:		struct is_conductance_unit_impl<unit_t<U, S, N>> : std::is_same<base_unit_of<typename unit_t_traits<unit_t<U, S, N>>::unit_type>, category::conductance_unit>::type {};
        -: 3422:	}
        -: 3423:
        -: 3424:	/**
        -: 3425:	 * @ingroup		TypeTraits
        -: 3426:	 * @brief		Trait which tests whether a type represents a unit of conductance
        -: 3427:	 * @details		Inherits from `std::true_type` or `std::false_type`. Use `is_conductance_unit<T>::value` to test
        -: 3428:	 *				the unit represents a conductance quantity.
        -: 3429:	 * @tparam		T	one or more types to test
        -: 3430:	 */
        -: 3431:	template<typename... T> struct is_conductance_unit : std::integral_constant<bool, all_true<detail::is_conductance_unit_impl<typename std::decay<T>::type>::value...>::value> {};
        -: 3432:
        -: 3433:	//------------------------------
        -: 3434:	//	UNITS OF MAGNETIC FLUX
        -: 3435:	//------------------------------
        -: 3436:
        -: 3437:	/**
        -: 3438:	 * @brief		namespace for unit types and containers representing magnetic_flux values
        -: 3439:	 * @details		The SI unit for magnetic_flux is `webers`, and the corresponding `base_unit` category is
        -: 3440:	 *				`magnetic_flux_unit`.
        -: 3441:	 * @sa			See unit_t for more information on unit type containers.
        -: 3442:	 */
        -: 3443:	namespace magnetic_flux
        -: 3444:	{
        -: 3445:		/**
        -: 3446:		 * @name Units (full names plural)
        -: 3447:		 * @{
        -: 3448:		 */
        -: 3449:		using webers = unit<std::ratio<1>, category::magnetic_flux_unit>;
        -: 3450:		using picowebers = pico<webers>;
        -: 3451:		using nanowebers = nano<webers>;
        -: 3452:		using microwebers = micro<webers>;
        -: 3453:		using milliwebers = milli<webers>;
        -: 3454:		using kilowebers = kilo<webers>;
        -: 3455:		using megawebers = mega<webers>;
        -: 3456:		using gigawebers = giga<webers>;
        -: 3457:		using maxwells = unit<std::ratio<1, 100000000>, webers>;
        -: 3458:		/** @} */
        -: 3459:
        -: 3460:		/**
        -: 3461:		 * @name Units (full names singular)
        -: 3462:		 * @{
        -: 3463:		 */
        -: 3464:		using weber = webers;
        -: 3465:		using picoweber = picowebers;
        -: 3466:		using nanoweber = nanowebers;
        -: 3467:		using microweber = microwebers;
        -: 3468:		using milliweber = milliwebers;
        -: 3469:		using kiloweber = kilowebers;
        -: 3470:		using megaweber = megawebers;
        -: 3471:		using gigaweber = gigawebers;
        -: 3472:		using maxwell = maxwells;
        -: 3473:		/** @} */
        -: 3474:
        -: 3475:		/**
        -: 3476:		 * @name Unit Containers
        -: 3477:		 * @anchor magneticFluxContainers
        -: 3478:		 * @{
        -: 3479:		 */
        -: 3480:		using weber_t = unit_t<weber>;
        -: 3481:		using picoweber_t = unit_t<picoweber>;
        -: 3482:		using nanoweber_t = unit_t<nanoweber>;
        -: 3483:		using microweber_t = unit_t<microweber>;
        -: 3484:		using milliweber_t = unit_t<milliweber>;
        -: 3485:		using kiloweber_t = unit_t<kiloweber>;
        -: 3486:		using megaweber_t = unit_t<megaweber>;
        -: 3487:		using gigaweber_t = unit_t<gigaweber>;
        -: 3488:		using maxwell_t = unit_t<maxwell>;
        -: 3489:		/** @} */
        -: 3490:
        -: 3491:		/**
        -: 3492:		 * @name  Units (abbreviated names)
        -: 3493:		 * @{
        -: 3494:		 */
        -: 3495:		using Wb = webers;
        -: 3496:		using pWb = picowebers;
        -: 3497:		using nWb = nanowebers;
        -: 3498:		using uWb = microwebers;
        -: 3499:		using mWb = milliwebers;
        -: 3500:		using kWb = kilowebers;
        -: 3501:		using MWb = megawebers;
        -: 3502:		using GWb = gigawebers;
        -: 3503:		using Mx = maxwells;
        -: 3504:		/** @} */
        -: 3505:	}
        -: 3506:
        -: 3507:	namespace detail
        -: 3508:	{
        -: 3509:		template<typename T> struct is_magnetic_flux_unit_impl : std::false_type {};
        -: 3510:		template<typename C, typename U, typename P, typename T>
        -: 3511:		struct is_magnetic_flux_unit_impl<unit<C, U, P, T>> : std::is_same<base_unit_of<typename unit_traits<unit<C, U, P, T>>::base_unit_type>, category::magnetic_flux_unit>::type {};
        -: 3512:		template<typename U, typename S, template<typename> class N>
        -: 3513:		struct is_magnetic_flux_unit_impl<unit_t<U, S, N>> : std::is_same<base_unit_of<typename unit_t_traits<unit_t<U, S, N>>::unit_type>, category::magnetic_flux_unit>::type {};
        -: 3514:	}
        -: 3515:
        -: 3516:	/**
        -: 3517:	 * @ingroup		TypeTraits
        -: 3518:	 * @brief		Trait which tests whether a type represents a unit of magnetic_flux
        -: 3519:	 * @details		Inherits from `std::true_type` or `std::false_type`. Use `is_magnetic_flux_unit<T>::value` to test
        -: 3520:	 *				the unit represents a magnetic_flux quantity.
        -: 3521:	 * @tparam		T	one or more types to test
        -: 3522:	 */
        -: 3523:	template<typename... T> struct is_magnetic_flux_unit : std::integral_constant<bool, all_true<detail::is_magnetic_flux_unit_impl<typename std::decay<T>::type>::value...>::value> {};
        -: 3524:
        -: 3525:	//----------------------------------------
        -: 3526:	//	UNITS OF MAGNETIC FIELD STRENGTH
        -: 3527:	//----------------------------------------
        -: 3528:
        -: 3529:	/**
        -: 3530:	 * @brief		namespace for unit types and containers representing magnetic_field_strength values
        -: 3531:	 * @details		The SI unit for magnetic_field_strength is `teslas`, and the corresponding `base_unit` category is
        -: 3532:	 *				`magnetic_field_strength_unit`.
        -: 3533:	 * @sa			See unit_t for more information on unit type containers.
        -: 3534:	 */
        -: 3535:	namespace magnetic_field_strength
        -: 3536:	{
        -: 3537:		/**
        -: 3538:		 * @name Units (full names plural)
        -: 3539:		 * @{
        -: 3540:		 */
        -: 3541:		using teslas = unit<std::ratio<1>, category::magnetic_field_strength_unit>;
        -: 3542:		using picoteslas = pico<teslas>;
        -: 3543:		using nanoteslas = nano<teslas>;
        -: 3544:		using microteslas = micro<teslas>;
        -: 3545:		using milliteslas = milli<teslas>;
        -: 3546:		using kiloteslas = kilo<teslas>;
        -: 3547:		using megateslas = mega<teslas>;
        -: 3548:		using gigateslas = giga<teslas>;
        -: 3549:		using gauss = compound_unit<magnetic_flux::maxwell, inverse<squared<length::centimeter>>>;
        -: 3550:		/** @} */
        -: 3551:
        -: 3552:		/**
        -: 3553:		 * @name Units (full names singular)
        -: 3554:		 * @{
        -: 3555:		 */
        -: 3556:		using tesla = teslas;
        -: 3557:		using picotesla = picoteslas;
        -: 3558:		using nanotesla = nanoteslas;
        -: 3559:		using microtesla = microteslas;
        -: 3560:		using millitesla = milliteslas;
        -: 3561:		using kilotesla = kiloteslas;
        -: 3562:		using megatesla = megateslas;
        -: 3563:		using gigatesla = gigateslas;
        -: 3564:		/** @} */
        -: 3565:
        -: 3566:		/**
        -: 3567:		 * @name Unit Containers
        -: 3568:		 * @anchor magneticFieldStrengthContainers
        -: 3569:		 * @{
        -: 3570:		 */
        -: 3571:		using tesla_t = unit_t<tesla>;
        -: 3572:		using picotesla_t = unit_t<picotesla>;
        -: 3573:		using nanotesla_t = unit_t<nanotesla>;
        -: 3574:		using microtesla_t = unit_t<microtesla>;
        -: 3575:		using millitesla_t = unit_t<millitesla>;
        -: 3576:		using kilotesla_t = unit_t<kilotesla>;
        -: 3577:		using megatesla_t = unit_t<megatesla>;
        -: 3578:		using gigatesla_t = unit_t<gigatesla>;
        -: 3579:		using gauss_t = unit_t<gauss>;
        -: 3580:		/** @} */
        -: 3581:
        -: 3582:		/**
        -: 3583:		 * @name Units (abbreviated names)
        -: 3584:		 * @{
        -: 3585:		 */
        -: 3586:		using T = teslas;
        -: 3587:		using pT = picoteslas;
        -: 3588:		using nT = nanoteslas;
        -: 3589:		using uT = microteslas;
        -: 3590:		using mT = milliteslas;
        -: 3591:		using kT = kiloteslas;
        -: 3592:		using MT = megateslas;
        -: 3593:		using GT = gigateslas;
        -: 3594:		using G = gauss;
        -: 3595:		/** @} */
        -: 3596:	}
        -: 3597:
        -: 3598:	namespace detail
        -: 3599:	{
        -: 3600:		template<typename T> struct is_magnetic_field_strength_unit_impl : std::false_type {};
        -: 3601:		template<typename C, typename U, typename P, typename T>
        -: 3602:		struct is_magnetic_field_strength_unit_impl<unit<C, U, P, T>> : std::is_same<base_unit_of<typename unit_traits<unit<C, U, P, T>>::base_unit_type>, category::magnetic_field_strength_unit>::type {};
        -: 3603:		template<typename U, typename S, template<typename> class N>
        -: 3604:		struct is_magnetic_field_strength_unit_impl<unit_t<U, S, N>> : std::is_same<base_unit_of<typename unit_t_traits<unit_t<U, S, N>>::unit_type>, category::magnetic_field_strength_unit>::type {};
        -: 3605:	}
        -: 3606:
        -: 3607:	/**
        -: 3608:	 * @ingroup		TypeTraits
        -: 3609:	 * @brief		Trait which tests whether a type represents a unit of magnetic_field_strength
        -: 3610:	 * @details		Inherits from `std::true_type` or `std::false_type`. Use `is_magnetic_field_strength_unit<T>::value` to test
        -: 3611:	 *				the unit represents a magnetic_field_strength quantity.
        -: 3612:	 * @tparam		T	one or more types to test
        -: 3613:	 */
        -: 3614:	template<typename... T> struct is_magnetic_field_strength_unit : std::integral_constant<bool, all_true<detail::is_magnetic_field_strength_unit_impl<typename std::decay<T>::type>::value...>::value> {};
        -: 3615:
        -: 3616:	//------------------------------
        -: 3617:	//	UNITS OF INDUCTANCE
        -: 3618:	//------------------------------
        -: 3619:
        -: 3620:	/**
        -: 3621:	 * @brief		namespace for unit types and containers representing inductance values
        -: 3622:	 * @details		The SI unit for inductance is `henrys`, and the corresponding `base_unit` category is
        -: 3623:	 *				`inductance_unit`.
        -: 3624:	 * @sa			See unit_t for more information on unit type containers.
        -: 3625:	 */
        -: 3626:	namespace inductance
        -: 3627:	{
        -: 3628:		/**
        -: 3629:		 * @name Units (full names plural)
        -: 3630:		 * @{
        -: 3631:		 */
        -: 3632:		using henrys = unit<std::ratio<1>, category::inductance_unit>;
        -: 3633:		using picohenrys = pico<henrys>;
        -: 3634:		using nanohenrys = nano<henrys>;
        -: 3635:		using microhenrys = micro<henrys>;
        -: 3636:		using millihenrys = milli<henrys>;
        -: 3637:		using kilohenrys = kilo<henrys>;
        -: 3638:		using megahenrys = mega<henrys>;
        -: 3639:		using gigahenrys = giga<henrys>;
        -: 3640:		/** @} */
        -: 3641:
        -: 3642:		/**
        -: 3643:		 * @name Units (full names singular)
        -: 3644:		 * @{
        -: 3645:		 */
        -: 3646:		using henry = henrys;
        -: 3647:		using picohenry = picohenrys;
        -: 3648:		using nanohenry = nanohenrys;
        -: 3649:		using microhenry = microhenrys;
        -: 3650:		using millihenry = millihenrys;
        -: 3651:		using kilohenry = kilohenrys;
        -: 3652:		using megahenry = megahenrys;
        -: 3653:		using gigahenry = gigahenrys;
        -: 3654:		/** @} */
        -: 3655:
        -: 3656:		/**
        -: 3657:		 * @name Units (alternate spellings)
        -: 3658:		 * @{
        -: 3659:		 */
        -: 3660:		using henries = henrys;
        -: 3661:		using picohenries = picohenrys;
        -: 3662:		using nanohenries = nanohenrys;
        -: 3663:		using microhenries = microhenrys;
        -: 3664:		using millihenries = millihenrys;
        -: 3665:		using kilohenries = kilohenrys;
        -: 3666:		using megahenries = megahenrys;
        -: 3667:		using gigahenries = gigahenrys;
        -: 3668:		/** @} */
        -: 3669:
        -: 3670:		/**
        -: 3671:		 * @name Unit Containers
        -: 3672:		 * @anchor inductanceContainers
        -: 3673:		 * @{
        -: 3674:		 */
        -: 3675:		using henry_t = unit_t<henry>;
        -: 3676:		using picohenry_t = unit_t<picohenry>;
        -: 3677:		using nanohenry_t = unit_t<nanohenry>;
        -: 3678:		using microhenry_t = unit_t<microhenry>;
        -: 3679:		using millihenry_t = unit_t<millihenry>;
        -: 3680:		using kilohenry_t = unit_t<kilohenry>;
        -: 3681:		using megahenry_t = unit_t<megahenry>;
        -: 3682:		using gigahenry_t = unit_t<gigahenry>;
        -: 3683:		/** @} */
        -: 3684:
        -: 3685:		/**
        -: 3686:		 * @name Units (abbreviated names)
        -: 3687:		 * @{
        -: 3688:		 */
        -: 3689:		using H = henrys;
        -: 3690:		using pH = picohenrys;
        -: 3691:		using nH = nanohenrys;
        -: 3692:		using uH = microhenrys;
        -: 3693:		using mH = millihenrys;
        -: 3694:		using kH = kilohenrys;
        -: 3695:		using MH = megahenrys;
        -: 3696:		using GH = gigahenrys;
        -: 3697:		/** @} */
        -: 3698:	}
        -: 3699:
        -: 3700:	namespace detail
        -: 3701:	{
        -: 3702:		template<typename T> struct is_inductance_unit_impl : std::false_type {};
        -: 3703:		template<typename C, typename U, typename P, typename T>
        -: 3704:		struct is_inductance_unit_impl<unit<C, U, P, T>> : std::is_same<base_unit_of<typename unit_traits<unit<C, U, P, T>>::base_unit_type>, category::inductance_unit>::type {};
        -: 3705:		template<typename U, typename S, template<typename> class N>
        -: 3706:		struct is_inductance_unit_impl<unit_t<U, S, N>> : std::is_same<base_unit_of<typename unit_t_traits<unit_t<U, S, N>>::unit_type>, category::inductance_unit>::type {};
        -: 3707:	}
        -: 3708:
        -: 3709:	/**
        -: 3710:	 * @ingroup		TypeTraits
        -: 3711:	 * @brief		Trait which tests whether a type represents a unit of inductance
        -: 3712:	 * @details		Inherits from `std::true_type` or `std::false_type`. Use `is_inductance_unit<T>::value` to test
        -: 3713:	 *				the unit represents a inductance quantity.
        -: 3714:	 * @tparam		T	one or more types to test
        -: 3715:	 */
        -: 3716:	template<typename... T> struct is_inductance_unit : std::integral_constant<bool, all_true<detail::is_inductance_unit_impl<typename std::decay<T>::type>::value...>::value> {};
        -: 3717:
        -: 3718:	//------------------------------
        -: 3719:	//	UNITS OF LUMINOUS FLUX
        -: 3720:	//------------------------------
        -: 3721:
        -: 3722:	/**
        -: 3723:	 * @brief		namespace for unit types and containers representing luminous_flux values
        -: 3724:	 * @details		The SI unit for luminous_flux is `lumens`, and the corresponding `base_unit` category is
        -: 3725:	 *				`luminous_flux_unit`.
        -: 3726:	 * @sa			See unit_t for more information on unit type containers.
        -: 3727:	 */
        -: 3728:	namespace luminous_flux
        -: 3729:	{
        -: 3730:		/**
        -: 3731:		 * @name Units (full names plural)
        -: 3732:		 * @{
        -: 3733:		 */
        -: 3734:		using lumens = unit<std::ratio<1>, category::luminous_flux_unit>;
        -: 3735:		using picolumens = pico<lumens>;
        -: 3736:		using nanolumens = nano<lumens>;
        -: 3737:		using microlumens = micro<lumens>;
        -: 3738:		using millilumens = milli<lumens>;
        -: 3739:		using kilolumens = kilo<lumens>;
        -: 3740:		using megalumens = mega<lumens>;
        -: 3741:		using gigalumens = giga<lumens>;
        -: 3742:		/** @} */
        -: 3743:
        -: 3744:		/**
        -: 3745:		 * @name Units (full names singular)
        -: 3746:		 * @{
        -: 3747:		 */
        -: 3748:		using lumen = lumens;
        -: 3749:		using picolumen = picolumens;
        -: 3750:		using nanolumen = nanolumens;
        -: 3751:		using microlumen = microlumens;
        -: 3752:		using millilumen = millilumens;
        -: 3753:		using kilolumen = kilolumens;
        -: 3754:		using megalumen = megalumens;
        -: 3755:		using gigalumen = gigalumens;
        -: 3756:		/** @} */
        -: 3757:
        -: 3758:		/**
        -: 3759:		 * @name Unit Containers
        -: 3760:		 * @anchor luminousFluxContainers
        -: 3761:		 * @{
        -: 3762:		 */
        -: 3763:		using lumen_t = unit_t<lumen>;
        -: 3764:		using picolumen_t = unit_t<picolumen>;
        -: 3765:		using nanolumen_t = unit_t<nanolumen>;
        -: 3766:		using microlumen_t = unit_t<microlumen>;
        -: 3767:		using millilumen_t = unit_t<millilumen>;
        -: 3768:		using kilolumen_t = unit_t<kilolumen>;
        -: 3769:		using megalumen_t = unit_t<megalumen>;
        -: 3770:		using gigalumen_t = unit_t<gigalumen>;
        -: 3771:		/** @} */
        -: 3772:
        -: 3773:		/**
        -: 3774:		 * @name Units (abbreviated names)
        -: 3775:		 * @{
        -: 3776:		 */
        -: 3777:		using lm = lumens;
        -: 3778:		using plm = picolumens;
        -: 3779:		using nlm = nanolumens;
        -: 3780:		using ulm = microlumens;
        -: 3781:		using mlm = millilumens;
        -: 3782:		using klm = kilolumens;
        -: 3783:		using Mlm = megalumens;
        -: 3784:		using Glm = gigalumens;
        -: 3785:		/** @} */
        -: 3786:	}
        -: 3787:
        -: 3788:	namespace detail
        -: 3789:	{
        -: 3790:		template<typename T> struct is_luminous_flux_unit_impl : std::false_type {};
        -: 3791:		template<typename C, typename U, typename P, typename T>
        -: 3792:		struct is_luminous_flux_unit_impl<unit<C, U, P, T>> : std::is_same<base_unit_of<typename unit_traits<unit<C, U, P, T>>::base_unit_type>, category::luminous_flux_unit>::type {};
        -: 3793:		template<typename U, typename S, template<typename> class N>
        -: 3794:		struct is_luminous_flux_unit_impl<unit_t<U, S, N>> : std::is_same<base_unit_of<typename unit_t_traits<unit_t<U, S, N>>::unit_type>, category::luminous_flux_unit>::type {};
        -: 3795:	}
        -: 3796:
        -: 3797:	/**
        -: 3798:	 * @ingroup		TypeTraits
        -: 3799:	 * @brief		Trait which tests whether a type represents a unit of luminous_flux
        -: 3800:	 * @details		Inherits from `std::true_type` or `std::false_type`. Use `is_luminous_flux_unit<T>::value` to test
        -: 3801:	 *				the unit represents a luminous_flux quantity.
        -: 3802:	 * @tparam		T	one or more types to test
        -: 3803:	 */
        -: 3804:	template<typename... T> struct is_luminous_flux_unit : std::integral_constant<bool, all_true<detail::is_luminous_flux_unit_impl<typename std::decay<T>::type>::value...>::value> {};
        -: 3805:
        -: 3806:	//------------------------------
        -: 3807:	//	UNITS OF ILLUMINANCE
        -: 3808:	//------------------------------
        -: 3809:
        -: 3810:	/**
        -: 3811:	 * @brief		namespace for unit types and containers representing illuminance values
        -: 3812:	 * @details		The SI unit for illuminance is `luxes`, and the corresponding `base_unit` category is
        -: 3813:	 *				`illuminance_unit`.
        -: 3814:	 * @sa			See unit_t for more information on unit type containers.
        -: 3815:	 */
        -: 3816:	namespace illuminance
        -: 3817:	{
        -: 3818:		/**
        -: 3819:		 * @name Units (full names plural)
        -: 3820:		 * @{
        -: 3821:		 */
        -: 3822:		using luxes = unit<std::ratio<1>, category::illuminance_unit>;
        -: 3823:		using picoluxes = pico<luxes>;
        -: 3824:		using nanoluxes = nano<luxes>;
        -: 3825:		using microluxes = micro<luxes>;
        -: 3826:		using milliluxes = milli<luxes>;
        -: 3827:		using kiloluxes = kilo<luxes>;
        -: 3828:		using megaluxes = mega<luxes>;
        -: 3829:		using gigaluxes = giga<luxes>;
        -: 3830:		using footcandles = compound_unit<luminous_flux::lumen, inverse<squared<length::foot>>>;
        -: 3831:		using lumens_per_square_inch = compound_unit<luminous_flux::lumen, inverse<squared<length::inch>>>;
        -: 3832:		using phots = compound_unit<luminous_flux::lumens, inverse<squared<length::centimeter>>>;
        -: 3833:		/** @} */
        -: 3834:
        -: 3835:		/**
        -: 3836:		 * @name  Units (full names singular)
        -: 3837:		 * @{
        -: 3838:		 */
        -: 3839:		using lux = luxes;
        -: 3840:		using picolux = picoluxes;
        -: 3841:		using nanolux = nanoluxes;
        -: 3842:		using microlux = microluxes;
        -: 3843:		using millilux = milliluxes;
        -: 3844:		using kilolux = kiloluxes;
        -: 3845:		using megalux = megaluxes;
        -: 3846:		using gigalux = gigaluxes;
        -: 3847:		using footcandle = footcandles;
        -: 3848:		using phot = phots;
        -: 3849:		/** @} */
        -: 3850:
        -: 3851:		/**
        -: 3852:		 * @name Unit Containers
        -: 3853:		 * @anchor illuminanceContainers
        -: 3854:		 * @{
        -: 3855:		 */
        -: 3856:		using lux_t = unit_t<lux>;
        -: 3857:		using picolux_t = unit_t<picolux>;
        -: 3858:		using nanolux_t = unit_t<nanolux>;
        -: 3859:		using microlux_t = unit_t<microlux>;
        -: 3860:		using millilux_t = unit_t<millilux>;
        -: 3861:		using kilolux_t = unit_t<kilolux>;
        -: 3862:		using megalux_t = unit_t<megalux>;
        -: 3863:		using gigalux_t = unit_t<gigalux>;
        -: 3864:		using footcandle_t = unit_t<footcandle>;
        -: 3865:		using lumens_per_square_inch_t = unit_t<lumens_per_square_inch>;
        -: 3866:		using phot_t = unit_t<phot>;
        -: 3867:		/** @} */
        -: 3868:
        -: 3869:		/**
        -: 3870:		 * @name Units (abbreviated names)
        -: 3871:		 * @{
        -: 3872:		 */
        -: 3873:		using lx = luxes;
        -: 3874:		using plx = picoluxes;
        -: 3875:		using nlx = nanoluxes;
        -: 3876:		using ulx = microluxes;
        -: 3877:		using mlx = milliluxes;
        -: 3878:		using klx = kiloluxes;
        -: 3879:		using Mlx = megaluxes;
        -: 3880:		using Glx = gigaluxes;
        -: 3881:		using fc = footcandles;
        -: 3882:		using ph = phots;
        -: 3883:		/** @} */
        -: 3884:	}
        -: 3885:
        -: 3886:	namespace detail
        -: 3887:	{
        -: 3888:		template<typename T> struct is_illuminance_unit_impl : std::false_type {};
        -: 3889:		template<typename C, typename U, typename P, typename T>
        -: 3890:		struct is_illuminance_unit_impl<unit<C, U, P, T>> : std::is_same<base_unit_of<typename unit_traits<unit<C, U, P, T>>::base_unit_type>, category::illuminance_unit>::type {};
        -: 3891:		template<typename U, typename S, template<typename> class N>
        -: 3892:		struct is_illuminance_unit_impl<unit_t<U, S, N>> : std::is_same<base_unit_of<typename unit_t_traits<unit_t<U, S, N>>::unit_type>, category::illuminance_unit>::type {};
        -: 3893:	}
        -: 3894:
        -: 3895:	/**
        -: 3896:	 * @ingroup		TypeTraits
        -: 3897:	 * @brief		Trait which tests whether a type represents a unit of illuminance
        -: 3898:	 * @details		Inherits from `std::true_type` or `std::false_type`. Use `is_illuminance_unit<T>::value` to test
        -: 3899:	 *				the unit represents a illuminance quantity.
        -: 3900:	 * @tparam		T	one or more types to test
        -: 3901:	 */
        -: 3902:	template<typename... T> struct is_illuminance_unit : std::integral_constant<bool, all_true<detail::is_illuminance_unit_impl<typename std::decay<T>::type>::value...>::value> {};
        -: 3903:
        -: 3904:	//------------------------------
        -: 3905:	//	UNITS OF RADIATION
        -: 3906:	//------------------------------
        -: 3907:
        -: 3908:	/**
        -: 3909:	 * @brief		namespace for unit types and containers representing radiation values
        -: 3910:	 * @details		The SI units for radiation are:
        -: 3911:	 *				- source activity:	becquerel
        -: 3912:	 *				- absorbed dose:	gray
        -: 3913:	 *				- equivalent dose:	sievert
        -: 3914:	 * @sa			See unit_t for more information on unit type containers.
        -: 3915:	 */
        -: 3916:	namespace radiation
        -: 3917:	{
        -: 3918:		/**
        -: 3919:		 * @name Units (full names plural)
        -: 3920:		 * @{
        -: 3921:		 */
        -: 3922:		using becquerels = inverse<time::seconds>;
        -: 3923:		using picobecquerels = pico<becquerels>;
        -: 3924:		using nanobecquerels = nano<becquerels>;
        -: 3925:		using microbecquerels = micro<becquerels>;
        -: 3926:		using millibecquerels = milli<becquerels>;
        -: 3927:		using kilobecquerels = kilo<becquerels>;
        -: 3928:		using megabecquerels = mega<becquerels>;
        -: 3929:		using gigabecquerels = giga<becquerels>;
        -: 3930:		using grays = compound_unit<energy::joules, inverse<mass::kilogram>>;
        -: 3931:		using picograys = pico<grays>;
        -: 3932:		using nanograys = nano<grays>;
        -: 3933:		using micrograys = micro<grays>;
        -: 3934:		using milligrays = milli<grays>;
        -: 3935:		using kilograys = kilo<grays>;
        -: 3936:		using megagrays = mega<grays>;
        -: 3937:		using gigagrays = giga<grays>;
        -: 3938:		using sieverts = compound_unit<energy::joules, inverse<mass::kilogram>>;
        -: 3939:		using picosieverts = pico<sieverts>;
        -: 3940:		using nanosieverts = nano<sieverts>;
        -: 3941:		using microsieverts = micro<sieverts>;
        -: 3942:		using millisieverts = milli<sieverts>;
        -: 3943:		using kilosieverts = kilo<sieverts>;
        -: 3944:		using megasieverts = mega<sieverts>;
        -: 3945:		using gigasieverts = giga<sieverts>;
        -: 3946:		using curies = unit<std::ratio<37>, gigabecquerels>;
        -: 3947:		using rutherfords = megabecquerels;
        -: 3948:		using rads = unit<std::ratio<1, 100>, grays>;
        -: 3949:		/** @} */
        -: 3950:
        -: 3951:		/**
        -: 3952:		 * @name Units (full names singular)
        -: 3953:		 * @{
        -: 3954:		 */
        -: 3955:		using becquerel = becquerels;
        -: 3956:		using picobecquerel = picobecquerels;
        -: 3957:		using nanobecquerel = nanobecquerels;
        -: 3958:		using microbecquerel = microbecquerels;
        -: 3959:		using millibecquerel = millibecquerels;
        -: 3960:		using kilobecquerel = kilobecquerels;
        -: 3961:		using megabecquerel = megabecquerels;
        -: 3962:		using gigabecquerel = gigabecquerels;
        -: 3963:		using gray = grays;
        -: 3964:		using picogray = picograys;
        -: 3965:		using nanogray = nanograys;
        -: 3966:		using microgray = micrograys;
        -: 3967:		using milligray = milligrays;
        -: 3968:		using kilogray = kilograys;
        -: 3969:		using megagray = megagrays;
        -: 3970:		using gigagray = gigagrays;
        -: 3971:		using sievert = sieverts;
        -: 3972:		using picosievert = picosieverts;
        -: 3973:		using nanosievert = nanosieverts;
        -: 3974:		using microsievert = microsieverts;
        -: 3975:		using millisievert = millisieverts;
        -: 3976:		using kilosievert = kilosieverts;
        -: 3977:		using megasievert = megasieverts;
        -: 3978:		using gigasievert = gigasieverts;
        -: 3979:		using curie = curies;
        -: 3980:		using rutherford = rutherfords;
        -: 3981:		using rad = rads;
        -: 3982:		/** @} */
        -: 3983:
        -: 3984:		/**
        -: 3985:		 * @name Unit Containers
        -: 3986:		 * @anchor radiationContainers
        -: 3987:		 * @{
        -: 3988:		 */
        -: 3989:		using becquerel_t = unit_t<becquerel>;
        -: 3990:		using picobecquerel_t = unit_t<picobecquerel>;
        -: 3991:		using nanobecquerel_t = unit_t<nanobecquerel>;
        -: 3992:		using microbecquerel_t = unit_t<microbecquerel>;
        -: 3993:		using millibecquerel_t = unit_t<millibecquerel>;
        -: 3994:		using kilobecquerel_t = unit_t<kilobecquerel>;
        -: 3995:		using megabecquerel_t = unit_t<megabecquerel>;
        -: 3996:		using gigabecquerel_t = unit_t<gigabecquerel>;
        -: 3997:		using gray_t = unit_t<gray>;
        -: 3998:		using picogray_t = unit_t<picogray>;
        -: 3999:		using nanogray_t = unit_t<nanogray>;
        -: 4000:		using microgray_t = unit_t<microgray>;
        -: 4001:		using milligray_t = unit_t<milligray>;
        -: 4002:		using kilogray_t = unit_t<kilogray>;
        -: 4003:		using megagray_t = unit_t<megagray>;
        -: 4004:		using gigagray_t = unit_t<gigagray>;
        -: 4005:		using sievert_t = unit_t<sievert>;
        -: 4006:		using picosievert_t = unit_t<picosievert>;
        -: 4007:		using nanosievert_t = unit_t<nanosievert>;
        -: 4008:		using microsievert_t = unit_t<microsievert>;
        -: 4009:		using millisievert_t = unit_t<millisievert>;
        -: 4010:		using kilosievert_t = unit_t<kilosievert>;
        -: 4011:		using megasievert_t = unit_t<megasievert>;
        -: 4012:		using gigasievert_t = unit_t<gigasievert>;
        -: 4013:		using curie_t = unit_t<curie>;
        -: 4014:		using rutherford_t = unit_t<rutherford>;
        -: 4015:		using rad_t = unit_t<rad>;
        -: 4016:		/** @} */
        -: 4017:
        -: 4018:		/**
        -: 4019:		 * @name  Units (abbreviated names)
        -: 4020:		 * @{
        -: 4021:		 */
        -: 4022:		using Bq = becquerels;
        -: 4023:		using pBq = picobecquerels;
        -: 4024:		using nBq = nanobecquerels;
        -: 4025:		using uBq = microbecquerels;
        -: 4026:		using mBq = millibecquerels;
        -: 4027:		using kBq = kilobecquerels;
        -: 4028:		using MBq = megabecquerels;
        -: 4029:		using GBq = gigabecquerels;
        -: 4030:		using Gy = grays;
        -: 4031:		using pGy = picograys;
        -: 4032:		using nGy = nanograys;
        -: 4033:		using uGy = micrograys;
        -: 4034:		using mGy = milligrays;
        -: 4035:		using kGy = kilograys;
        -: 4036:		using MGy = megagrays;
        -: 4037:		using GGy = gigagrays;
        -: 4038:		using Sv = sieverts;
        -: 4039:		using pSv = picosieverts;
        -: 4040:		using nSv = nanosieverts;
        -: 4041:		using uSv = microsieverts;
        -: 4042:		using mSv = millisieverts;
        -: 4043:		using kSv = kilosieverts;
        -: 4044:		using MSv = megasieverts;
        -: 4045:		using GSv = gigasieverts;
        -: 4046:		using Ci = curies;
        -: 4047:		using rd = rutherfords;
        -: 4048:		/** @} */
        -: 4049:	}
        -: 4050:
        -: 4051:	namespace detail
        -: 4052:	{
        -: 4053:		template<typename T> struct is_radioactivity_unit_impl : std::false_type {};
        -: 4054:		template<typename C, typename U, typename P, typename T>
        -: 4055:		struct is_radioactivity_unit_impl<unit<C, U, P, T>> : std::is_same<base_unit_of<typename unit_traits<unit<C, U, P, T>>::base_unit_type>, category::radioactivity_unit>::type {};
        -: 4056:		template<typename U, typename S, template<typename> class N>
        -: 4057:		struct is_radioactivity_unit_impl<unit_t<U, S, N>> : std::is_same<base_unit_of<typename unit_t_traits<unit_t<U, S, N>>::unit_type>, category::radioactivity_unit>::type {};
        -: 4058:	}
        -: 4059:
        -: 4060:	/**
        -: 4061:	 * @ingroup		TypeTraits
        -: 4062:	 * @brief		Trait which tests whether a type represents a unit of radiation
        -: 4063:	 * @details		Inherits from `std::true_type` or `std::false_type`. Use `is_radioactivity_unit<T>::value` to test
        -: 4064:	 *				the unit represents a radiation quantity.
        -: 4065:	 * @tparam		T	one or more types to test
        -: 4066:	 */
        -: 4067:	template<typename... T> struct is_radioactivity_unit : std::integral_constant<bool, all_true<detail::is_radioactivity_unit_impl<typename std::decay<T>::type>::value...>::value> {};
        -: 4068:
        -: 4069:	//------------------------------
        -: 4070:	//	UNITS OF TORQUE
        -: 4071:	//------------------------------
        -: 4072:
        -: 4073:	/**
        -: 4074:	 * @brief		namespace for unit types and containers representing torque values
        -: 4075:	 * @details		The SI unit for torque is `newton_meters`, and the corresponding `base_unit` category is
        -: 4076:	 *				`torque_units`.
        -: 4077:	 * @sa			See unit_t for more information on unit type containers.
        -: 4078:	 */
        -: 4079:	namespace torque
        -: 4080:	{
        -: 4081:		/**
        -: 4082:		 * @name Units (full names plural)
        -: 4083:		 * @{
        -: 4084:		 */
        -: 4085:		using newton_meters = unit<std::ratio<1>, category::torque_unit>;
        -: 4086:		using foot_pounds = compound_unit<length::foot, force::pounds>;
        -: 4087:		using foot_poundals = compound_unit<length::foot, force::poundal>;
        -: 4088:		using inch_pounds = compound_unit<length::inch, force::pounds>;
        -: 4089:		using meter_kilograms = compound_unit<length::meter, force::kiloponds>;
        -: 4090:		/** @} */
        -: 4091:
        -: 4092:		/**
        -: 4093:		 * @name Units (full names singular)
        -: 4094:		 * @{
        -: 4095:		 */
        -: 4096:		using newton_meter = newton_meters;
        -: 4097:		using foot_pound = foot_pounds;
        -: 4098:		using foot_poundal = foot_poundals;
        -: 4099:		using inch_pound = inch_pounds;
        -: 4100:		using meter_kilogram = meter_kilograms;
        -: 4101:		/** @} */
        -: 4102:
        -: 4103:		/**
        -: 4104:		 * @name Unit Containers
        -: 4105:		 * @anchor torqueContainers
        -: 4106:		 * @{
        -: 4107:		 */
        -: 4108:		using newton_meter_t = unit_t<newton_meter>;
        -: 4109:		using foot_pound_t = unit_t<foot_pound>;
        -: 4110:		using foot_poundal_t = unit_t<foot_poundal>;
        -: 4111:		using inch_pound_t = unit_t<inch_pound>;
        -: 4112:		using meter_kilogram_t = unit_t<meter_kilogram>;
        -: 4113:		/** @} */
        -: 4114:
        -: 4115:		/**
        -: 4116:		 * @name Units (abbreviated names)
        -: 4117:		 * @{
        -: 4118:		 */
        -: 4119:		using Nm = newton_meters;
        -: 4120:		using ftlbf = foot_pounds;
        -: 4121:		using ftpdl = foot_poundals;
        -: 4122:		using inlbf = inch_pounds;
        -: 4123:		using mkgf = meter_kilograms;
        -: 4124:		/** @} */
        -: 4125:	}
        -: 4126:
        -: 4127:	namespace detail
        -: 4128:	{
        -: 4129:		template<typename T> struct is_torque_unit_impl : std::false_type {};
        -: 4130:		template<typename C, typename U, typename P, typename T>
        -: 4131:		struct is_torque_unit_impl<unit<C, U, P, T>> : std::is_same<base_unit_of<typename unit_traits<unit<C, U, P, T>>::base_unit_type>, category::torque_unit>::type {};
        -: 4132:		template<typename U, typename S, template<typename> class N>
        -: 4133:		struct is_torque_unit_impl<unit_t<U, S, N>> : std::is_same<base_unit_of<typename unit_t_traits<unit_t<U, S, N>>::unit_type>, category::torque_unit>::type {};
        -: 4134:	}
        -: 4135:
        -: 4136:	/**
        -: 4137:	 * @ingroup		TypeTraits
        -: 4138:	 * @brief		Trait which tests whether a type represents a unit of torque
        -: 4139:	 * @details		Inherits from `std::true_type` or `std::false_type`. Use `is_torque_unit<T>::value` to test
        -: 4140:	 *				the unit represents a torque quantity.
        -: 4141:	 * @tparam		T	one or more types to test
        -: 4142:	 */
        -: 4143:	template<typename... T> struct is_torque_unit : std::integral_constant<bool, all_true<detail::is_torque_unit_impl<typename std::decay<T>::type>::value...>::value> {};
        -: 4144:
        -: 4145:	//------------------------------
        -: 4146:	//	AREA UNITS
        -: 4147:	//------------------------------
        -: 4148:
        -: 4149:	/**
        -: 4150:	 * @brief		namespace for unit types and containers representing area values
        -: 4151:	 * @details		The SI unit for area is `square_meters`, and the corresponding `base_unit` category is
        -: 4152:	 *				`area_unit`.
        -: 4153:	 * @sa			See unit_t for more information on unit type containers.
        -: 4154:	 */
        -: 4155:	namespace area
        -: 4156:	{
        -: 4157:		/**
        -: 4158:		 * @name Units (full names plural)
        -: 4159:		 * @{
        -: 4160:		 */
        -: 4161:		using square_meters = unit<std::ratio<1>, category::area_unit>;
        -: 4162:		using square_feet = squared<length::feet>;
        -: 4163:		using square_inches = squared<length::inch>;
        -: 4164:		using square_miles = squared<length::miles>;
        -: 4165:		using square_kilometers = squared<length::kilometers>;
        -: 4166:		using hectares = unit<std::ratio<10000>, square_meters>;
        -: 4167:		using acres = unit<std::ratio<43560>, square_feet>;
        -: 4168:		/** @} */
        -: 4169:
        -: 4170:		/**
        -: 4171:		 * @name Units (full names singular)
        -: 4172:		 * @{
        -: 4173:		 */
        -: 4174:		using square_meter = square_meters;
        -: 4175:		using square_foot = square_feet;
        -: 4176:		using square_inch = square_inches;
        -: 4177:		using square_mile = square_miles;
        -: 4178:		using square_kilometer = square_kilometers;
        -: 4179:		using hectare = hectares;
        -: 4180:		using acre = acres;
        -: 4181:		/** @} */
        -: 4182:
        -: 4183:		/**
        -: 4184:		 * @name Units (abbreviated names)
        -: 4185:		 * @{
        -: 4186:		 */
        -: 4187:		using ha = hectares;
        -: 4188:		/** @} */
        -: 4189:
        -: 4190:		/**
        -: 4191:		 * @name Unit Containers
        -: 4192:		 * @anchor areaContainers
        -: 4193:		 * @{
        -: 4194:		 */
        -: 4195:		using square_meter_t = unit_t<square_meter>;
        -: 4196:		using square_foot_t = unit_t<square_foot>;
        -: 4197:		using square_inch_t = unit_t<square_inch>;
        -: 4198:		using square_mile_t = unit_t<square_mile>;
        -: 4199:		using square_kilometer_t = unit_t<square_kilometer>;
        -: 4200:		using hectare_t = unit_t<hectare>;
        -: 4201:		using acre_t = unit_t<acre>;
        -: 4202:		/** @} */
        -: 4203:	}
        -: 4204:
        -: 4205:	namespace detail
        -: 4206:	{
        -: 4207:		template<typename T> struct is_area_unit_impl : std::false_type {};
        -: 4208:		template<typename C, typename U, typename P, typename T>
        -: 4209:		struct is_area_unit_impl<unit<C, U, P, T>> : std::is_same<base_unit_of<typename unit_traits<unit<C, U, P, T>>::base_unit_type>, category::area_unit>::type {};
        -: 4210:		template<typename U, typename S, template<typename> class N>
        -: 4211:		struct is_area_unit_impl<unit_t<U, S, N>> : std::is_same<base_unit_of<typename unit_t_traits<unit_t<U, S, N>>::unit_type>, category::area_unit>::type {};
        -: 4212:	}
        -: 4213:
        -: 4214:	/**
        -: 4215:	 * @ingroup		TypeTraits
        -: 4216:	 * @brief		Trait which tests whether a type represents a unit of area
        -: 4217:	 * @details		Inherits from `std::true_type` or `std::false_type`. Use `is_area_unit<T>::value` to test
        -: 4218:	 *				the unit represents a area quantity.
        -: 4219:	 * @tparam		T	one or more types to test
        -: 4220:	 */
        -: 4221:	template<typename... T> struct is_area_unit : std::integral_constant<bool, all_true<detail::is_area_unit_impl<typename std::decay<T>::type>::value...>::value> {};
        -: 4222:
        -: 4223:	//------------------------------
        -: 4224:	//	UNITS OF VOLUME
        -: 4225:	//------------------------------
        -: 4226:
        -: 4227:	/**
        -: 4228:	 * @brief		namespace for unit types and containers representing volume values
        -: 4229:	 * @details		The SI unit for volume is `cubic_meters`, and the corresponding `base_unit` category is
        -: 4230:	 *				`volume_unit`.
        -: 4231:	 * @sa			See unit_t for more information on unit type containers.
        -: 4232:	 */
        -: 4233:	namespace volume
        -: 4234:	{
        -: 4235:		/**
        -: 4236:		 * @name Units (full names plural)
        -: 4237:		 * @{
        -: 4238:		 */
        -: 4239:		using cubic_meters = unit<std::ratio<1>, category::volume_unit>;
        -: 4240:		using cubic_millimeters = cubed<length::millimeter>;
        -: 4241:		using cubic_kilometers = cubed<length::kilometer>;
        -: 4242:		using liters = cubed<deci<length::meter>>;
        -: 4243:		using milliliters = milli<liters>;
        -: 4244:		using cubic_inches = cubed<length::inches>;
        -: 4245:		using cubic_feet = cubed<length::feet>;
        -: 4246:		using cubic_yards = cubed<length::yards>;
        -: 4247:		using cubic_miles = cubed<length::miles>;
        -: 4248:		using gallons = unit<std::ratio<231>, cubic_inches>;
        -: 4249:		using quarts = unit<std::ratio<1, 4>, gallons>;
        -: 4250:		using pints = unit<std::ratio<1, 2>, quarts>;
        -: 4251:		using cups = unit<std::ratio<1, 2>, pints>;
        -: 4252:		using ounces = unit<std::ratio<1, 8>, cups>;
        -: 4253:		using barrels = unit<std::ratio<42>, gallons>;
        -: 4254:		using bushels = unit<std::ratio<215042, 100>, cubic_inches>;
        -: 4255:		using cords = unit<std::ratio<128>, cubic_feet>;
        -: 4256:		using cubic_fathoms = cubed<length::fathom>;
        -: 4257:		using tablespoons = unit<std::ratio<1, 2>, ounces>;
        -: 4258:		using teaspoons = unit<std::ratio<1, 6>, ounces>;
        -: 4259:		using pinches = unit<std::ratio<1, 8>, teaspoons>;
        -: 4260:		using dashes = unit<std::ratio<1, 2>, pinches>;
        -: 4261:		using drops = unit<std::ratio<1, 360>, ounces>;
        -: 4262:		using fifths = unit<std::ratio<1, 5>, gallons>;
        -: 4263:		using drams = unit<std::ratio<1, 8>, ounces>;
        -: 4264:		using gills = unit<std::ratio<4>, ounces>;
        -: 4265:		using pecks = unit<std::ratio<1, 4>, bushels>;
        -: 4266:		using sacks = unit<std::ratio<3>, bushels>;
        -: 4267:		using shots = unit<std::ratio<3, 2>, ounces>;
        -: 4268:		using strikes = unit<std::ratio<2>, bushels>;
        -: 4269:		/** @} */
        -: 4270:
        -: 4271:		/**
        -: 4272:		 * @name Units (alternate names)
        -: 4273:		 * @{
        -: 4274:		 */
        -: 4275:		using fluidOunces = ounces;
        -: 4276:		/** @} */
        -: 4277:
        -: 4278:		/**
        -: 4279:		 * @name  Units (full names singular)
        -: 4280:		 * @{
        -: 4281:		 */
        -: 4282:		using cubic_meter = cubic_meters;
        -: 4283:		using cubic_millimeter = cubic_millimeters;
        -: 4284:		using cubic_kilometer = cubic_kilometers;
        -: 4285:		using liter = liters;
        -: 4286:		using milliliter = milliliters;
        -: 4287:		using cubic_inch = cubic_inches;
        -: 4288:		using cubic_foot = cubic_feet;
        -: 4289:		using cubic_yard = cubic_yards;
        -: 4290:		using cubic_mile = cubic_miles;
        -: 4291:		using gallon = gallons;
        -: 4292:		using quart = quarts;
        -: 4293:		using pint = pints;
        -: 4294:		using cup = cups;
        -: 4295:		using ounce = ounces;
        -: 4296:		using barrel = barrels;
        -: 4297:		using bushel = bushels;
        -: 4298:		using cord = cords;
        -: 4299:		using cubic_fathom = cubic_fathoms;
        -: 4300:		using tablespoon = tablespoons;
        -: 4301:		using teaspoon = teaspoons;
        -: 4302:		using pinch = pinches;
        -: 4303:		using dash = dashes;
        -: 4304:		using drop = drops;
        -: 4305:		using fifth = fifths;
        -: 4306:		using dram = drams;
        -: 4307:		using gill = gills;
        -: 4308:		using peck = pecks;
        -: 4309:		using sack = sacks;
        -: 4310:		using shot = shots;
        -: 4311:		using strike = strikes;
        -: 4312:		using fluidOunce = fluidOunces;
        -: 4313:		/** @} */
        -: 4314:
        -: 4315:		/**
        -: 4316:		 * @name  Unit Containers
        -: 4317:		 * @anchor volumeContainers
        -: 4318:		 * @{
        -: 4319:		 */
        -: 4320:		using cubic_meter_t = unit_t<cubic_meter>;
        -: 4321:		using cubic_millimeter_t = unit_t<cubic_millimeter>;
        -: 4322:		using cubic_kilometer_t = unit_t<cubic_kilometer>;
        -: 4323:		using liter_t = unit_t<liter>;
        -: 4324:		using milliliter_t = unit_t<milliliter>;
        -: 4325:		using cubic_inch_t = unit_t<cubic_inch>;
        -: 4326:		using cubic_foot_t = unit_t<cubic_foot>;
        -: 4327:		using cubic_yard_t = unit_t<cubic_yard>;
        -: 4328:		using cubic_mile_t = unit_t<cubic_mile>;
        -: 4329:		using gallon_t = unit_t<gallon>;
        -: 4330:		using quart_t = unit_t<quart>;
        -: 4331:		using pint_t = unit_t<pint>;
        -: 4332:		using cup_t = unit_t<cup>;
        -: 4333:		using ounce_t = unit_t<ounce>;
        -: 4334:		using barrel_t = unit_t<barrel>;
        -: 4335:		using bushel_t = unit_t<bushel>;
        -: 4336:		using cord_t = unit_t<cord>;
        -: 4337:		using cubic_fathom_t = unit_t<cubic_fathom>;
        -: 4338:		using tablespoon_t = unit_t<tablespoon>;
        -: 4339:		using teaspoon_t = unit_t<teaspoon>;
        -: 4340:		using pinch_t = unit_t<pinch>;
        -: 4341:		using dash_t = unit_t<dash>;
        -: 4342:		using drop_t = unit_t<drop>;
        -: 4343:		using fifth_t = unit_t<fifth>;
        -: 4344:		using dram_t = unit_t<dram>;
        -: 4345:		using gill_t = unit_t<gill>;
        -: 4346:		using peck_t = unit_t<peck>;
        -: 4347:		using sack_t = unit_t<sack>;
        -: 4348:		using shot_t = unit_t<shot>;
        -: 4349:		using strike_t = unit_t<strike>;
        -: 4350:		/** @} */
        -: 4351:
        -: 4352:		/**
        -: 4353:		 * @name Units (abbreviated names)
        -: 4354:		 * @{
        -: 4355:		 */
        -: 4356:		using m3 = cubic_meters;
        -: 4357:		using mm3 = cubic_millimeters;
        -: 4358:		using km3 = cubic_kilometers;
        -: 4359:		using L = liters;
        -: 4360:		using mL = milliliters;
        -: 4361:		using cu_in = cubic_inches;
        -: 4362:		using cu_ft = cubic_feet;
        -: 4363:		using cu_yd = cubic_yards;
        -: 4364:		using cu_mi = cubic_miles;
        -: 4365:		using gal = gallons;
        -: 4366:		using qt = quarts;
        -: 4367:		using pt = pints;
        -: 4368:		using c = cups;
        -: 4369:		using oz = ounces;
        -: 4370:		using bl = barrels;
        -: 4371:		using bu = bushels;
        -: 4372:		using cu_fm = cubic_fathoms;
        -: 4373:		using tbsp = tablespoons;
        -: 4374:		using tsp = teaspoons;
        -: 4375:		using dr = drams;
        -: 4376:		using gi = gills;
        -: 4377:		using pk = pecks;
        -: 4378:		/** @} */
        -: 4379:	}
        -: 4380:
        -: 4381:	namespace detail
        -: 4382:	{
        -: 4383:		template<typename T> struct is_volume_unit_impl : std::false_type {};
        -: 4384:		template<typename C, typename U, typename P, typename T>
        -: 4385:		struct is_volume_unit_impl<unit<C, U, P, T>> : std::is_same<base_unit_of<typename unit_traits<unit<C, U, P, T>>::base_unit_type>, category::volume_unit>::type {};
        -: 4386:		template<typename U, typename S, template<typename> class N>
        -: 4387:		struct is_volume_unit_impl<unit_t<U, S, N>> : std::is_same<base_unit_of<typename unit_t_traits<unit_t<U, S, N>>::unit_type>, category::volume_unit>::type {};
        -: 4388:	}
        -: 4389:
        -: 4390:	/**
        -: 4391:	 * @ingroup		TypeTraits
        -: 4392:	 * @brief		Trait which tests whether a type represents a unit of volume
        -: 4393:	 * @details		Inherits from `std::true_type` or `std::false_type`. Use `is_volume_unit<T>::value` to test
        -: 4394:	 *				the unit represents a volume quantity.
        -: 4395:	 * @tparam		T	one or more types to test
        -: 4396:	 */
        -: 4397:	template<typename... T> struct is_volume_unit : std::integral_constant<bool, all_true<detail::is_volume_unit_impl<typename std::decay<T>::type>::value...>::value> {};
        -: 4398:
        -: 4399:	//------------------------------
        -: 4400:	//	UNITS OF DENSITY
        -: 4401:	//------------------------------
        -: 4402:
        -: 4403:	/**
        -: 4404:	 * @brief		namespace for unit types and containers representing density values
        -: 4405:	 * @details		The SI unit for density is `kilograms_per_cubic_meter`, and the corresponding `base_unit` category is
        -: 4406:	 *				`density_unit`.
        -: 4407:	 * @sa			See unit_t for more information on unit type containers.
        -: 4408:	 */
        -: 4409:	namespace density
        -: 4410:	{
        -: 4411:		/**
        -: 4412:		 * @name Units (full names plural)
        -: 4413:		 * @{
        -: 4414:		 */
        -: 4415:		using kilograms_per_cubic_meter = unit<std::ratio<1>, category::density_unit>;
        -: 4416:		using grams_per_milliliter = compound_unit<mass::grams, inverse<volume::milliliter>>;
        -: 4417:		using kilograms_per_liter = compound_unit<mass::kilograms, inverse<volume::liter>>;
        -: 4418:		using ounces_per_cubic_foot = compound_unit<mass::ounces, inverse<volume::cubic_foot>>;
        -: 4419:		using ounces_per_cubic_inch = compound_unit<mass::ounces, inverse<volume::cubic_inch>>;
        -: 4420:		using ounces_per_gallon = compound_unit<mass::ounces, inverse<volume::gallon>>;
        -: 4421:		using pounds_per_cubic_foot = compound_unit<mass::pounds, inverse<volume::cubic_foot>>;
        -: 4422:		using pounds_per_cubic_inch = compound_unit<mass::pounds, inverse<volume::cubic_inch>>;
        -: 4423:		using pounds_per_gallon = compound_unit<mass::pounds, inverse<volume::gallon>>;
        -: 4424:		using slugs_per_cubic_foot = compound_unit<mass::slugs, inverse<volume::cubic_foot>>;
        -: 4425:		/** @} */
        -: 4426:
        -: 4427:		/**
        -: 4428:		 * @name Units (full names singular)
        -: 4429:		 * @{
        -: 4430:		 */
        -: 4431:		using kilogram_per_cubic_meter = kilograms_per_cubic_meter;
        -: 4432:		using gram_per_milliliter = grams_per_milliliter;
        -: 4433:		using kilogram_per_liter = kilograms_per_liter;
        -: 4434:		using ounce_per_cubic_foot = ounces_per_cubic_foot;
        -: 4435:		using ounce_per_cubic_inch = ounces_per_cubic_inch;
        -: 4436:		using ounce_per_gallon = ounces_per_gallon;
        -: 4437:		using pound_per_cubic_foot = pounds_per_cubic_foot;
        -: 4438:		using pound_per_cubic_inch = pounds_per_cubic_inch;
        -: 4439:		using pound_per_gallon = pounds_per_gallon;
        -: 4440:		using slug_per_cubic_foot = slugs_per_cubic_foot;
        -: 4441:		/** @} */
        -: 4442:
        -: 4443:		/**
        -: 4444:		 * @name  Unit Containers
        -: 4445:		 * @anchor densityContainers
        -: 4446:		 * @{
        -: 4447:		 */
        -: 4448:		using kilogram_per_cubic_meter_t = unit_t<kilogram_per_cubic_meter>;
        -: 4449:		using gram_per_milliliter_t = unit_t<gram_per_milliliter>;
        -: 4450:		using kilogram_per_liter_t = unit_t<kilogram_per_liter>;
        -: 4451:		using ounce_per_cubic_foot_t = unit_t<ounce_per_cubic_foot>;
        -: 4452:		using ounce_per_cubic_inch_t = unit_t<ounce_per_cubic_inch>;
        -: 4453:		using ounce_per_gallon_t = unit_t<ounce_per_gallon>;
        -: 4454:		using pound_per_cubic_foot_t = unit_t<pound_per_cubic_foot>;
        -: 4455:		using pound_per_cubic_inch_t = unit_t<pound_per_cubic_inch>;
        -: 4456:		using pound_per_gallon_t = unit_t<pound_per_gallon>;
        -: 4457:		using slug_per_cubic_foot_t = unit_t<slug_per_cubic_foot>;
        -: 4458:		/** @} */
        -: 4459:	}
        -: 4460:
        -: 4461:	namespace detail
        -: 4462:	{
        -: 4463:		template<typename T> struct is_density_unit_impl : std::false_type {};
        -: 4464:		template<typename C, typename U, typename P, typename T>
        -: 4465:		struct is_density_unit_impl<unit<C, U, P, T>> : std::is_same<base_unit_of<typename unit_traits<unit<C, U, P, T>>::base_unit_type>, category::density_unit>::type {};
        -: 4466:		template<typename U, typename S, template<typename> class N>
        -: 4467:		struct is_density_unit_impl<unit_t<U, S, N>> : std::is_same<base_unit_of<typename unit_t_traits<unit_t<U, S, N>>::unit_type>, category::density_unit>::type {};
        -: 4468:	}
        -: 4469:
        -: 4470:	/**
        -: 4471:	 * @ingroup		TypeTraits
        -: 4472:	 * @brief		Trait which tests whether a type represents a unit of density
        -: 4473:	 * @details		Inherits from `std::true_type` or `std::false_type`. Use `is_density_unit<T>::value` to test
        -: 4474:	 *				the unit represents a density quantity.
        -: 4475:	 * @tparam		T	one or more types to test
        -: 4476:	 */
        -: 4477:	template<typename... T> struct is_density_unit : std::integral_constant<bool, all_true<detail::is_density_unit_impl<typename std::decay<T>::type>::value...>::value> {};
        -: 4478:
        -: 4479:	//------------------------------
        -: 4480:	//	UNITS OF CONCENTRATION
        -: 4481:	//------------------------------
        -: 4482:
        -: 4483:	/**
        -: 4484:	 * @brief		namespace for unit types and containers representing concentration values
        -: 4485:	 * @details		The SI unit for concentration is `parts_per_million`, and the corresponding `base_unit` category is
        -: 4486:	 *				`scalar_unit`.
        -: 4487:	 * @sa			See unit_t for more information on unit type containers.
        -: 4488:	 */
        -: 4489:	namespace concentration
        -: 4490:	{
        -: 4491:		/**
        -: 4492:		 * @name  Units (full names plural)
        -: 4493:		 * @{
        -: 4494:		 */
        -: 4495:		using parts_per_million = unit<std::ratio<1, 1000000>, category::scalar_unit>;
        -: 4496:		using parts_per_billion = unit<std::ratio<1, 1000>, parts_per_million>;
        -: 4497:		using parts_per_trillion = unit<std::ratio<1, 1000>, parts_per_billion>;
        -: 4498:		using percent = unit<std::ratio<1, 100>, category::scalar_unit>;
        -: 4499:		/** @} */
        -: 4500:
        -: 4501:		/**
        -: 4502:		 * @name  Units (full names singular)
        -: 4503:		 * @{
        -: 4504:		 */
        -: 4505:		using ppm = parts_per_million;
        -: 4506:		using ppb = parts_per_billion;
        -: 4507:		using ppt = parts_per_trillion;
        -: 4508:		/** @} */
        -: 4509:
        -: 4510:		/**
        -: 4511:		 * @name Unit Containers
        -: 4512:		 * @anchor concentrationContainers
        -: 4513:		 * @{
        -: 4514:		 */
        -: 4515:		using ppm_t = unit_t<ppm>;
        -: 4516:		using ppb_t = unit_t<ppb>;
        -: 4517:		using ppt_t = unit_t<ppt>;
        -: 4518:		using percent_t = unit_t<percent>;
        -: 4519:		/** @} */
        -: 4520:	}
        -: 4521:
        -: 4522:	namespace detail
        -: 4523:	{
        -: 4524:		template<typename T> struct is_concentration_unit_impl : std::false_type {};
        -: 4525:		template<typename C, typename U, typename P, typename T>
        -: 4526:		struct is_concentration_unit_impl<unit<C, U, P, T>> : std::is_same<base_unit_of<typename unit_traits<unit<C, U, P, T>>::base_unit_type>, category::scalar_unit>::type {};
        -: 4527:		template<typename U, typename S, template<typename> class N>
        -: 4528:		struct is_concentration_unit_impl<unit_t<U, S, N>> : std::is_same<base_unit_of<typename unit_t_traits<unit_t<U, S, N>>::unit_type>, category::scalar_unit>::type {};
        -: 4529:	}
        -: 4530:
        -: 4531:	/**
        -: 4532:	 * @ingroup		TypeTraits
        -: 4533:	 * @brief		Trait which tests whether a type represents a unit of concentration
        -: 4534:	 * @details		Inherits from `std::true_type` or `std::false_type`. Use `is_concentration_unit<T>::value` to test
        -: 4535:	 *				the unit represents a concentration quantity.
        -: 4536:	 * @tparam		T	one or more types to test
        -: 4537:	 */
        -: 4538:	template<typename T> struct is_concentration_unit : detail::is_concentration_unit_impl <typename std::decay<T>::type> {};
        -: 4539:
        -: 4540:	//------------------------------
        -: 4541:	//	CONSTANTS
        -: 4542:	//------------------------------
        -: 4543:
        -: 4544:	/**
        -: 4545:	 * @brief		namespace for physical constants like PI and Avogadro's Number.
        -: 4546:	 * @sa			See unit_t for more information on unit type containers.
        -: 4547:	 */
        -: 4548:	namespace constants
        -: 4549:	{
        -: 4550:		/**
        -: 4551:		 * @name Unit Containers
        -: 4552:		 * @anchor constantContainers
        -: 4553:		 * @{
        -: 4554:		 */
        1: 4555:		static const unit_t<unit<std::ratio<1>, dimensionless::scalar, std::ratio<1>>>														pi(1.0);									///< Ratio of a circle's circumference to its diameter.
        1: 4556:		static const velocity::meters_per_second_t																							c(299792458.0);								///< Speed of light in vacuum.
        1: 4557:		static const unit_t<compound_unit<cubed<length::meters>, inverse<mass::kilogram>, inverse<squared<time::seconds>>>>					G(6.67408e-11);								///< Newtonian constant of gravitation.
        1: 4558:		static const unit_t<compound_unit<energy::joule, time::seconds>>																	h(6.626070040e-34);							///< Planck constant.
        1: 4559:		static const unit_t<compound_unit<force::newtons, inverse<squared<current::ampere>>>>												mu0(4.0e-7 * PI);							///< vacuum permeability.
        1: 4560:		static const unit_t<compound_unit<capacitance::farad, inverse<length::meter>>>														epsilon0(1.0 / (mu0 * units::pow<2>(c)));	///< vacuum permitivity.
        1: 4561:		static const impedance::ohm_t																										Z0(mu0 * c);								///< characteristic impedance of vacuum.
        1: 4562:		static const unit_t<compound_unit<force::newtons, area::square_meter, inverse<squared<charge::coulomb>>>>							k_e(1.0 / (4 * pi * epsilon0));				///< Coulomb's constant.
        1: 4563:		static const charge::coulomb_t																										e(1.602176565e-19);							///< elementary charge.
        1: 4564:		static const mass::kilogram_t																										m_e(9.10938291e-31);						///< electron mass.
        1: 4565:		static const mass::kilogram_t																										m_p(1.672621777e-27);						///< proton mass.
        1: 4566:		static const unit_t<compound_unit<energy::joules, inverse<magnetic_field_strength::tesla>>>											mu_B(e * h / (4 * pi *m_e));				///< Bohr magneton.
        1: 4567:		static const unit_t<inverse<substance::mol>>																						N_A(6.02214129e23);							///< Avagadro's Number.
        1: 4568:		static const unit_t<compound_unit<energy::joules, inverse<temperature::kelvin>, inverse<substance::moles>>>							R(8.3144621);								///< Gas constant.
        1: 4569:		static const unit_t<compound_unit<energy::joules, inverse<temperature::kelvin>>>													k_B(R / N_A);								///< Boltzmann constant.
        1: 4570:		static const unit_t<compound_unit<charge::coulomb, inverse<substance::mol>>>														F(N_A * e);									///< Faraday constnat.
        1: 4571:		static const unit_t<compound_unit<power::watts, inverse<area::square_meters>, inverse<squared<squared<temperature::kelvin>>>>>		sigma((2 * pow<5>(pi) * pow<4>(R)) / (15 * pow<3>(h) * pow<2>(c) * pow<4>(N_A)));	///< Stefan-Boltzmann constant.
        -: 4572:		/** @} */
        -: 4573:	}
        -: 4574:
        -: 4575:};	// end namespace units
        -: 4576:
        -: 4577:#if _MCS_VER < 1800
        -: 4578:#	pragma warning(pop)
        -: 4579:#endif
        -: 4580:
        -: 4581:#endif // units_h__
        -: 4582:
        -: 4583:// For Emacs
        -: 4584:// Local Variables:
        -: 4585:// Mode: C++
        -: 4586:// c-basic-offset: 2
        -: 4587:// fill-column: 116
        -: 4588:// tab-width: 4
        -: 4589:// End:
