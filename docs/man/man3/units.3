.TH "units" 3 "Sun Apr 3 2016" "Version 2.0.0" "Unit Conversion and Dimensional Analysis Library" \" -*- nroff -*-
.ad l
.nh
.SH NAME
units \- Unit Conversion Library namespace\&.  

.SH SYNOPSIS
.br
.PP
.SS "Namespaces"

.in +1c
.ti -1c
.RI " \fBacceleration\fP"
.br
.RI "\fInamespace for unit types and containers representing acceleration values \fP"
.ti -1c
.RI " \fBangle\fP"
.br
.RI "\fInamespace for unit types and containers representing angle values \fP"
.ti -1c
.RI " \fBangular_velocity\fP"
.br
.RI "\fInamespace for unit types and containers representing angular velocity values \fP"
.ti -1c
.RI " \fBarea\fP"
.br
.RI "\fInamespace for unit types and containers representing area values \fP"
.ti -1c
.RI " \fBcapacitance\fP"
.br
.RI "\fInamespace for unit types and containers representing capacitance values \fP"
.ti -1c
.RI " \fBcategory\fP"
.br
.RI "\fInamespace representing the implemented base and derived unit types\&. \fP"
.ti -1c
.RI " \fBcharge\fP"
.br
.RI "\fInamespace for unit types and containers representing charge values \fP"
.ti -1c
.RI " \fBconcentration\fP"
.br
.RI "\fInamespace for unit types and containers representing concentration values \fP"
.ti -1c
.RI " \fBconductance\fP"
.br
.RI "\fInamespace for unit types and containers representing conductance values \fP"
.ti -1c
.RI " \fBconstants\fP"
.br
.RI "\fInamespace for physical constants like PI and Avogadro's Number\&. \fP"
.ti -1c
.RI " \fBcurrent\fP"
.br
.RI "\fInamespace for unit types and containers representing current values \fP"
.ti -1c
.RI " \fBdensity\fP"
.br
.RI "\fInamespace for unit types and containers representing density values \fP"
.ti -1c
.RI " \fBdimensionless\fP"
.br
.RI "\fInamespace for unit types and containers for units that have no dimension (scalar units) \fP"
.ti -1c
.RI " \fBenergy\fP"
.br
.RI "\fInamespace for unit types and containers representing energy values \fP"
.ti -1c
.RI " \fBforce\fP"
.br
.RI "\fInamespace for unit types and containers representing force values \fP"
.ti -1c
.RI " \fBfrequency\fP"
.br
.RI "\fInamespace for unit types and containers representing frequency values \fP"
.ti -1c
.RI " \fBilluminance\fP"
.br
.RI "\fInamespace for unit types and containers representing illuminance values \fP"
.ti -1c
.RI " \fBimpedance\fP"
.br
.RI "\fInamespace for unit types and containers representing impedance values \fP"
.ti -1c
.RI " \fBinductance\fP"
.br
.RI "\fInamespace for unit types and containers representing inductance values \fP"
.ti -1c
.RI " \fBlength\fP"
.br
.RI "\fInamespace for unit types and containers representing length values \fP"
.ti -1c
.RI " \fBluminous_flux\fP"
.br
.RI "\fInamespace for unit types and containers representing \fBluminous_flux\fP values \fP"
.ti -1c
.RI " \fBluminous_intensity\fP"
.br
.RI "\fInamespace for unit types and containers representing \fBluminous_intensity\fP values \fP"
.ti -1c
.RI " \fBmagnetic_field_strength\fP"
.br
.RI "\fInamespace for unit types and containers representing \fBmagnetic_field_strength\fP values \fP"
.ti -1c
.RI " \fBmagnetic_flux\fP"
.br
.RI "\fInamespace for unit types and containers representing \fBmagnetic_flux\fP values \fP"
.ti -1c
.RI " \fBmass\fP"
.br
.RI "\fInamespace for unit types and containers representing mass values \fP"
.ti -1c
.RI " \fBmath\fP"
.br
.RI "\fInamespace for unit-enabled versions of the \fC<cmath>\fP library \fP"
.ti -1c
.RI " \fBpower\fP"
.br
.RI "\fInamespace for unit types and containers representing power values \fP"
.ti -1c
.RI " \fBpressure\fP"
.br
.RI "\fInamespace for unit types and containers representing pressure values \fP"
.ti -1c
.RI " \fBradiation\fP"
.br
.RI "\fInamespace for unit types and containers representing radiation values \fP"
.ti -1c
.RI " \fBsolid_angle\fP"
.br
.RI "\fInamespace for unit types and containers representing \fBsolid_angle\fP values \fP"
.ti -1c
.RI " \fBsubstance\fP"
.br
.RI "\fInamespace for unit types and containers representing substance values \fP"
.ti -1c
.RI " \fBtemperature\fP"
.br
.RI "\fInamespace for unit types and containers representing temperature values \fP"
.ti -1c
.RI " \fBtime\fP"
.br
.RI "\fInamespace for unit types and containers representing time values \fP"
.ti -1c
.RI " \fBtorque\fP"
.br
.RI "\fInamespace for unit types and containers representing torque values \fP"
.ti -1c
.RI " \fBtraits\fP"
.br
.RI "\fInamespace representing type traits which can access the properties of types provided by the units library\&. \fP"
.ti -1c
.RI " \fBvelocity\fP"
.br
.RI "\fInamespace for unit types and containers representing velocity values \fP"
.ti -1c
.RI " \fBvoltage\fP"
.br
.RI "\fInamespace for unit types and containers representing voltage values \fP"
.ti -1c
.RI " \fBvolume\fP"
.br
.RI "\fInamespace for unit types and containers representing volume values \fP"
.in -1c
.SS "Classes"

.in +1c
.ti -1c
.RI "struct \fBbase_unit\fP"
.br
.RI "\fIClass representing SI base unit types\&. \fP"
.ti -1c
.RI "struct \fBdecibel_scale\fP"
.br
.RI "\fI\fBunit_t\fP scale for representing decibel values\&. \fP"
.ti -1c
.RI "struct \fBlinear_scale\fP"
.br
.RI "\fI\fBunit_t\fP scale which is linear \fP"
.ti -1c
.RI "struct \fBunit\fP"
.br
.RI "\fIType representing an arbitrary unit\&. \fP"
.ti -1c
.RI "class \fBunit_t\fP"
.br
.RI "\fIContainer for values which represent quantities of a given unit\&. \fP"
.ti -1c
.RI "struct \fBunit_value_add\fP"
.br
.RI "\fIadds two \fBunit_value_t\fP types at compile-time \fP"
.ti -1c
.RI "struct \fBunit_value_divide\fP"
.br
.RI "\fIdivides two \fBunit_value_t\fP types at compile-time \fP"
.ti -1c
.RI "struct \fBunit_value_multiply\fP"
.br
.RI "\fImultiplies two \fBunit_value_t\fP types at compile-time \fP"
.ti -1c
.RI "struct \fBunit_value_power\fP"
.br
.RI "\fIraises unit_value_to a power at compile-time \fP"
.ti -1c
.RI "struct \fBunit_value_sqrt\fP"
.br
.RI "\fIcalculates square root of \fBunit_value_t\fP at compile-time \fP"
.ti -1c
.RI "struct \fBunit_value_subtract\fP"
.br
.RI "\fIsubtracts two \fBunit_value_t\fP types at compile-time \fP"
.ti -1c
.RI "struct \fBunit_value_t\fP"
.br
.RI "\fIStores a rational unit value as a compile-time constant\&. \fP"
.in -1c
.SS "Typedefs"

.in +1c
.ti -1c
.RI "template<class U > using \fBinverse\fP = typename detail::inverse_impl< U >::type"
.br
.RI "\fIrepresents the inverse unit type of \fCclass U\fP\&. \fP"
.ti -1c
.RI "template<class U > using \fBsquared\fP = typename detail::squared_impl< U >::type"
.br
.RI "\fIrepresents the unit type of \fCclass U\fP squared \fP"
.ti -1c
.RI "template<class U > using \fBcubed\fP = typename detail::cubed_impl< U >::type"
.br
.RI "\fIrepresents the type of \fCclass U\fP cubed\&. \fP"
.ti -1c
.RI "template<typename Ratio , std::intmax_t Eps = 10000000000> using \fBratio_sqrt\fP = typename detail::Sqrt< Ratio, std::ratio< 1, Eps >>::type"
.br
.RI "\fICalculate square root of a ratio at compile-time\&. \fP"
.ti -1c
.RI "template<class U , std::intmax_t Eps = 10000000000> using \fBsquare_root\fP = typename detail::sqrt_impl< U, Eps >::type"
.br
.RI "\fIrepresents the square root of type \fCclass U\fP\&. \fP"
.ti -1c
.RI "template<class U , class\&.\&.\&. Us> using \fBcompound_unit\fP = typename detail::compound_impl< U, Us\&.\&.\&.>::type"
.br
.RI "\fIRepresents a unit type made up from other units\&. \fP"
.in -1c
.PP
.RI "\fB\fP"
.br

.in +1c
.in +1c
.ti -1c
.RI "template<class U > using \fBatto\fP = typename detail::prefix< std::atto, U >::type"
.br
.RI "\fIRepresents the type of \fCclass U\fP with the metric 'atto' prefix appended\&. \fP"
.ti -1c
.RI "template<class U > using \fBfemto\fP = typename detail::prefix< std::femto, U >::type"
.br
.RI "\fIRepresents the type of \fCclass U\fP with the metric 'atto' prefix appended\&. \fP"
.ti -1c
.RI "template<class U > using \fBpico\fP = typename detail::prefix< std::pico, U >::type"
.br
.RI "\fIRepresents the type of \fCclass U\fP with the metric 'femto' prefix appended\&. \fP"
.ti -1c
.RI "template<class U > using \fBnano\fP = typename detail::prefix< std::nano, U >::type"
.br
.RI "\fIRepresents the type of \fCclass U\fP with the metric 'pico' prefix appended\&. \fP"
.ti -1c
.RI "template<class U > using \fBmicro\fP = typename detail::prefix< std::micro, U >::type"
.br
.RI "\fIRepresents the type of \fCclass U\fP with the metric 'nano' prefix appended\&. \fP"
.ti -1c
.RI "template<class U > using \fBmilli\fP = typename detail::prefix< std::milli, U >::type"
.br
.RI "\fIRepresents the type of \fCclass U\fP with the metric 'micro' prefix appended\&. \fP"
.ti -1c
.RI "template<class U > using \fBcenti\fP = typename detail::prefix< std::centi, U >::type"
.br
.RI "\fIRepresents the type of \fCclass U\fP with the metric 'milli' prefix appended\&. \fP"
.ti -1c
.RI "template<class U > using \fBdeci\fP = typename detail::prefix< std::deci, U >::type"
.br
.RI "\fIRepresents the type of \fCclass U\fP with the metric 'centi' prefix appended\&. \fP"
.ti -1c
.RI "template<class U > using \fBdeca\fP = typename detail::prefix< std::deca, U >::type"
.br
.RI "\fIRepresents the type of \fCclass U\fP with the metric 'deci' prefix appended\&. \fP"
.ti -1c
.RI "template<class U > using \fBhecto\fP = typename detail::prefix< std::hecto, U >::type"
.br
.RI "\fIRepresents the type of \fCclass U\fP with the metric 'deca' prefix appended\&. \fP"
.ti -1c
.RI "template<class U > using \fBkilo\fP = typename detail::prefix< std::kilo, U >::type"
.br
.RI "\fIRepresents the type of \fCclass U\fP with the metric 'hecto' prefix appended\&. \fP"
.ti -1c
.RI "template<class U > using \fBmega\fP = typename detail::prefix< std::mega, U >::type"
.br
.RI "\fIRepresents the type of \fCclass U\fP with the metric 'kilo' prefix appended\&. \fP"
.ti -1c
.RI "template<class U > using \fBgiga\fP = typename detail::prefix< std::giga, U >::type"
.br
.RI "\fIRepresents the type of \fCclass U\fP with the metric 'mega' prefix appended\&. \fP"
.ti -1c
.RI "template<class U > using \fBtera\fP = typename detail::prefix< std::tera, U >::type"
.br
.RI "\fIRepresents the type of \fCclass U\fP with the metric 'giga' prefix appended\&. \fP"
.ti -1c
.RI "template<class U > using \fBpeta\fP = typename detail::prefix< std::peta, U >::type"
.br
.RI "\fIRepresents the type of \fCclass U\fP with the metric 'tera' prefix appended\&. \fP"
.ti -1c
.RI "template<class U > using \fBexa\fP = typename detail::prefix< std::exa, U >::type"
.br
.RI "\fIRepresents the type of \fCclass U\fP with the metric 'peta' prefix appended\&. \fP"
.in -1c
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "template<class UnitFrom , class UnitTo , typename T  = double> static T \fBconvert\fP (const T &value)"
.br
.RI "\fIconverts a \fIvalue\fP from one type to another\&. \fP"
.ti -1c
.RI "template<class Units , typename T , template< typename > class NonLinearScale> std::ostream & \fBoperator<<\fP (std::ostream &os, const \fBunit_t\fP< Units, T, NonLinearScale > &obj)"
.br
.ti -1c
.RI "template<class UnitTypeLhs , class UnitTypeRhs , typename std::enable_if<!traits::is_same_scale< UnitTypeLhs, UnitTypeRhs >::value, int >::type  = 0> int \fBoperator+\fP (const UnitTypeLhs &lhs, const UnitTypeRhs &rhs)"
.br
.ti -1c
.RI "template<class UnitTypeLhs , class UnitTypeRhs , typename std::enable_if< traits::has_linear_scale< UnitTypeLhs, UnitTypeRhs >::value, int >::type  = 0> UnitTypeLhs \fBoperator+\fP (const UnitTypeLhs &lhs, const UnitTypeRhs &rhs)"
.br
.RI "\fIAddition operator for \fBunit_t\fP types with a \fBlinear_scale\fP\&. \fP"
.ti -1c
.RI "template<typename T , typename std::enable_if< std::is_arithmetic< T >::value, int >::type  = 0> \fBdimensionless::scalar_t\fP \fBoperator+\fP (const \fBdimensionless::scalar_t\fP &lhs, T rhs)"
.br
.RI "\fIAddition operator for scalar \fBunit_t\fP types with a \fBlinear_scale\fP\&. Scalar types can be implicitly converted to built-in types\&. \fP"
.ti -1c
.RI "template<typename T , typename std::enable_if< std::is_arithmetic< T >::value, int >::type  = 0> \fBdimensionless::scalar_t\fP \fBoperator+\fP (T lhs, const \fBdimensionless::scalar_t\fP &rhs)"
.br
.RI "\fIAddition operator for scalar \fBunit_t\fP types with a \fBlinear_scale\fP\&. Scalar types can be implicitly converted to built-in types\&. \fP"
.ti -1c
.RI "template<class UnitTypeLhs , class UnitTypeRhs , typename std::enable_if< traits::has_linear_scale< UnitTypeLhs, UnitTypeRhs >::value, int >::type  = 0> UnitTypeLhs \fBoperator-\fP (const UnitTypeLhs &lhs, const UnitTypeRhs &rhs)"
.br
.RI "\fISubtraction operator for \fBunit_t\fP types with a \fBlinear_scale\fP\&. \fP"
.ti -1c
.RI "template<typename T , typename std::enable_if< std::is_arithmetic< T >::value, int >::type  = 0> \fBdimensionless::scalar_t\fP \fBoperator-\fP (const \fBdimensionless::scalar_t\fP &lhs, T rhs)"
.br
.RI "\fISubtraction operator for scalar \fBunit_t\fP types with a \fBlinear_scale\fP\&. Scalar types can be implicitly converted to built-in types\&. \fP"
.ti -1c
.RI "template<typename T , typename std::enable_if< std::is_arithmetic< T >::value, int >::type  = 0> \fBdimensionless::scalar_t\fP \fBoperator-\fP (T lhs, const \fBdimensionless::scalar_t\fP &rhs)"
.br
.RI "\fISubtraction operator for scalar \fBunit_t\fP types with a \fBlinear_scale\fP\&. Scalar types can be implicitly converted to built-in types\&. \fP"
.ti -1c
.RI "template<class UnitTypeLhs , class UnitTypeRhs , typename std::enable_if< traits::is_convertible_unit_t< UnitTypeLhs, UnitTypeRhs >::value &&traits::has_linear_scale< UnitTypeLhs, UnitTypeRhs >::value, int >::type  = 0> auto \fBoperator*\fP (const UnitTypeLhs &lhs, const UnitTypeRhs &rhs) -> \fBunit_t\fP< \fBcompound_unit\fP< \fBsquared\fP< typename \fBtraits::unit_t_traits\fP< UnitTypeLhs >::unit_type >>>"
.br
.RI "\fIMultiplication type for convertible \fBunit_t\fP types with a linear scale\&. \fP"
.ti -1c
.RI "template<class UnitTypeLhs , typename T , typename std::enable_if< std::is_arithmetic< T >::value &&traits::has_linear_scale< UnitTypeLhs >::value, int >::type  = 0> UnitTypeLhs \fBoperator*\fP (const UnitTypeLhs &lhs, T rhs)"
.br
.RI "\fIMultiplication by a scalar for \fBunit_t\fP types with a linear scale\&. \fP"
.ti -1c
.RI "template<class UnitTypeRhs , typename T , typename std::enable_if< std::is_arithmetic< T >::value &&traits::has_linear_scale< UnitTypeRhs >::value, int >::type  = 0> UnitTypeRhs \fBoperator*\fP (T lhs, const UnitTypeRhs &rhs)"
.br
.RI "\fIMultiplication by a scalar for \fBunit_t\fP types with a linear scale\&. \fP"
.ti -1c
.RI "template<class UnitTypeLhs , class UnitTypeRhs , typename std::enable_if< traits::is_convertible_unit_t< UnitTypeLhs, UnitTypeRhs >::value &&traits::has_linear_scale< UnitTypeLhs, UnitTypeRhs >::value, int >::type  = 0> \fBdimensionless::scalar_t\fP \fBoperator/\fP (const UnitTypeLhs &lhs, const UnitTypeRhs &rhs)"
.br
.RI "\fIDivision for convertible \fBunit_t\fP types with a linear scale\&. \fP"
.ti -1c
.RI "template<class UnitTypeLhs , class UnitTypeRhs , typename std::enable_if<!traits::is_convertible_unit_t< UnitTypeLhs, UnitTypeRhs >::value &&traits::has_linear_scale< UnitTypeLhs, UnitTypeRhs >::value, int >::type  = 0> auto \fBoperator/\fP (const UnitTypeLhs &lhs, const UnitTypeRhs &rhs) -> \fBunit_t\fP< \fBcompound_unit\fP< typename \fBtraits::unit_t_traits\fP< UnitTypeLhs >::unit_type, \fBinverse\fP< typename \fBtraits::unit_t_traits\fP< UnitTypeRhs >::unit_type >>>"
.br
.RI "\fIDivision for non-convertible \fBunit_t\fP types with a linear scale\&. \fP"
.ti -1c
.RI "template<class UnitTypeLhs , typename T , typename std::enable_if< std::is_arithmetic< T >::value &&traits::has_linear_scale< UnitTypeLhs >::value, int >::type  = 0> UnitTypeLhs \fBoperator/\fP (const UnitTypeLhs &lhs, T rhs)"
.br
.RI "\fIDivision by a scalar for \fBunit_t\fP types with a linear scale\&. \fP"
.ti -1c
.RI "template<class UnitTypeRhs , typename T , typename std::enable_if< std::is_arithmetic< T >::value &&traits::has_linear_scale< UnitTypeRhs >::value, int >::type  = 0> auto \fBoperator/\fP (T lhs, const UnitTypeRhs &rhs) -> \fBunit_t\fP< \fBinverse\fP< typename \fBtraits::unit_t_traits\fP< UnitTypeRhs >::unit_type >>"
.br
.RI "\fIDivision of a scalar by a \fBunit_t\fP type with a linear scale\&. \fP"
.ti -1c
.RI "bool \fBoperator==\fP (double lhs, const \fBdimensionless::scalar_t\fP &rhs)"
.br
.ti -1c
.RI "bool \fBoperator==\fP (const \fBdimensionless::scalar_t\fP &lhs, double rhs)"
.br
.ti -1c
.RI "bool \fBoperator!=\fP (double lhs, const \fBdimensionless::scalar_t\fP &rhs)"
.br
.ti -1c
.RI "bool \fBoperator!=\fP (const \fBdimensionless::scalar_t\fP &lhs, double rhs)"
.br
.ti -1c
.RI "bool \fBoperator>=\fP (double lhs, const \fBdimensionless::scalar_t\fP &rhs)"
.br
.ti -1c
.RI "bool \fBoperator>=\fP (const \fBdimensionless::scalar_t\fP &lhs, double rhs)"
.br
.ti -1c
.RI "bool \fBoperator>\fP (double lhs, const \fBdimensionless::scalar_t\fP &rhs)"
.br
.ti -1c
.RI "bool \fBoperator>\fP (const \fBdimensionless::scalar_t\fP &lhs, double rhs)"
.br
.ti -1c
.RI "bool \fBoperator<=\fP (double lhs, const \fBdimensionless::scalar_t\fP &rhs)"
.br
.ti -1c
.RI "bool \fBoperator<=\fP (const \fBdimensionless::scalar_t\fP &lhs, double rhs)"
.br
.ti -1c
.RI "bool \fBoperator<\fP (double lhs, const \fBdimensionless::scalar_t\fP &rhs)"
.br
.ti -1c
.RI "bool \fBoperator<\fP (const \fBdimensionless::scalar_t\fP &lhs, double rhs)"
.br
.ti -1c
.RI "template<class UnitTypeLhs , class UnitTypeRhs , typename std::enable_if< traits::has_decibel_scale< UnitTypeLhs, UnitTypeRhs >::value, int >::type  = 0> auto \fBoperator+\fP (const UnitTypeLhs &lhs, const UnitTypeRhs &rhs) -> \fBunit_t\fP< \fBcompound_unit\fP< \fBsquared\fP< typename \fBtraits::unit_t_traits\fP< UnitTypeLhs >::unit_type >>, typename \fBtraits::unit_t_traits\fP< UnitTypeLhs >::underlying_type, \fBdecibel_scale\fP >"
.br
.RI "\fIAddition for convertible \fBunit_t\fP types with a \fBdecibel_scale\fP\&. \fP"
.ti -1c
.RI "template<class UnitTypeLhs , typename std::enable_if< traits::has_decibel_scale< UnitTypeLhs >::value &&!traits::is_scalar_unit< UnitTypeLhs >::value, int >::type  = 0> UnitTypeLhs \fBoperator+\fP (const UnitTypeLhs &lhs, const \fBdimensionless::dB_t\fP &rhs)"
.br
.RI "\fIAddition between \fBunit_t\fP types with a \fBdecibel_scale\fP and dimensionless dB units\&. \fP"
.ti -1c
.RI "template<class UnitTypeRhs , typename std::enable_if< traits::has_decibel_scale< UnitTypeRhs >::value &&!traits::is_scalar_unit< UnitTypeRhs >::value, int >::type  = 0> UnitTypeRhs \fBoperator+\fP (const \fBdimensionless::dB_t\fP &lhs, const UnitTypeRhs &rhs)"
.br
.RI "\fIAddition between \fBunit_t\fP types with a \fBdecibel_scale\fP and dimensionless dB units\&. \fP"
.ti -1c
.RI "template<class UnitTypeLhs , class UnitTypeRhs , typename std::enable_if< traits::has_decibel_scale< UnitTypeLhs, UnitTypeRhs >::value, int >::type  = 0> auto \fBoperator-\fP (const UnitTypeLhs &lhs, const UnitTypeRhs &rhs) -> \fBunit_t\fP< \fBcompound_unit\fP< typename \fBtraits::unit_t_traits\fP< UnitTypeLhs >::unit_type, \fBinverse\fP< typename \fBtraits::unit_t_traits\fP< UnitTypeRhs >::unit_type >>, typename \fBtraits::unit_t_traits\fP< UnitTypeLhs >::underlying_type, \fBdecibel_scale\fP >"
.br
.RI "\fISubtraction for convertible \fBunit_t\fP types with a \fBdecibel_scale\fP\&. \fP"
.ti -1c
.RI "template<class UnitTypeLhs , typename std::enable_if< traits::has_decibel_scale< UnitTypeLhs >::value &&!traits::is_scalar_unit< UnitTypeLhs >::value, int >::type  = 0> UnitTypeLhs \fBoperator-\fP (const UnitTypeLhs &lhs, const \fBdimensionless::dB_t\fP &rhs)"
.br
.RI "\fISubtraction between \fBunit_t\fP types with a \fBdecibel_scale\fP and dimensionless dB units\&. \fP"
.ti -1c
.RI "template<class UnitTypeRhs , typename std::enable_if< traits::has_decibel_scale< UnitTypeRhs >::value &&!traits::is_scalar_unit< UnitTypeRhs >::value, int >::type  = 0> auto \fBoperator-\fP (const \fBdimensionless::dB_t\fP &lhs, const UnitTypeRhs &rhs) -> \fBunit_t\fP< \fBinverse\fP< typename \fBtraits::unit_t_traits\fP< UnitTypeRhs >::unit_type >, typename \fBtraits::unit_t_traits\fP< UnitTypeRhs >::underlying_type, \fBdecibel_scale\fP >"
.br
.RI "\fISubtraction between \fBunit_t\fP types with a \fBdecibel_scale\fP and dimensionless dB units\&. \fP"
.in -1c
.SH "Detailed Description"
.PP 
Unit Conversion Library namespace\&. 
.SH "Function Documentation"
.PP 
.SS "template<class UnitTypeLhs , class UnitTypeRhs , typename std::enable_if< traits::is_convertible_unit_t< UnitTypeLhs, UnitTypeRhs >::value &&traits::has_linear_scale< UnitTypeLhs, UnitTypeRhs >::value, int >::type  = 0> auto units::operator* (const UnitTypeLhs & lhs, const UnitTypeRhs & rhs) -> \fBunit_t\fP<\fBcompound_unit\fP<\fBsquared\fP<typename \fBtraits::unit_t_traits\fP<UnitTypeLhs>::unit_type>>>
	\fC [inline]\fP"

.PP
Multiplication type for convertible \fBunit_t\fP types with a linear scale\&. 
.PP
\fBReturns:\fP
.RS 4
the multiplied value, with the same type as left-hand side unit\&.
.PP
the multiplied value, whose type is a compound unit of the left and right hand side values\&. 
.RE
.PP

.SS "template<class UnitTypeLhs , class UnitTypeRhs , typename std::enable_if< traits::is_convertible_unit_t< UnitTypeLhs, UnitTypeRhs >::value &&traits::has_linear_scale< UnitTypeLhs, UnitTypeRhs >::value, int >::type  = 0> \fBdimensionless::scalar_t\fP units::operator/ (const UnitTypeLhs & lhs, const UnitTypeRhs & rhs)\fC [inline]\fP"

.PP
Division for convertible \fBunit_t\fP types with a linear scale\&. 
.PP
\fBReturns:\fP
.RS 4
the lhs divided by rhs value, whose type is a scalar 
.RE
.PP

.SS "template<class UnitTypeLhs , class UnitTypeRhs , typename std::enable_if<!traits::is_convertible_unit_t< UnitTypeLhs, UnitTypeRhs >::value &&traits::has_linear_scale< UnitTypeLhs, UnitTypeRhs >::value, int >::type  = 0> auto units::operator/ (const UnitTypeLhs & lhs, const UnitTypeRhs & rhs) -> \fBunit_t\fP<\fBcompound_unit\fP<typename \fBtraits::unit_t_traits\fP<UnitTypeLhs>::unit_type, \fBinverse\fP<typename \fBtraits::unit_t_traits\fP<UnitTypeRhs>::unit_type>>>
	\fC [inline]\fP"

.PP
Division for non-convertible \fBunit_t\fP types with a linear scale\&. 
.PP
\fBReturns:\fP
.RS 4
the lhs divided by the rhs, with a compound unit type of lhs/rhs 
.RE
.PP

.SH "Author"
.PP 
Generated automatically by Doxygen for Unit Conversion and Dimensional Analysis Library from the source code\&.
