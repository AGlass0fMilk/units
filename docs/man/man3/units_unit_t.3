.TH "units::unit_t< Units, T, NonLinearScale >" 3 "Sun Apr 3 2016" "Version 2.0.0" "Unit Conversion and Dimensional Analysis Library" \" -*- nroff -*-
.ad l
.nh
.SH NAME
units::unit_t< Units, T, NonLinearScale > \- Container for values which represent quantities of a given unit\&.  

.SH SYNOPSIS
.br
.PP
.PP
\fC#include <units\&.h>\fP
.PP
Inherits NonLinearScale< T >, and _unit_t\&.
.SS "Public Types"

.in +1c
.ti -1c
.RI "typedef NonLinearScale< T > \fBnon_linear_scale_type\fP"
.br
.RI "\fIType of the non-linear scale of the \fBunit_t\fP (e\&.g\&. \fBlinear_scale\fP) \fP"
.ti -1c
.RI "typedef T \fBunderlying_type\fP"
.br
.RI "\fIType of the underlying storage of the \fBunit_t\fP (e\&.g\&. double) \fP"
.ti -1c
.RI "typedef Units \fBunit_type\fP"
.br
.RI "\fIType of \fCunit\fP the \fC\fBunit_t\fP\fP represents (e\&.g\&. meters) \fP"
.in -1c
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBunit_t\fP ()"
.br
.RI "\fIdefault constructor\&. \fP"
.ti -1c
.RI "template<class\&.\&.\&. Args> \fBunit_t\fP (const Args &\&.\&.\&.args)"
.br
.RI "\fIconstructor \fP"
.ti -1c
.RI "template<class Ty , class  = typename std::enable_if<std::is_same<traits::base_unit_of<Units>, category::scalar_unit>::value && std::is_arithmetic<Ty>::value>::type> \fBunit_t\fP (Ty value)"
.br
.RI "\fIconstructor \fP"
.ti -1c
.RI "template<class UnitsRhs , typename Ty , template< typename > class NlsRhs> \fBunit_t\fP (const \fBunit_t\fP< UnitsRhs, Ty, NlsRhs > &rhs)"
.br
.RI "\fIcopy constructor \fP"
.ti -1c
.RI "template<class UnitsRhs , typename Ty , template< typename > class NlsRhs> \fBunit_t\fP & \fBoperator=\fP (const \fBunit_t\fP< UnitsRhs, Ty, NlsRhs > &rhs)"
.br
.RI "\fIassignment \fP"
.ti -1c
.RI "template<class Ty , class  = typename std::enable_if<std::is_same<traits::base_unit_of<Units>, category::scalar_unit>::value && std::is_arithmetic<Ty>::value>::type> \fBunit_t\fP & \fBoperator=\fP (Ty rhs)"
.br
.RI "\fIassignment \fP"
.ti -1c
.RI "template<class UnitsRhs , typename Ty , template< typename > class NlsRhs> bool \fBoperator<\fP (const \fBunit_t\fP< UnitsRhs, Ty, NlsRhs > &rhs) const "
.br
.RI "\fIless-than \fP"
.ti -1c
.RI "template<class UnitsRhs , typename Ty , template< typename > class NlsRhs> bool \fBoperator<=\fP (const \fBunit_t\fP< UnitsRhs, Ty, NlsRhs > &rhs) const "
.br
.RI "\fIless-than or equal \fP"
.ti -1c
.RI "template<class UnitsRhs , typename Ty , template< typename > class NlsRhs> bool \fBoperator>\fP (const \fBunit_t\fP< UnitsRhs, Ty, NlsRhs > &rhs) const "
.br
.RI "\fIgreater-than \fP"
.ti -1c
.RI "template<class UnitsRhs , typename Ty , template< typename > class NlsRhs> bool \fBoperator>=\fP (const \fBunit_t\fP< UnitsRhs, Ty, NlsRhs > &rhs) const "
.br
.RI "\fIgreater-than or equal \fP"
.ti -1c
.RI "template<class UnitsRhs , typename Ty , template< typename > class NlsRhs> bool \fBoperator==\fP (const \fBunit_t\fP< UnitsRhs, Ty, NlsRhs > &rhs) const "
.br
.RI "\fIequality \fP"
.ti -1c
.RI "template<class UnitsRhs , typename Ty , template< typename > class NlsRhs> bool \fBoperator!=\fP (const \fBunit_t\fP< UnitsRhs, Ty, NlsRhs > &rhs) const "
.br
.RI "\fIinequality \fP"
.ti -1c
.RI "T \fBtoDouble\fP () const "
.br
.RI "\fIunit value \fP"
.ti -1c
.RI "T \fBtoLinearizedDouble\fP () const "
.br
.RI "\fIlinearized unit value \fP"
.ti -1c
.RI "template<class U > auto \fBconvert\fP () const -> \fBunit_t\fP< U >"
.br
.RI "\fIconversion \fP"
.ti -1c
.RI "template<class Ty , class  = typename std::enable_if<std::is_same<traits::base_unit_of<Units>, category::scalar_unit>::value && std::is_arithmetic<Ty>::value>::type> \fBoperator Ty\fP () const "
.br
.RI "\fIimplicit type conversion\&. \fP"
.in -1c
.SS "Protected Types"

.in +1c
.ti -1c
.RI "using \fBnls\fP = NonLinearScale< T >"
.br
.in -1c
.SS "Friends"

.in +1c
.ti -1c
.RI "template<class U , typename Ty , template< typename > class Nlt> class \fBunit_t\fP"
.br
.in -1c
.SH "Detailed Description"
.PP 

.SS "template<class Units, typename T = double, template< typename > class NonLinearScale = linear_scale>class units::unit_t< Units, T, NonLinearScale >"
Container for values which represent quantities of a given unit\&. 

Stores a value which represents a quantity in the given units\&. Unit containers (except scalar values) are \fInot\fP convertible to built-in c++ types, in order to provide type safety in dimensional analysis\&. Unit containers \fIare\fP implicitely convertible to other compatible unit container types\&. Unit containers support various types of arithmetic operations, depending on their scale type\&.
.PP
The value of a \fC\fBunit_t\fP\fP can only be changed on construction, or by assignment from another \fC\fBunit_t\fP\fP type\&. If necessary, the underlying value can be accessed using \fCoperator()\fP:
.PP
.nf
meter_t m(5\&.0);
double val = m(); // val == 5\&.0 

.fi
.PP
\&. 
.PP
\fBTemplate Parameters:\fP
.RS 4
\fIUnits\fP unit tag for which type of units the \fC\fBunit_t\fP\fP represents (e\&.g\&. meters) 
.br
\fIT\fP underlying type of the storage\&. Defaults to double\&. 
.br
\fINonLinearScale\fP optional scale class for the units\&. Defaults to linear (i\&.e\&. does not scale the unit value)\&. Examples of non-linear scales could be logarithmic, decibel, or richter scales\&. Non-linear scales must adhere to the non-linear-scale concept, i\&.e\&. \fCis_nonlinear_scale<\&.\&.\&.>::value\fP must be \fCtrue\fP\&. 
.RE
.PP
\fBSee also:\fP
.RS 4
.IP "\(bu" 2
\fBlength unit containers\fP
.IP "\(bu" 2
\fBmass unit containers\fP
.IP "\(bu" 2
\fBtime unit containers\fP
.IP "\(bu" 2
\fBangle unit containers\fP
.IP "\(bu" 2
\fBcurrent unit containers\fP
.IP "\(bu" 2
\fBtemperature unit containers\fP
.IP "\(bu" 2
\fBsubstance unit containers\fP
.IP "\(bu" 2
\fBluminous intensity unit containers\fP
.IP "\(bu" 2
\fBsolid angle unit containers\fP
.IP "\(bu" 2
\fBfrequency unit containers\fP
.IP "\(bu" 2
\fBvelocity unit containers\fP
.IP "\(bu" 2
\fBangular velocity unit containers\fP
.IP "\(bu" 2
\fBacceleration unit containers\fP
.IP "\(bu" 2
\fBforce unit containers\fP
.IP "\(bu" 2
\fBpressure unit containers\fP
.IP "\(bu" 2
\fBcharge unit containers\fP
.IP "\(bu" 2
\fBenergy unit containers\fP
.IP "\(bu" 2
\fBpower unit containers\fP
.IP "\(bu" 2
\fBvoltage unit containers\fP
.IP "\(bu" 2
\fBcapacitance unit containers\fP
.IP "\(bu" 2
\fBimpedance unit containers\fP
.IP "\(bu" 2
\fBmagnetic flux unit containers\fP
.IP "\(bu" 2
\fBmagnetic field strength unit containers\fP
.IP "\(bu" 2
\fBinductance unit containers\fP
.IP "\(bu" 2
\fBluminous flux unit containers\fP
.IP "\(bu" 2
\fBilluminance unit containers\fP
.IP "\(bu" 2
\fBradiation unit containers\fP
.IP "\(bu" 2
\fBtorque unit containers\fP
.IP "\(bu" 2
\fBarea unit containers\fP
.IP "\(bu" 2
\fBvolume unit containers\fP
.IP "\(bu" 2
\fBdensity unit containers\fP
.IP "\(bu" 2
\fBconcentration unit containers\fP
.IP "\(bu" 2
\fBconstant unit containers\fP 
.PP
.RE
.PP

.SH "Constructor & Destructor Documentation"
.PP 
.SS "template<class Units, typename T = double, template< typename > class NonLinearScale = linear_scale> template<class\&.\&.\&. Args> \fBunits::unit_t\fP< Units, T, NonLinearScale >::\fBunit_t\fP (const Args &\&.\&.\&. args)\fC [inline]\fP, \fC [explicit]\fP"

.PP
constructor constructs a new \fBunit_t\fP using the non-linear scale's constructor\&. 
.PP
\fBParameters:\fP
.RS 4
\fIargs\fP constructor arguments are forwarded to the non-linear scale constructor\&. Which args are required depends on which scale is used\&. For the default (linear) scale, a single double-type value should be given\&. 
.RE
.PP

.SS "template<class Units, typename T = double, template< typename > class NonLinearScale = linear_scale> template<class Ty , class  = typename std::enable_if<std::is_same<traits::base_unit_of<Units>, category::scalar_unit>::value && std::is_arithmetic<Ty>::value>::type> \fBunits::unit_t\fP< Units, T, NonLinearScale >::\fBunit_t\fP (Ty value)\fC [inline]\fP"

.PP
constructor enable implicit conversions from T types ONLY for linear scalar units 
.PP
\fBParameters:\fP
.RS 4
\fIvalue\fP value of the \fBunit_t\fP 
.RE
.PP

.SS "template<class Units, typename T = double, template< typename > class NonLinearScale = linear_scale> template<class UnitsRhs , typename Ty , template< typename > class NlsRhs> \fBunits::unit_t\fP< Units, T, NonLinearScale >::\fBunit_t\fP (const \fBunit_t\fP< UnitsRhs, Ty, NlsRhs > & rhs)\fC [inline]\fP"

.PP
copy constructor performs implicit unit conversions if required\&. 
.PP
\fBParameters:\fP
.RS 4
\fIrhs\fP unit to copy\&. 
.RE
.PP

.SH "Member Function Documentation"
.PP 
.SS "template<class Units, typename T = double, template< typename > class NonLinearScale = linear_scale> template<class U > auto \fBunits::unit_t\fP< Units, T, NonLinearScale >::convert () const -> \fBunit_t\fP<U>
		\fC [inline]\fP"

.PP
conversion Converts to a different unit container\&. Units can be converted to other containers implicitly, but this can be used in cases where explicit notation of a conversion is beneficial, or where an r-value container is needed\&. 
.PP
\fBTemplate Parameters:\fP
.RS 4
\fIU\fP unit (not \fBunit_t\fP) to convert to 
.RE
.PP
\fBReturns:\fP
.RS 4
a unit container with the specified units containing the equivalent value to *this\&. 
.RE
.PP

.SS "template<class Units, typename T = double, template< typename > class NonLinearScale = linear_scale> template<class Ty , class  = typename std::enable_if<std::is_same<traits::base_unit_of<Units>, category::scalar_unit>::value && std::is_arithmetic<Ty>::value>::type> \fBunits::unit_t\fP< Units, T, NonLinearScale >::operator Ty () const\fC [inline]\fP"

.PP
implicit type conversion\&. only enabled for scalar unit types\&. 
.SS "template<class Units, typename T = double, template< typename > class NonLinearScale = linear_scale> template<class UnitsRhs , typename Ty , template< typename > class NlsRhs> bool \fBunits::unit_t\fP< Units, T, NonLinearScale >::operator!= (const \fBunit_t\fP< UnitsRhs, Ty, NlsRhs > & rhs) const\fC [inline]\fP"

.PP
inequality compares the linearized value of two units\&. Performs unit conversions if necessary\&. 
.PP
\fBParameters:\fP
.RS 4
\fIrhs\fP right-hand side unit for the comparison 
.RE
.PP
\fBReturns:\fP
.RS 4
true IFF the value of \fCthis\fP is not equal to the value of rhs\&. 
.RE
.PP
\fBNote:\fP
.RS 4
This may not be suitable for all applications when the underlying_type of \fBunit_t\fP is a double\&. 
.RE
.PP

.SS "template<class Units, typename T = double, template< typename > class NonLinearScale = linear_scale> template<class UnitsRhs , typename Ty , template< typename > class NlsRhs> bool \fBunits::unit_t\fP< Units, T, NonLinearScale >::operator< (const \fBunit_t\fP< UnitsRhs, Ty, NlsRhs > & rhs) const\fC [inline]\fP"

.PP
less-than compares the linearized value of two units\&. Performs unit conversions if necessary\&. 
.PP
\fBParameters:\fP
.RS 4
\fIrhs\fP right-hand side unit for the comparison 
.RE
.PP
\fBReturns:\fP
.RS 4
true IFF the value of \fCthis\fP is less than the value of \fCrhs\fP 
.RE
.PP

.SS "template<class Units, typename T = double, template< typename > class NonLinearScale = linear_scale> template<class UnitsRhs , typename Ty , template< typename > class NlsRhs> bool \fBunits::unit_t\fP< Units, T, NonLinearScale >::operator<= (const \fBunit_t\fP< UnitsRhs, Ty, NlsRhs > & rhs) const\fC [inline]\fP"

.PP
less-than or equal compares the linearized value of two units\&. Performs unit conversions if necessary\&. 
.PP
\fBParameters:\fP
.RS 4
\fIrhs\fP right-hand side unit for the comparison 
.RE
.PP
\fBReturns:\fP
.RS 4
true IFF the value of \fCthis\fP is less than or equal to the value of \fCrhs\fP 
.RE
.PP

.SS "template<class Units, typename T = double, template< typename > class NonLinearScale = linear_scale> template<class UnitsRhs , typename Ty , template< typename > class NlsRhs> \fBunit_t\fP& \fBunits::unit_t\fP< Units, T, NonLinearScale >::operator= (const \fBunit_t\fP< UnitsRhs, Ty, NlsRhs > & rhs)\fC [inline]\fP"

.PP
assignment performs implicit unit conversions if required 
.PP
\fBParameters:\fP
.RS 4
\fIrhs\fP unit to copy\&. 
.RE
.PP

.SS "template<class Units, typename T = double, template< typename > class NonLinearScale = linear_scale> template<class Ty , class  = typename std::enable_if<std::is_same<traits::base_unit_of<Units>, category::scalar_unit>::value && std::is_arithmetic<Ty>::value>::type> \fBunit_t\fP& \fBunits::unit_t\fP< Units, T, NonLinearScale >::operator= (Ty rhs)\fC [inline]\fP"

.PP
assignment performs implicit conversions from built-in types ONLY for scalar units 
.PP
\fBParameters:\fP
.RS 4
\fIrhs\fP value to copy\&. 
.RE
.PP

.SS "template<class Units, typename T = double, template< typename > class NonLinearScale = linear_scale> template<class UnitsRhs , typename Ty , template< typename > class NlsRhs> bool \fBunits::unit_t\fP< Units, T, NonLinearScale >::operator== (const \fBunit_t\fP< UnitsRhs, Ty, NlsRhs > & rhs) const\fC [inline]\fP"

.PP
equality compares the linearized value of two units\&. Performs unit conversions if necessary\&. 
.PP
\fBParameters:\fP
.RS 4
\fIrhs\fP right-hand side unit for the comparison 
.RE
.PP
\fBReturns:\fP
.RS 4
true IFF the value of \fCthis\fP exactly equal to the value of rhs\&. 
.RE
.PP
\fBNote:\fP
.RS 4
This may not be suitable for all applications when the underlying_type of \fBunit_t\fP is a double\&. 
.RE
.PP

.SS "template<class Units, typename T = double, template< typename > class NonLinearScale = linear_scale> template<class UnitsRhs , typename Ty , template< typename > class NlsRhs> bool \fBunits::unit_t\fP< Units, T, NonLinearScale >::operator> (const \fBunit_t\fP< UnitsRhs, Ty, NlsRhs > & rhs) const\fC [inline]\fP"

.PP
greater-than compares the linearized value of two units\&. Performs unit conversions if necessary\&. 
.PP
\fBParameters:\fP
.RS 4
\fIrhs\fP right-hand side unit for the comparison 
.RE
.PP
\fBReturns:\fP
.RS 4
true IFF the value of \fCthis\fP is greater than the value of \fCrhs\fP 
.RE
.PP

.SS "template<class Units, typename T = double, template< typename > class NonLinearScale = linear_scale> template<class UnitsRhs , typename Ty , template< typename > class NlsRhs> bool \fBunits::unit_t\fP< Units, T, NonLinearScale >::operator>= (const \fBunit_t\fP< UnitsRhs, Ty, NlsRhs > & rhs) const\fC [inline]\fP"

.PP
greater-than or equal compares the linearized value of two units\&. Performs unit conversions if necessary\&. 
.PP
\fBParameters:\fP
.RS 4
\fIrhs\fP right-hand side unit for the comparison 
.RE
.PP
\fBReturns:\fP
.RS 4
true IFF the value of \fCthis\fP is greater than or equal to the value of \fCrhs\fP 
.RE
.PP

.SS "template<class Units, typename T = double, template< typename > class NonLinearScale = linear_scale> T \fBunits::unit_t\fP< Units, T, NonLinearScale >::toDouble () const\fC [inline]\fP"

.PP
unit value 
.PP
\fBReturns:\fP
.RS 4
value of the unit in it's underlying, non-safe type\&. 
.RE
.PP

.SS "template<class Units, typename T = double, template< typename > class NonLinearScale = linear_scale> T \fBunits::unit_t\fP< Units, T, NonLinearScale >::toLinearizedDouble () const\fC [inline]\fP"

.PP
linearized unit value 
.PP
\fBReturns:\fP
.RS 4
linearized value of unit which has a non-linear scale\&. For \fC\fBunit_t\fP\fP types with linear scales, this is equivalent to \fCvalue\fP\&. 
.RE
.PP


.SH "Author"
.PP 
Generated automatically by Doxygen for Unit Conversion and Dimensional Analysis Library from the source code\&.
