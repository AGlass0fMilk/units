{"name":"Units","tagline":"a compile-time, header-only, unit conversion library built on c++14 with no dependencies.","body":"# units\r\na compile-time, header-only, unit conversion library built on c++14 with no dependencies.\r\n\r\nReleases\r\n--------\r\n\r\nv1.2.1 - Bug fixes (#1) and namespace cleanup\r\n\r\nv1.2.0 - Adds angular velocity units. Tested with gcc-4.9.2, msvc2013, msvc2015.\r\n\r\nv1.1.1 - Adds Doxygen and additional type traits. Tested with gcc-4.9.2, msvc2013, msvc2015.\r\n\r\nv1.0.0 - Initial release. Tested with msvc2015\r\n\r\nDescription\r\n-----------\r\n\r\nThe library consists of a single file (include/units.h), plus unit tests. To incorporate the library into your project, simply copy the header into a location in your include path. Use the included CMake project to build the tests and documentation.\r\n\r\nunitTests/main.cpp provides comprehensive examples of how to use the library.\r\n\r\nComplex, recurively-defined conversions are performed in just 5 processor instructions:\r\n\r\n\t\tauto test2 = convert<years, weeks>(2.0);\r\n\t00007FF6D6475ECC  mov         eax,16Dh  \r\n\t00007FF6D6475ED1  xorps       xmm1,xmm1  \r\n\t00007FF6D6475ED4  cvtsi2sd    xmm1,rax  \r\n\t00007FF6D6475ED9  mulsd       xmm1,mmword ptr [__real@4000000000000000 (07FF6D64AFE38h)]  \r\n\t00007FF6D6475EE1  divsd       xmm1,mmword ptr [__real@401c000000000000 (07FF6D64AFE58h)] \r\n\t\tEXPECT_NEAR(104.357143, test2, 5.0e-7);\r\n\t00007FF6D6475EE9  ...\r\n\r\nAn explanation of the instructions can be found at: http://stackoverflow.com/questions/35103741/what-is-the-purpose-of-xorps-on-the-same-register/35103871#35103871\r\n\r\nIn the library, the year to week conversion is defined in terms of\r\nyears -> days -> hours -> minutes -> seconds -> minutes -> hours -> days -> weeks\r\nbut the total conversion ratio is computed at compile-time and the math is optimized to two floating-point operations.\r\n\r\nUnit conversions between equivalent types are optimized away completely, and generate no machine code.\r\n\r\nDefining new units is simple, as they can be recursively defined as ratio of previously-defined units in a way that mimics natural language and is highly readable:\r\n\r\n\tnamespace time\r\n\t{\r\n\t\tusing seconds = unit<std::ratio<1>, category::time_unit>;\r\n\t\tusing minutes = unit<std::ratio<60>, seconds>;\r\n\t\tusing hours = unit<std::ratio<60>, minutes>;\r\n\t\tusing days = unit<std::ratio<24>, hours>;\r\n\t\tusing weeks = unit<std::ratio<7>, days>;\r\n\t\tusing years = unit<std::ratio<365>, days>;\r\n\t}\r\n\r\nCompound units are defined in a similar manner, with additional helper functions for polynomials:\r\n\r\n\tusing acceleration = compound_unit<meters, inverse<squared<seconds>>>;\r\n\t\r\nThe preferred method of conversion is implicitly though the use of unit containers, however unit conversion can be accomplished using `units::convert` for arithmetic types:\r\n\r\n\tdouble val_in = convert<feet, inches>(1.0);\t// val_in == 12.0\r\n\t\r\nFor type-safe conversion, see the next section.\r\n\r\nUnit containers\r\n---------------\r\n\r\nIn addition to providing unit tags to perform conversion, the library also provides container types. Containers are derived from the `unit_t` class, and have the form `[unitname]_t`, e.g. `meter_t`. Containers provide additional advanges over template tag conversions, without any increase in overhead, thanks to the c++ type system.\r\n\r\nUnit containers are defined in terms of the units they represent, the underlying type of the container, and an optional non-linear scale (think decibels or richter scale). For example, `meter_t` would be defined: \r\n\r\n   using meter_t = unit_t<length::meter, double, linear_scale>\r\n\r\nor simply \r\n\r\n    using meter_t = unit_t<length::meter>\r\n\r\nsince the underlying type and scale parameters default to `double` and `linear_scale` respectively. Defifining your own units is simple, and the standard SI prefixes, as well as `inverse`, `squared`, and `cubed` templates are provided to make it even easier.\r\n\r\nUnits of compatible types (e.g length units) can be implicitely converted/assigned to one another. Units (with the exception of dimensionless types) cannot be implicitely converted to/from built-in types. They can be constructed from built-in types, and operator() can be used to retrieve a built-in type value. That said, the user should prefer to operate within the unit type-space as much as is practical. \r\n\r\nUnit containers provide type safety and dimensional analysis for mathematical operations. for instance, the velocity of an object can be calculated:\r\n\r\n    auto objectVelocity = meter_t(100.0) / second_t(2.0);\r\n\r\nThe resulting velocity type will be deduced to be `velocity::meters_per_second` with a value of 50.0. Additionally, if the return type if specified, the type system wll verify that the units are compatible. For example, the following will fail to compile:\r\n\r\n    velocity::meters_per_second objectVelocity = square_meter_t(100.0) / second_t(2.0); // Error: cannot convert.`\r\n\r\nUnit containers can also be used to perform implicit conversions:\r\n\r\n\tsecond_t a;\r\n\tminute_t b(1.0);\r\n\t\r\n\ta = b;\t// a == 60.0\r\n\r\nUnsupported arithmetic, or improper return types will result in compiler errors:\r\n\r\n\tmeter_t a_m(1.0), b_m(2.0), c_m;\r\n\tfoot_t\ta_ft(1.0), b_ft(2.0), c_ft;\r\n\t\r\n\tc_m = a_m + b_m;\t\t\t\t\t\t\t// OK. c == 3m\r\n\tc_ft = a_m + b_m;\t\t\t\t\t\t\t// OK. resulting 3m is converted to ft.\r\n\tauto result = a_m * b_ft;\t\t\t\t\t// OK. result is `meter_t` (left-most unit)\r\n\t\r\n\tc_m = a_m + 5.0;\t\t\t\t\t\t\t// Error. can't add scalars to dimensioned units.\r\n\tc_m = a_m + scalar_t(5.0);\t\t\t\t\t// Error. can't add scalars to dimensioned units.\r\n\tauto result = a_m + square_meter_t(1.0);\t// Error. Incompatible units.\r\n\t\r\n\tauto result = a_m * square_meter_t(1.0);\t// OK. units can always be multiplied. Result is `cubed<meter_t>`.\r\n\tauto result = a_m * scalar_t(1.0); \t\t\t// OK. units can always be multiplied. Result is `meter_t`.\r\n\t\r\nExponentials\r\n------------\r\n\r\nMany functions require units to be raised to some power. This can be accomplished using the units::pow function:\r\n\r\n\t\tsquare_meter_t m2 = units::pow<2>(meter_t(5.0));\t// m2 == 25.0\r\n\t\t\r\nThe only constraint is that the exponential power (given in the template argument) must be known at compile time, so that the type system can deduce the output type.\r\n\r\nNamespaces\r\n----------\r\n\r\nUnit tags and containers are split into separate namespaces to avoid conflicting unit names which represent different physical quantities. The currently defined namespaces are:\r\n\r\n- units::length\r\n- units::mass\r\n- units::time\r\n- units::angle (plane)\r\n- units::current\r\n- units::temperature\r\n- units::substance (amount of, i.e. moles)\r\n- units::luminous_intensity\r\n- units::solid_angle\r\n- units::frequency\r\n- units::velocity\r\n- units::angular_velocity\r\n- units::acceleration\r\n- units::force\r\n- units::pressure\r\n- units::charge\r\n- units::energy\r\n- units::power\r\n- units::voltage\r\n- units::capacitance\r\n- units::impedance\r\n- units::magnetic_flux\r\n- units::magnetic_field_strength\r\n- units::inductance\r\n- units::luminous_flux\r\n- units::illuminance\r\n- units::radiation\r\n- units::torque\r\n- units::area\r\n- units::volume\r\n- units::density\r\n- units::concentration\r\n- units::constants (scalar and non-scalar physical constants like Avagadro's number)\r\n\r\nBuild Instructions\r\n------------------\r\n\r\nThe library itself consists of a single header (include/units.h), and can be included into your project without being built. The unit tests and documentation can be built with CMake. A doxygen installation is required to generate the documentation, and a Tex install is needed if pdf documentation is desired.\r\n\r\nTo build the tests:\r\n\r\n1. create a `build` directory inside or outside of the source tree.\r\n2. from the build directory, call `cmake [relative path to build direcory]`\r\n3. This will generate makefiles or a visual studio solution, depending on your platform. From here the project can be built in the usual platform-specific way.\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}