<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.9.1"/>
<title>Unit Conversion and Dimensional Analysis Library: Main Page</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Unit Conversion and Dimensional Analysis Library
   &#160;<span id="projectnumber">2.0.0</span>
   </div>
   <div id="projectbrief">A compile-time c++14 unit conversion library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.9.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li class="current"><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Unit Conversion and Dimensional Analysis Library Documentation</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>a compile-time, header-only, unit conversion library built on c++14 with no dependencies.</p>
<h2>Latest Release - v2.0.0 </h2>
<p>New features:</p><ul>
<li>Compile-time unit arithmetic via <code>unit_value_t</code></li>
<li>Unit-enabled ports of most <code>&lt;cmath&gt;</code> functions, including c++11 extensions.</li>
<li>Square-root manipulators for <code>unit</code>, <code>unit_t</code>, and <code>unit_value_t</code></li>
<li>Improved documentation</li>
</ul>
<p>Tested on:</p><ul>
<li>gcc -4.9</li>
<li>msvc2013</li>
<li>msvc2015</li>
</ul>
<p><a href="https://github.com/nholthaus/units/releases/tag/v2.0.0" target="_blank">Download units v2.0.0</a></p>
<h2>Documentation </h2>
<p>The full documentation is available *<a href="http://nholthaus.github.io/units">here</a>*.</p>
<h2>Description </h2>
<p>The library consists of a single file (<a class="el" href="units_8h.html" title="Complete implementation of units - a compile-time, header-only, unit conversion library built on c++1...">include/units.h</a>), plus unit tests. To incorporate the library into your project, simply copy the header into a location in your include path. A CMake project is included to build the unit tests and documentation if desired.</p>
<p>The library provides a set of types, containers, and traits to solve dimensional analysis problems, that is, problems involving dimensioned physical quantities. The conversions between units are defined as ratios at compile time, making the library <em>incredibly</em> fast. Additionally, specifying units as <em>types</em>, rather than variable suffixes (or not at all), provides complete type-safety within the compiler. This means that code that accidently misuses units or which has errors in the dimensional analysis <em>will fail at compile-time, not at run-time</em>.</p>
<p>The unit test file <code>unitTests/main.cpp</code> contains example usage of every type, trait, and function contained in the library, and while not exactly user-friendly, can be a valuable resource.</p>
<h2>Unit tags </h2>
<p>Unit tags are the foundation of the unit library. Unit tags are types which are never instantiated in user code, but which provide the meta-information about different units, including how to convert between them, and how to determine their compatibility for conversion.</p>
<p>All unit tags are defined in namespaces under the <code>units</code> namespace, such as <code><a class="el" href="namespaceunits_1_1length.html" title="namespace for unit types and containers representing length values ">units::length</a></code> or <code><a class="el" href="namespaceunits_1_1angle.html" title="namespace for unit types and containers representing angle values ">units::angle</a></code>, to avoid name clashes between units of different physical quantities which share the same names (like pounds). SI base units are defined as "categories" in the <code>unit</code> namespace.</p>
<p>Units are defined in terms of</p><ol type="1">
<li>A scale factor relative to a base unit type.</li>
<li>A base unit</li>
<li>[optionally] a scale factor of <code>pi</code></li>
<li>[optionally] a datum translation (such as the +/- 32 required to convert between <code>fahrenheit</code> and <code>celsius</code>)</li>
</ol>
<p>All units have their origin in the Scientific International (SI) base unit system. A special exception is made for angle units, which are defined in SI as ( m * m^-1), which is not <em>exactly</em> the same as dimensionless/scalar units for practical purposes (and probably why the SI didn't define them as simple scalar units), and so in this library they are treated as a basic unit type.</p>
<p><em>Example</em>: the defintions of some common length units are: </p><pre class="fragment">namespace length
{
    using meters = units::unit&lt;std::ratio&lt;1&gt;, units::category::length_unit&gt;;    // meters are (1) unit of length in the SI system.
    using feet = units::unit&lt;std::ratio&lt;381, 1250&gt;, meters&gt;;                    // feet are 3.28084 meters.
}
</pre><h2>Unit containers </h2>
<p>Unit containers are the workhorse of the units libary, and the primary classes which will be instantiated in user code. Containers are derived from the <code>unit_t</code> class, and have the form <code>[unitname]_t</code>, e.g. <code>meter_t</code> or <code>radian_t</code>. Containers are effectively doubles with associated unit type tags, and can be used wherever a double would be used to store a dimensioned quantity.</p>
<p>Unit containers are defined in terms of the units they represent, their underlying type, and an optional non-linear scale (think decibels or richter scale). For example, <code>meter_t</code> would be defined: </p><pre class="fragment">using meter_t = units::unit_t&lt;units::length::meter, double, units::linear_scale&gt;
</pre><p>or simply </p><pre class="fragment">using meter_t = units::unit_t&lt;units::length::meter&gt;
</pre><p>since the underlying type and scale parameters default to <code>double</code> and <code>linear_scale</code> respectively.</p>
<p>Units of compatible types (e.g length units) can be implicitely converted/assigned to one another. Units (with the exception of dimensionless types) cannot be implicitely converted to/from built-in types, such as <code>double</code>.</p>
<p>Units are constructed from built-in types, and the <code>toDouble()</code> method (or <code>operator()</code>) can be used to retrieve a built-in type value. That said, the user should prefer to operate within the unit type-space as much as is practical, and wrappers of most <code>&lt;cmath&gt;</code> functions are provided to enable operating soly in the <code>unit_t</code> domain.</p>
<p>The primary purpose of unit containers is to provide type safety and dimensional analysis for mathematical operations. for instance, the velocity of an object can be calculated: </p><pre class="fragment">auto objectVelocity = units::meter_t(100.0) / units::second_t(2.0);
</pre><p>The resulting velocity type will be deduced to be <code>velocity::meters_per_second</code> with a value of 50.0. Additionally, if the return type if specified, the type system wll verify that the units are compatible. For example, the following will fail to compile: </p><pre class="fragment">units::velocity::meters_per_second objectVelocity = units::square_meter_t(100.0) / units::second_t(2.0); // Error: Unit types are not compatible.`
</pre><p>Unit containers can (and should!) be used to perform implicit conversions: </p><pre class="fragment">units::time::second_t a;
units::time::minute_t b(1.0);

a = b;  // a == 60.0
</pre><p>Arithmetic can be performed on unit containers the same way it can for built-in types. However, unlike built-in types, the return value of unit-type arithmetic will be the proper unit to represent the resulting quantity. </p><pre class="fragment">using namespace units::length;
using namespace units::area;

meter_t a_m(1.0), b_m(2.0), c_m;
foot_t  a_ft(1.0), b_ft(2.0), c_ft;

c_m = a_m + b_m;                            // OK. c == 3m
c_ft = a_m + b_m;                           // OK. resulting 3m is converted to ft.
auto result = a_m * b_ft;                   // OK. result is `meter_t` (left-most unit)

auto result_sm = a_m * b_m;                 // OK. result_sm is `square_meter_t`.
auto result_s = a_m / b_m;                  // OK. result_s is `dimensionless_t`.
auto result = a_m * b_ft;                   // OK. result is `square_meter_t` (left-most unit)

auto result = a_m * square_meter_t(1.0);    // OK. units can always be multiplied. Result is `cubed&lt;meter_t&gt;`.
auto result = a_m * scalar_t(1.0);          // OK. units can always be multiplied. Result is `meter_t`.
</pre><p>Unsupported arithmetic, or improper return types will result in compiler errors: </p><pre class="fragment">c_m = a_m + 5.0;                            // Error. can't add scalars to dimensioned units.
c_m = a_m + scalar_t(5.0);                  // Error. can't add scalars to dimensioned units.
auto result = a_m + square_meter_t(1.0);    // Error. Incompatible units.
</pre><p>By providing explicit return types for unit functions, the compiler can be used to verify the accuracy of the dimensional analysis, and thus avoiding costly errors.</p>
<h2><code>&lt;cmath&gt;</code> Functions </h2>
<p>The <code>units</code> library include type-safe unit_t container wrappers for almost all of the &lt;cmath&gt; functions, <em>including</em> the c++11 extensions. These functions can be found in the <code><a class="el" href="namespaceunits_1_1math.html" title="namespace for unit-enabled versions of the <cmath> library ">units::math</a></code> namespace. The <code>units</code> library versions don't conflict with &lt;cmath&gt;, and it's possible to use both libraries in the same code.</p>
<p>The overloaded functions ensure that only the proper unit types are accepted into the functions, and that the return value type matches the expected units, all without needing to result to the type-unsafe <code>toDouble()</code> member.</p>
<p>In <em>rare</em> cases, the overload resolution for a given type may be ambiguous. If so, simply preprend the function with the fully-qualified <code><a class="el" href="namespaceunits_1_1math.html" title="namespace for unit-enabled versions of the <cmath> library ">units::math</a></code> prefix, e.g. </p><pre class="fragment">meter_t x(2.0);
meter_t y(3.0);
square_meter_t z(1.0);
square_meter_t result;

result = fma(x, y, z);                                              // Error: ambiguous
double result = fma(x.toDouble(), y.toDouble(), z.toDouble());      // Warning: Unsafe!
result = math::fma(x, y, z);                                        // OK.
</pre><h2>Exponentials and Square Roots </h2>
<p>Many functions require units to be raised to some power. This can be accomplished using the <code><a class="el" href="namespaceunits_1_1math.html#adf689b7864a5c78a00628574cc8dca6b" title="computes the value of value raised to the power ">units::math::pow</a></code> function: </p><pre class="fragment">square_meter_t m2 = units::math::pow&lt;2&gt;(meter_t(5.0));  // m2 == 25.0
</pre><p>The only constraint is that the exponential power (given in the template argument) must be known at compile time, so that the type system can deduce the output type. This differs from the <code>&lt;cmath&gt; pow</code> implementation, which takes exponent values at runtime.</p>
<p>Square roots are also provided with the <code><a class="el" href="group___unit_math.html#gabfa4684a203331f788cf8294fdc25c7a" title="computes the square root of value ">units::math::sqrt</a></code> function. Due to the nature of the <code>sqrt</code> operation, the units library can often provide exact conversions for square root operations, but <em>not in every case</em>. The rest of the time, the <code>sqrt</code> unit will be a <em>rational_approximation</em> of the real value. These are guaranteed to be accurate to at least 10 decimal places. </p><pre class="fragment">meter_t m = units::math::sqrt(square_meter_t(4.0));     // m == 2.0
</pre><h2>Efficiency </h2>
<p>Complex, recurively-defined conversions are performed in just 5 instructions: </p><pre class="fragment">    year_t twoYears(2.0);
    week_t twoYearsInWeeks = twoYears;
00007FF7BDB57FF6  xorps       xmm9,xmm9  
00007FF7BDB57FFA  cvtsi2sd    xmm9,rax  
00007FF7BDB57FFF  mulsd       xmm9,mmword ptr [__real@4000000000000000 (07FF7BDBB31A0h)]  
00007FF7BDB58008  divsd       xmm9,mmword ptr [__real@401c000000000000 (07FF7BDBB33C0h)]  
00007FF7BDB58011  movsd       mmword ptr [rbp+6Fh],xmm9  
    EXPECT_EQ(week_t(104.286), twoYearsInWeeks);
00007FF7BDB58017  ...
</pre><p>In the library, the year to week conversion is defined in terms of <code>years -&gt; days -&gt; hours -&gt; minutes -&gt; seconds -&gt; minutes -&gt; hours -&gt; days -&gt; weeks</code> but the total conversion ratio is computed at compile-time and the math is optimized to two floating-point operations.</p>
<p>Unit conversions between equivalent types are optimized away completely, and generate <em>no machine code</em>.</p>
<h2>Compile-time Unit Manipulation </h2>
<p>In many cases, unit equations are used to determine derived values from a set of values which are known at comile-time. In these situations, it would be optimal to pre-compute the derived values <em>at compile time</em>, thus generating no machine code and incurring no run-time penalty.</p>
<p>The <code>unit_value_t</code> class is the mechanism in the units library to perform compule-time arithmetic. The <code>unit_value_t</code> class functions exactly the same way as <code>std::ratio</code>, but with an associated unit tag and the ensuing type safety.</p>
<p>For a simple example, let's define a right triangle whose hypotnuse is the sum of the squares of its side (a pythagorean triple) </p><pre class="fragment">struct RightTriangle
{
    using a = unit_value_t&lt;meters, 3&gt;;
    using b = unit_value_t&lt;meters, 4&gt;;
    using c = unit_value_sqrt&lt;unit_value_add&lt;unit_value_power&lt;a, 2&gt;, unit_value_power&lt;b, 2&gt;&gt;&gt;;
};
</pre><p>The definition above is perfectly efficient, as it generates <em>no run-time code</em> whatsoever, and still provides all the type safety of unit containers. The values of <code>a</code>, <code>b</code>, and <code>c</code> can be accessed at runtime using the static <code>value()</code> method of <code>unit_value_t</code> </p><pre class="fragment">auto a = RightTriangle::a::value(); // a is `meter_t(3)`
auto b = RightTriangle::b::value(); // b is `meter_t(4)`
auto c = RightTriangle::c::value(); // c is `meter_t(5)`
</pre><p>The available compile-time operations are:</p><ul>
<li><code><a class="el" href="structunits_1_1unit__value__add.html" title="adds two unit_value_t types at compile-time ">units::unit_value_add</a></code></li>
<li><code><a class="el" href="structunits_1_1unit__value__subtract.html" title="subtracts two unit_value_t types at compile-time ">units::unit_value_subtract</a></code></li>
<li><code><a class="el" href="structunits_1_1unit__value__multiply.html" title="multiplies two unit_value_t types at compile-time ">units::unit_value_multiply</a></code></li>
<li><code><a class="el" href="structunits_1_1unit__value__divide.html" title="divides two unit_value_t types at compile-time ">units::unit_value_divide</a></code></li>
<li><code><a class="el" href="structunits_1_1unit__value__power.html" title="raises unit_value_to a power at compile-time ">units::unit_value_power</a></code></li>
<li><code><a class="el" href="structunits_1_1unit__value__sqrt.html" title="calculates square root of unit_value_t at compile-time ">units::unit_value_sqrt</a></code></li>
</ul>
<h2>Conversion without unit containers </h2>
<p>The preferred method of conversion is implicitly though the use of unit containers, however unit conversion can be accomplished using <code><a class="el" href="group___conversion.html#gae7541dbcd66420e011c82ac58ef7723c" title="converts a value from one type to another. ">units::convert</a></code> for arithmetic types: </p><pre class="fragment">double val_in = convert&lt;feet, inches&gt;(1.0); // val_in == 12.0
</pre><p>For type-safe conversion, prefer implicit conversion via unit_t type containers..</p>
<h2>Namespaces </h2>
<p>Unit tags and containers are split into separate namespaces to avoid conflicting unit names which represent different physical quantities.</p>
<p>Unit tag and unit_t container definitions are defined in the following namespaces:</p><ul>
<li><a class="el" href="namespaceunits_1_1length.html" title="namespace for unit types and containers representing length values ">units::length</a></li>
<li><a class="el" href="namespaceunits_1_1mass.html" title="namespace for unit types and containers representing mass values ">units::mass</a></li>
<li><a class="el" href="namespaceunits_1_1time.html" title="namespace for unit types and containers representing time values ">units::time</a></li>
<li><a class="el" href="namespaceunits_1_1angle.html" title="namespace for unit types and containers representing angle values ">units::angle</a> (plane)</li>
<li><a class="el" href="namespaceunits_1_1current.html" title="namespace for unit types and containers representing current values ">units::current</a></li>
<li><a class="el" href="namespaceunits_1_1temperature.html" title="namespace for unit types and containers representing temperature values ">units::temperature</a></li>
<li><a class="el" href="namespaceunits_1_1substance.html" title="namespace for unit types and containers representing substance values ">units::substance</a> (amount of, i.e. moles)</li>
<li><a class="el" href="namespaceunits_1_1luminous__intensity.html" title="namespace for unit types and containers representing luminous_intensity values ">units::luminous_intensity</a></li>
<li><a class="el" href="namespaceunits_1_1solid__angle.html" title="namespace for unit types and containers representing solid_angle values ">units::solid_angle</a></li>
<li><a class="el" href="namespaceunits_1_1frequency.html" title="namespace for unit types and containers representing frequency values ">units::frequency</a></li>
<li><a class="el" href="namespaceunits_1_1velocity.html" title="namespace for unit types and containers representing velocity values ">units::velocity</a></li>
<li><a class="el" href="namespaceunits_1_1angular__velocity.html" title="namespace for unit types and containers representing angular velocity values ">units::angular_velocity</a></li>
<li><a class="el" href="namespaceunits_1_1acceleration.html" title="namespace for unit types and containers representing acceleration values ">units::acceleration</a></li>
<li><a class="el" href="namespaceunits_1_1force.html" title="namespace for unit types and containers representing force values ">units::force</a></li>
<li><a class="el" href="namespaceunits_1_1pressure.html" title="namespace for unit types and containers representing pressure values ">units::pressure</a></li>
<li><a class="el" href="namespaceunits_1_1charge.html" title="namespace for unit types and containers representing charge values ">units::charge</a></li>
<li><a class="el" href="namespaceunits_1_1energy.html" title="namespace for unit types and containers representing energy values ">units::energy</a></li>
<li><a class="el" href="namespaceunits_1_1power.html" title="namespace for unit types and containers representing power values ">units::power</a></li>
<li><a class="el" href="namespaceunits_1_1voltage.html" title="namespace for unit types and containers representing voltage values ">units::voltage</a></li>
<li><a class="el" href="namespaceunits_1_1capacitance.html" title="namespace for unit types and containers representing capacitance values ">units::capacitance</a></li>
<li><a class="el" href="namespaceunits_1_1impedance.html" title="namespace for unit types and containers representing impedance values ">units::impedance</a></li>
<li><a class="el" href="namespaceunits_1_1magnetic__flux.html" title="namespace for unit types and containers representing magnetic_flux values ">units::magnetic_flux</a></li>
<li><a class="el" href="namespaceunits_1_1magnetic__field__strength.html" title="namespace for unit types and containers representing magnetic_field_strength values ...">units::magnetic_field_strength</a></li>
<li><a class="el" href="namespaceunits_1_1inductance.html" title="namespace for unit types and containers representing inductance values ">units::inductance</a></li>
<li><a class="el" href="namespaceunits_1_1luminous__flux.html" title="namespace for unit types and containers representing luminous_flux values ">units::luminous_flux</a></li>
<li><a class="el" href="namespaceunits_1_1illuminance.html" title="namespace for unit types and containers representing illuminance values ">units::illuminance</a></li>
<li><a class="el" href="namespaceunits_1_1radiation.html" title="namespace for unit types and containers representing radiation values ">units::radiation</a></li>
<li><a class="el" href="namespaceunits_1_1torque.html" title="namespace for unit types and containers representing torque values ">units::torque</a></li>
<li><a class="el" href="namespaceunits_1_1area.html" title="namespace for unit types and containers representing area values ">units::area</a></li>
<li><a class="el" href="namespaceunits_1_1volume.html" title="namespace for unit types and containers representing volume values ">units::volume</a></li>
<li><a class="el" href="namespaceunits_1_1density.html" title="namespace for unit types and containers representing density values ">units::density</a></li>
<li><a class="el" href="namespaceunits_1_1concentration.html" title="namespace for unit types and containers representing concentration values ">units::concentration</a></li>
<li><a class="el" href="namespaceunits_1_1constants.html" title="namespace for physical constants like PI and Avogadro&#39;s Number. ">units::constants</a> (scalar and non-scalar physical constants like Avagadro's number)</li>
</ul>
<p>Mathematical operations like <code>sin</code>, <code>log</code>, <code>floor</code>, etc are defined in the following namespaces:</p><ul>
<li><a class="el" href="namespaceunits_1_1math.html" title="namespace for unit-enabled versions of the <cmath> library ">units::math</a></li>
</ul>
<p>Type traits that you can use to test unit types are defined in the following namespaces:</p><ul>
<li><a class="el" href="namespaceunits_1_1traits.html" title="namespace representing type traits which can access the properties of types provided by the units lib...">units::traits</a></li>
</ul>
<h2>Defining new units </h2>
<p>The units library strives to provide built-in types for every conceievable unit, and before defing your own units you should double-check the namespaces to make sure it's not already included. That said, if you need to roll your own units, the library is extensible by design.</p>
<p>Defining new units is simple, as they can be recursively defined as ratio of previously-defined units in a way that mimics natural language and is highly readable: </p><pre class="fragment">namespace time
{
    using seconds = units::unit&lt;std::ratio&lt;1&gt;,   units::category::time_unit&gt;;
    using minutes = units::unit&lt;std::ratio&lt;60&gt;,  seconds&gt;;
    using hours   = units::unit&lt;std::ratio&lt;60&gt;,  minutes&gt;;
    using days    = units::unit&lt;std::ratio&lt;24&gt;,  hours&gt;;
    using weeks   = units::unit&lt;std::ratio&lt;7&gt;,   days&gt;;
    using years   = units::unit&lt;std::ratio&lt;365&gt;, days&gt;;
}
</pre><p>Units are defined in the form: <code>using [unit] = unit&lt;std::ratio&lt;[number of base units per unit]&gt;, [base unit]&gt;;</code>, where:</p><ul>
<li>the <code>[unit]</code> is what you are defining.</li>
<li>the <code>[base unit]</code> is the unit that <code>[unit]</code> will be defined in terms of, and</li>
<li>the <code>[number of base units per unit]</code> is the conversion ratio between the two, expressed as a <code>std::ratio</code> type.</li>
</ul>
<p>Compound units are defined in a similar manner, with additional helper functions for polynomials: </p><pre class="fragment">using acceleration = compound_unit&lt;meters, inverse&lt;squared&lt;seconds&gt;&gt;&gt;;      // (m / s^2)
</pre><p>The available helpers are:</p><ul>
<li><code><a class="el" href="group___unit_manipulators.html#gaacc539ef162e24b260d023d3ff949b57" title="represents the inverse unit type of class U. ">units::inverse</a>&lt;...&gt;</code> (inverts the unit, e.g. meters becomes meters^-1, or 1 / meters)</li>
<li><code><a class="el" href="group___unit_manipulators.html#ga636346f7898c35eb98a796bec1d77fb2" title="represents the unit type of class U squared ">units::squared</a>&lt;...&gt;</code> (squares the unit, e.g. meters becomes meters^2)</li>
<li><code><a class="el" href="group___unit_manipulators.html#gad3e94dc693fe45a580b382cb666434a1" title="represents the type of class U cubed. ">units::cubed</a>&lt;...&gt;</code> (cubes the unit, e.g. meters becomes meters^3)</li>
<li><code><a class="el" href="group___unit_manipulators.html#ga66c5d3d0e80c7c3e56683d7df366b380" title="represents the square root of type class U. ">units::square_root</a>&lt;...&gt;</code> (takes the square root of the unit, e.g meters^2 becomes meters)</li>
<li><code><a class="el" href="group___unit_manipulators.html#ga8a7180c782263384a118dc8ffa5bc689" title="Represents the type of class U with the metric &#39;atto&#39; prefix appended. ">units::atto</a>&lt;...&gt;</code> through <code><a class="el" href="group___unit_manipulators.html#gad0c18c5a47e0fe677715f0328f818515" title="Represents the type of class U with the metric &#39;peta&#39; prefix appended. ">units::exa</a>&lt;...&gt;</code> metric prefixes</li>
</ul>
<h2>Unit Type Traits </h2>
<p>The units library provides a comprehensive set of type-traits, which can be used in templated user code to enforce that the unit types have certain properties.</p>
<p>For example, let's say you want to write a function that validates that the square footage of an office (given in any units), meets the minimum size required by local ordinance. </p><pre class="fragment">template&lt;typename Units&gt;
bool isMinimumSize(Units x)
{
    return x &gt;= square_feet_t(80.0);
}
</pre><p>This function will fail to compile if <code>Units</code> is not a unit of area (since incompatible unit types are not comparable), but it will produce a series difficult-to-understand tempalte errors. Type traits could be used to make the error message more friendly: </p><pre class="fragment">template&lt;typename Units&gt;
bool isMinimumSize(Units x)
{
    static_assert(units::traits::is_area_unit&lt;Units&gt;::value, "Input value x must represent an area quantity.");
    return x &gt;= square_feet_t(80.0);
}
</pre><p>See the <code><a class="el" href="namespaceunits_1_1traits.html" title="namespace representing type traits which can access the properties of types provided by the units lib...">units::traits</a></code> namespace for a list of all the suported traits.</p>
<h2>Build Instructions </h2>
<p>The library itself consists of a single header (<a class="el" href="units_8h.html" title="Complete implementation of units - a compile-time, header-only, unit conversion library built on c++1...">include/units.h</a>), and can be included into your project without being built.</p>
<p>The unit tests and documentation can be built with CMake. A doxygen installation is required to generate the documentation, and a Tex install is needed if pdf documentation is desired.</p>
<p>To build the tests:</p>
<p>Windows:</p><ol type="1">
<li>Ensure cmake is installed, and that the <code>bin</code> directory is in your PATH% variable, and that a compiler like <code>Visual Studio 2015 Community Edition</code> is installed.</li>
<li>clone the repository or download the <code>.zip</code> package.</li>
<li>Open a <code>cmd</code> terminal and navigate to the source directory.</li>
<li>Type the following commands:<ul>
<li><code>md build</code></li>
<li><code>cd build</code></li>
<li><code>cmake -Wno-dev ..</code></li>
<li><code>cmake --build . --config Release</code></li>
</ul>
</li>
<li>The tests will be created in an executable called <code>unitLibTest.exe</code> in the folder <code>build/unitTests/Release</code>.</li>
</ol>
<p>Linux:</p><ol type="1">
<li>Ensure you are using cmake 3.2 or later. You can verify this with <code>cmake --version</code>.</li>
<li>Ensure you are using gcc version 4.9 or greater. You can verify this with <code>gcc --version</code>.</li>
<li>clone the repository or download the <code>.tar.gz</code> package.</li>
<li>Open a terminal and navigate to the source directory.</li>
<li>Type the following commands:<ul>
<li><code>mkdir build</code></li>
<li><code>cd build</code></li>
<li><code>cmake -Wno-dev ..</code></li>
<li><code>cmake --build . --config Release</code></li>
</ul>
</li>
<li>The tests will be created in an executable called <code>unitLibTest</code> in the folder <code>build/unitTests</code>.</li>
</ol>
<h2>Previous Releases </h2>
<ul>
<li>v1.3.0 - Adds ostream support. bug fixes. Tested with gcc-4.9.2, msvc2013, msvc2015.</li>
<li>v1.2.2 - Bug fixes (#1) and namespace cleanup. Tested with msvc2015, gcc 5.2.1</li>
<li>v1.2.0 - Adds angular velocity units. Tested with gcc-4.9.2, msvc2013, msvc2015.</li>
<li>v1.1.1 - Adds Doxygen and additional type traits. Tested with gcc-4.9.2, msvc2013, msvc2015.</li>
<li>v1.0.0 - Initial release. Tested with msvc2015 </li>
</ul>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sun Apr 3 2016 13:47:11 for Unit Conversion and Dimensional Analysis Library by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.9.1
</small></address>
</body>
</html>
