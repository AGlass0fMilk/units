<!DOCTYPE html>
<html>

  <head>
    <meta charset='utf-8'>
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <meta name="description" content="Units : a compile-time, header-only, unit conversion library built on c++14 with no dependencies.">

    <link rel="stylesheet" type="text/css" media="screen" href="stylesheets/stylesheet.css">

    <title>Units</title>
  </head>

  <body>

    <!-- HEADER -->
    <div id="header_wrap" class="outer">
        <header class="inner">
          <a id="forkme_banner" href="https://github.com/nholthaus/units">View on GitHub</a>

          <h1 id="project_title">Units</h1>
          <h2 id="project_tagline">a compile-time, header-only, unit conversion library built on c++14 with no dependencies.</h2>

            <section id="downloads">
              <a class="zip_download_link" href="https://github.com/nholthaus/units/zipball/master">Download this project as a .zip file</a>
              <a class="tar_download_link" href="https://github.com/nholthaus/units/tarball/master">Download this project as a tar.gz file</a>
            </section>
        </header>
    </div>

    <!-- MAIN CONTENT -->
    <div id="main_content_wrap" class="outer">
      <section id="main_content" class="inner">
        <h1>
<a id="units" class="anchor" href="#units" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>units</h1>

<p>a compile-time, header-only, unit conversion library built on c++14 with no dependencies.</p>

<h2>
<a id="releases" class="anchor" href="#releases" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Releases</h2>

<p>v1.2.1 - Bug fixes (#1) and namespace cleanup</p>

<p>v1.2.0 - Adds angular velocity units. Tested with gcc-4.9.2, msvc2013, msvc2015.</p>

<p>v1.1.1 - Adds Doxygen and additional type traits. Tested with gcc-4.9.2, msvc2013, msvc2015.</p>

<p>v1.0.0 - Initial release. Tested with msvc2015</p>

<h2>
<a id="description" class="anchor" href="#description" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Description</h2>

<p>The library consists of a single file (include/units.h), plus unit tests. To incorporate the library into your project, simply copy the header into a location in your include path. Use the included CMake project to build the tests and documentation.</p>

<p>unitTests/main.cpp provides comprehensive examples of how to use the library.</p>

<p>Complex, recurively-defined conversions are performed in just 5 processor instructions:</p>

<pre><code>    auto test2 = convert&lt;years, weeks&gt;(2.0);
00007FF6D6475ECC  mov         eax,16Dh  
00007FF6D6475ED1  xorps       xmm1,xmm1  
00007FF6D6475ED4  cvtsi2sd    xmm1,rax  
00007FF6D6475ED9  mulsd       xmm1,mmword ptr [__real@4000000000000000 (07FF6D64AFE38h)]  
00007FF6D6475EE1  divsd       xmm1,mmword ptr [__real@401c000000000000 (07FF6D64AFE58h)] 
    EXPECT_NEAR(104.357143, test2, 5.0e-7);
00007FF6D6475EE9  ...
</code></pre>

<p>An explanation of the instructions can be found at: <a href="http://stackoverflow.com/questions/35103741/what-is-the-purpose-of-xorps-on-the-same-register/35103871#35103871">http://stackoverflow.com/questions/35103741/what-is-the-purpose-of-xorps-on-the-same-register/35103871#35103871</a></p>

<p>In the library, the year to week conversion is defined in terms of
years -&gt; days -&gt; hours -&gt; minutes -&gt; seconds -&gt; minutes -&gt; hours -&gt; days -&gt; weeks
but the total conversion ratio is computed at compile-time and the math is optimized to two floating-point operations.</p>

<p>Unit conversions between equivalent types are optimized away completely, and generate no machine code.</p>

<p>Defining new units is simple, as they can be recursively defined as ratio of previously-defined units in a way that mimics natural language and is highly readable:</p>

<pre><code>namespace time
{
    using seconds = unit&lt;std::ratio&lt;1&gt;, category::time_unit&gt;;
    using minutes = unit&lt;std::ratio&lt;60&gt;, seconds&gt;;
    using hours = unit&lt;std::ratio&lt;60&gt;, minutes&gt;;
    using days = unit&lt;std::ratio&lt;24&gt;, hours&gt;;
    using weeks = unit&lt;std::ratio&lt;7&gt;, days&gt;;
    using years = unit&lt;std::ratio&lt;365&gt;, days&gt;;
}
</code></pre>

<p>Compound units are defined in a similar manner, with additional helper functions for polynomials:</p>

<pre><code>using acceleration = compound_unit&lt;meters, inverse&lt;squared&lt;seconds&gt;&gt;&gt;;
</code></pre>

<p>The preferred method of conversion is implicitly though the use of unit containers, however unit conversion can be accomplished using <code>units::convert</code> for arithmetic types:</p>

<pre><code>double val_in = convert&lt;feet, inches&gt;(1.0); // val_in == 12.0
</code></pre>

<p>For type-safe conversion, see the next section.</p>

<h2>
<a id="unit-containers" class="anchor" href="#unit-containers" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Unit containers</h2>

<p>In addition to providing unit tags to perform conversion, the library also provides container types. Containers are derived from the <code>unit_t</code> class, and have the form <code>[unitname]_t</code>, e.g. <code>meter_t</code>. Containers provide additional advanges over template tag conversions, without any increase in overhead, thanks to the c++ type system.</p>

<p>Unit containers are defined in terms of the units they represent, the underlying type of the container, and an optional non-linear scale (think decibels or richter scale). For example, <code>meter_t</code> would be defined: </p>

<p>using meter_t = unit_t</p>

<p>or simply </p>

<pre><code>using meter_t = unit_t&lt;length::meter&gt;
</code></pre>

<p>since the underlying type and scale parameters default to <code>double</code> and <code>linear_scale</code> respectively. Defifining your own units is simple, and the standard SI prefixes, as well as <code>inverse</code>, <code>squared</code>, and <code>cubed</code> templates are provided to make it even easier.</p>

<p>Units of compatible types (e.g length units) can be implicitely converted/assigned to one another. Units (with the exception of dimensionless types) cannot be implicitely converted to/from built-in types. They can be constructed from built-in types, and operator() can be used to retrieve a built-in type value. That said, the user should prefer to operate within the unit type-space as much as is practical. </p>

<p>Unit containers provide type safety and dimensional analysis for mathematical operations. for instance, the velocity of an object can be calculated:</p>

<pre><code>auto objectVelocity = meter_t(100.0) / second_t(2.0);
</code></pre>

<p>The resulting velocity type will be deduced to be <code>velocity::meters_per_second</code> with a value of 50.0. Additionally, if the return type if specified, the type system wll verify that the units are compatible. For example, the following will fail to compile:</p>

<pre><code>velocity::meters_per_second objectVelocity = square_meter_t(100.0) / second_t(2.0); // Error: cannot convert.`
</code></pre>

<p>Unit containers can also be used to perform implicit conversions:</p>

<pre><code>second_t a;
minute_t b(1.0);

a = b;  // a == 60.0
</code></pre>

<p>Unsupported arithmetic, or improper return types will result in compiler errors:</p>

<pre><code>meter_t a_m(1.0), b_m(2.0), c_m;
foot_t  a_ft(1.0), b_ft(2.0), c_ft;

c_m = a_m + b_m;                            // OK. c == 3m
c_ft = a_m + b_m;                           // OK. resulting 3m is converted to ft.
auto result = a_m * b_ft;                   // OK. result is `meter_t` (left-most unit)

c_m = a_m + 5.0;                            // Error. can't add scalars to dimensioned units.
c_m = a_m + scalar_t(5.0);                  // Error. can't add scalars to dimensioned units.
auto result = a_m + square_meter_t(1.0);    // Error. Incompatible units.

auto result = a_m * square_meter_t(1.0);    // OK. units can always be multiplied. Result is `cubed&lt;meter_t&gt;`.
auto result = a_m * scalar_t(1.0);          // OK. units can always be multiplied. Result is `meter_t`.
</code></pre>

<h2>
<a id="exponentials" class="anchor" href="#exponentials" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Exponentials</h2>

<p>Many functions require units to be raised to some power. This can be accomplished using the units::pow function:</p>

<pre><code>    square_meter_t m2 = units::pow&lt;2&gt;(meter_t(5.0));    // m2 == 25.0
</code></pre>

<p>The only constraint is that the exponential power (given in the template argument) must be known at compile time, so that the type system can deduce the output type.</p>

<h2>
<a id="namespaces" class="anchor" href="#namespaces" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Namespaces</h2>

<p>Unit tags and containers are split into separate namespaces to avoid conflicting unit names which represent different physical quantities. The currently defined namespaces are:</p>

<ul>
<li>units::length</li>
<li>units::mass</li>
<li>units::time</li>
<li>units::angle (plane)</li>
<li>units::current</li>
<li>units::temperature</li>
<li>units::substance (amount of, i.e. moles)</li>
<li>units::luminous_intensity</li>
<li>units::solid_angle</li>
<li>units::frequency</li>
<li>units::velocity</li>
<li>units::angular_velocity</li>
<li>units::acceleration</li>
<li>units::force</li>
<li>units::pressure</li>
<li>units::charge</li>
<li>units::energy</li>
<li>units::power</li>
<li>units::voltage</li>
<li>units::capacitance</li>
<li>units::impedance</li>
<li>units::magnetic_flux</li>
<li>units::magnetic_field_strength</li>
<li>units::inductance</li>
<li>units::luminous_flux</li>
<li>units::illuminance</li>
<li>units::radiation</li>
<li>units::torque</li>
<li>units::area</li>
<li>units::volume</li>
<li>units::density</li>
<li>units::concentration</li>
<li>units::constants (scalar and non-scalar physical constants like Avagadro's number)</li>
</ul>

<h2>
<a id="build-instructions" class="anchor" href="#build-instructions" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Build Instructions</h2>

<p>The library itself consists of a single header (include/units.h), and can be included into your project without being built. The unit tests and documentation can be built with CMake. A doxygen installation is required to generate the documentation, and a Tex install is needed if pdf documentation is desired.</p>

<p>To build the tests:</p>

<ol>
<li>create a <code>build</code> directory inside or outside of the source tree.</li>
<li>from the build directory, call <code>cmake [relative path to build direcory]</code>
</li>
<li>This will generate makefiles or a visual studio solution, depending on your platform. From here the project can be built in the usual platform-specific way.</li>
</ol>
      </section>
    </div>

    <!-- FOOTER  -->
    <div id="footer_wrap" class="outer">
      <footer class="inner">
        <p class="copyright">Units maintained by <a href="https://github.com/nholthaus">nholthaus</a></p>
        <p>Published with <a href="https://pages.github.com">GitHub Pages</a></p>
      </footer>
    </div>

    

  </body>
</html>
