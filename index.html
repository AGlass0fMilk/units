<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Unit Conversion and Dimensional Analysis Library: UNITS</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Unit Conversion and Dimensional Analysis Library
   &#160;<span id="projectnumber">2.3.0</span>
   </div>
   <div id="projectbrief">A compile-time c++14 unit conversion library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">UNITS </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>A compile-time, header-only, dimensional analysis library built on c++14 with no dependencies.</p>
<p><a href="https://travis-ci.org/nholthaus/units"><object type="image/svg+xml" data="https://travis-ci.org/nholthaus/units.svg?branch=master" style="pointer-events: none;">Linux build</object></a> <a href="https://ci.appveyor.com/project/nholthaus/units"><img src="https://ci.appveyor.com/api/projects/status/github/nholthaus/units?svg=true&amp;branch=master" alt="Windows build" class="inline"/></a> <a href="https://coveralls.io/github/nholthaus/units?branch=master"><object type="image/svg+xml" data="https://coveralls.io/repos/github/nholthaus/units/badge.svg?branch=master" style="pointer-events: none;">Coverage Status</object></a> <object type="image/svg+xml" data="https://img.shields.io/badge/license-MIT-orange.svg" style="pointer-events: none;">license</object> <object type="image/svg+xml" data="https://img.shields.io/badge/%C2%A9-Nic_Holthaus-orange.svg" style="pointer-events: none;">copyright</object> <object type="image/svg+xml" data="https://img.shields.io/badge/language-c++-blue.svg" style="pointer-events: none;">language</object> <object type="image/svg+xml" data="https://img.shields.io/badge/std-c++14-blue.svg" style="pointer-events: none;">c++</object><br  />
<object type="image/svg+xml" data="https://img.shields.io/badge/MSVC-2015-ff69b4.svg" style="pointer-events: none;">msvc2015</object> <object type="image/svg+xml" data="https://img.shields.io/badge/MSVC-2017-ff69b4.svg" style="pointer-events: none;">msvc2017</object> <object type="image/svg+xml" data="https://img.shields.io/badge/GCC-4.9.3-ff69b4.svg" style="pointer-events: none;">gcc-4.9.3</object> <object type="image/svg+xml" data="https://img.shields.io/badge/GCC-5.4.0-ff69b4.svg" style="pointer-events: none;">gcc-5.4.0</object> <object type="image/svg+xml" data="https://img.shields.io/badge/CLANG-3.4-ff69b4.svg" style="pointer-events: none;">clang-3.4</object></p>
<h1><a class="anchor" id="autotoc_md1"></a>
Get in touch</h1>
<p>If you are using <code><a class="el" href="units_8h.html" title="Complete implementation of units - a compile-time, header-only, unit conversion library built on c++1...">units.h</a></code> in production code, I'd love to hear from you via GitHub issues!</p>
<h1><a class="anchor" id="autotoc_md2"></a>
Latest Release - v2.3.1</h1>
<h2><a class="anchor" id="autotoc_md3"></a>
Get it</h2>
<p><a href="https://github.com/nholthaus/units/releases/tag/v2.3.1"><object type="image/svg+xml" data="https://img.shields.io/badge/Download-v2.3.1-green.svg" style="pointer-events: none;">DOWNLOAD</object></a></p>
<h2><a class="anchor" id="autotoc_md4"></a>
New in v2.3.1</h2>
<p><b>This version removes support for the Visual Studio 2013 compiler.</b></p>
<p>Features:</p><ul>
<li>units now include constexpr <code>name()</code> and <code>abbreviation()</code> member functions, which do not really on string/iostream.</li>
<li>Builds with VS2017 Ninja generator out of the box</li>
<li>string conversions are now locale aware</li>
<li>added unary increment and decrement operators (<code>++</code>,<code>--</code>), as well as unary <code>+</code> operator.</li>
</ul>
<p>Bug fixs:</p><ul>
<li>fixed compilation error when iostream was disabled</li>
</ul>
<h2><a class="anchor" id="autotoc_md5"></a>
New in v2.3.0</h2>
<p>Features:</p><ul>
<li>5x compile time improvement on MSVC.</li>
<li>1.5x compile time improvement on GCC.</li>
<li>Even more dramatic reductions in compile time can be achieved if you opt-in to specific unit definitions instead of using all the library-defined types (which is the default value). Check out <a href="#enabling-a-subset-of-units-to-improve-compilation-time">Enabling a subset of units to improve compilation time</a> for instructions.</li>
<li>Adds std::cout support for units with no defined abbreviation (they show up as a combination of SI base units)</li>
<li>Support for <code>std::numeric_limits</code> of unit types.</li>
<li>Assignment operators for unit types: <code>-=</code>, <code>+=</code>, <code>/=</code>, <code>*=</code>.</li>
<li>Added <code>min</code> and <code>max</code> overloads for units types in <code><a class="el" href="namespaceunits_1_1math.html" title="namespace for unit-enabled versions of the &lt;cmath&gt; library">units::math</a></code>.</li>
<li>Added <code>to_string</code> function and <code>abbreviation</code> functions: <div class="fragment"><div class="line"><span class="keyword">auto</span> len = 3.5_m;</div>
<div class="line"><span class="keyword">auto</span> str = units::length::to_string(len);</div>
<div class="line"><span class="keyword">auto</span> abv = units::length::abbreviation(len);</div>
<div class="line"> </div>
<div class="line">std::cout &lt;&lt; str;  <span class="comment">// prints &quot;3.5 m&quot;</span></div>
<div class="line">std::cout &lt;&lt; abv;  <span class="comment">// prints &quot;m&quot;</span></div>
</div><!-- fragment --></li>
<li>Added units of data and data transfer: <code>bits</code>, <code>bytes</code>, <code>bits_per_second</code>, and <code>bytes_per_second</code>.</li>
<li>Adds <code>value()</code> member for accessing underlying type.</li>
<li>Adds <code>value_type</code> trait, as a synonym for <code>underlying_type</code>.</li>
<li>Adds definitions for Julian and Gregorian years.</li>
<li>Thanks to @dinocore1, <code>units</code> now supports cmake install and <code>find_packages</code>. From the <a href="https://github.com/nholthaus/units/pull/84">pull request</a>: <div class="fragment"><div class="line"># To have cmake install units library to a local &#39;install&#39; directory:</div>
<div class="line">mkdir build</div>
<div class="line">cd build</div>
<div class="line">cmake -DCMAKE_INSTALL_PREFIX=&quot;install&quot; ..</div>
<div class="line">cmake --build . --target install</div>
<div class="line"># The units library can then be used in some other cmake project using </div>
<div class="line"># the standard &#39;find_package&#39; command. Like so:</div>
<div class="line">find_package(units)</div>
</div><!-- fragment --></li>
</ul>
<p>Bug fixes:</p><ul>
<li>Fixed singular name of <code>siemen</code> to be <code>siemens</code> (Thanks @Oxyd)</li>
<li>Fixed bug with <code>cubrt</code> operation (Thanks @PearCoding)</li>
<li>Fixed constexpr relational operators bug</li>
<li>Fixed exponential temperature conversions (Thanks @guarndt)</li>
</ul>
<h2><a class="anchor" id="autotoc_md6"></a>
Tested on</h2>
<ul>
<li>gcc-4.9.3</li>
<li>gcc-5.4.0</li>
<li>clang-3.4</li>
<li>msvc2015</li>
<li>msvc2017</li>
</ul>
<p>Does this library work on your compiler? If so, let me know!</p>
<h1><a class="anchor" id="autotoc_md7"></a>
Contents</h1>
<ul>
<li><a href="#units">UNITS</a></li>
<li><a href="#get-in-touch">Get in touch</a></li>
<li><a href="#latest-release---v231">Latest Release - v2.3.1</a><ul>
<li><a href="#get-it">Get it</a></li>
<li><a href="#new-in-v231">New in v2.3.1</a></li>
<li><a href="#new-in-v230">New in v2.3.0</a></li>
<li><a href="#tested-on">Tested on</a></li>
</ul>
</li>
<li><a href="#contents">Contents</a></li>
<li><a href="#documentation">Documentation</a></li>
<li><a href="#description">Description</a></li>
<li><a href="#getting-started-guide">Getting started guide</a></li>
<li><a href="#unit-initialization">Unit initialization</a></li>
<li><a href="#unit-tags">Unit tags</a></li>
<li><a href="#unit-containers">Unit containers</a></li>
<li><a href="#unit-literals">Unit Literals</a></li>
<li><a href="#cmath-functions"><code>&lt;cmath&gt;</code> Functions</a></li>
<li><a href="#exponentials-and-square-roots">Exponentials and Square Roots</a></li>
<li><a href="#removing-type-safety">Removing type safety</a></li>
<li><a href="#efficiency">Efficiency</a></li>
<li><a href="#pure-compile-time-unit-manipulation">Pure Compile-time Unit Manipulation</a></li>
<li><a href="#conversion-without-unit-containers">Conversion without unit containers</a></li>
<li><a href="#namespaces">Namespaces</a></li>
<li><a href="#defining-new-units">Defining new units</a></li>
<li><a href="#unit-definition-macros">Unit definition macros</a></li>
<li><a href="#unit-type-traits">Unit Type Traits</a></li>
<li><a href="#changing-the-underlying-type-of-unit_t">Changing the underlying type of <code>unit_t</code></a></li>
<li><a href="#disabling-iostream">Disabling IOStream</a></li>
<li><a href="#enabling-a-subset-of-units-to-improve-compilation-time">Enabling a subset of units to improve compilation time</a></li>
<li><a href="#macro-clashes">Macro clashes</a><ul>
<li><a href="#windows-macros">Windows macros</a></li>
<li><a href="#arm-macros">ARM macros</a></li>
</ul>
</li>
<li><a href="#cmake-instructions">CMake Instructions</a></li>
<li><a href="#build-instructions">Build Instructions</a><ul>
<li><a href="#windows">Windows</a></li>
<li><a href="#linux">Linux</a></li>
</ul>
</li>
<li><a href="#previous-releases">Previous Releases</a></li>
</ul>
<h1><a class="anchor" id="autotoc_md8"></a>
Documentation</h1>
<p><a href="http://nholthaus.github.io/units">The full documentation is available <em><b>here</b></em></a>.</p>
<h1><a class="anchor" id="autotoc_md9"></a>
Description</h1>
<p>The library consists of a single file (<a href="include/units.h">units.h</a>), plus unit tests. To incorporate the library into your project, simply copy the header into a location in your include path, or add the <a href="#cmake-instructions">included CMake project</a> into your build. Using the CMake project, you can also build the unit tests and documentation if desired.</p>
<p>The library provides a set of types, containers, and traits to solve dimensional analysis problems, that is, problems involving dimensioned physical quantities. The conversions between units are defined as ratios at compile time, making the library <em>incredibly</em> fast. Additionally, specifying units as <em>types</em>, rather than variable suffixes (or not at all), provides complete type-safety within the compiler. This means that code that accidentally misuses units or which has errors in the dimensional analysis <em>will fail at compile-time, not at run-time</em>.</p>
<p>The unit test file <code>unitTests/main.cpp</code> contains example usage of every type, trait, and function contained in the library, and while not exactly user-friendly, can be a valuable resource.</p>
<h1><a class="anchor" id="autotoc_md10"></a>
Getting started guide</h1>
<p>Add <code><a class="el" href="units_8h.html" title="Complete implementation of units - a compile-time, header-only, unit conversion library built on c++1...">units.h</a></code> to your project, along with the <code>using</code> directive for literals</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="units_8h.html">units.h</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code" href="namespaceunits_1_1literals.html">units::literals</a>;</div>
</div><!-- fragment --><p>Each "dimension" of unit is defined in its own namespace. See <a href="#namespaces">the namespaces section</a> for a complete list. The rest of the guide assumes you've included the namespaces you plan to use:</p>
<div class="fragment"><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespaceunits.html">units</a>;</div>
<div class="line"><span class="keyword">using namespace </span><a class="code" href="namespaceunits_1_1length.html">units::length</a>;</div>
<div class="line"><span class="keyword">using namespace </span><a class="code" href="namespaceunits_1_1time.html">units::time</a>;</div>
<div class="line"><span class="keyword">using namespace </span><a class="code" href="namespaceunits_1_1area.html">units::area</a>;</div>
<div class="line"><span class="keyword">using namespace </span><a class="code" href="namespaceunits_1_1velocity.html">units::velocity</a>;</div>
</div><!-- fragment --><p><b>The easiest way to get started with the <code>units</code> library is to think of unit containers as <code>double</code> values.</b> Unit containers are typically the units' non-plural name with the suffix <code>_t</code> (for type), e.g. <code>meter_t</code>. See <a href="http://nholthaus.github.io/units/namespaces.html">the documentation</a> for a complete list.</p>
<p>Units can (<em>and should!</em>) be used anywhere <code>double</code> values can be used:</p>
<div class="fragment"><div class="line"><span class="keywordtype">double</span>          area = 15 * 5 + 10 * 10;                <span class="comment">// 175 m^2?</span></div>
<div class="line">square_meter_t  area = 15_m * 5_m + 10_m * 10_m;        <span class="comment">// 175 m^2</span></div>
</div><!-- fragment --><p>What makes unit types special is that unit conversions happen implicitly and automatically. Since unit conversions are evaluated at compile time, this means you can mix and match all the unit types you want with <em>no runtime penalty</em>.</p>
<div class="fragment"><div class="line">foot_t              len   = 5_m;                            <span class="comment">// simple implicit conversion</span></div>
<div class="line">meters_per_second_t speed = 60_mi / 1_hr;                   <span class="comment">// more complex implicit conversion</span></div>
<div class="line">square_meter_t      area  = 15_m * 5_m + 1000_cm * 1000_cm; <span class="comment">// previous example with mixed units</span></div>
</div><!-- fragment --><p>Note the return type has the correct dimensions of area, even though the source types were all units of length. <code><a class="el" href="units_8h.html" title="Complete implementation of units - a compile-time, header-only, unit conversion library built on c++1...">units.h</a></code> has powerful dimensional analysis capabilities. But what happens if we get the return type wrong?</p>
<div class="fragment"><div class="line">meter_t  area = 15_m * 5_m + 10_m * 10_m;               <span class="comment">// oops, m * m = m^2</span></div>
</div><!-- fragment --><blockquote class="doxtable">
<p>E:/workspace/units/include/units.h(1405): error C2338: Units are not compatible. </p>
</blockquote>
<p>Your compiler will produce an "incompatible units" error if your dimensional analysis is incorrect. If your resulting unit types are complex, you could use <code>auto</code> for simplicity:</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> result = 15_m * 5_m + 10_m * 10_m;                 <span class="comment">//  m^2</span></div>
<div class="line"><span class="keyword">auto</span> speed  = 60_mi / 1_hr;                             <span class="comment">//  60 mph</span></div>
</div><!-- fragment --><p><em><b>NOTE: Think carefully about using <code>auto</code> for return types.</b></em> When you explicitly declare the return type, the compiler can check the dimensional analysis for correctness, and produce errors at compile time if you make a mistake. When using <code>auto</code>, you are basically saying that whatever unit the right-hand side of the expression results to is correct (even if it's not). If you are only using <code>auto</code> because a complex unit type is not available in the library, try <a href="#defining-new-units">defining a new unit</a> as a better alternative.</p>
<p>More complex mathematical operations (<a href="http://nholthaus.github.io/units/namespaceunits_1_1math.html">almost every <code>&lt;cmath&gt;</code> operation actually</a>), including exponentials and square roots are possibe by using the <code><a class="el" href="namespaceunits_1_1math.html" title="namespace for unit-enabled versions of the &lt;cmath&gt; library">units::math</a></code> namespace .</p>
<div class="fragment"><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespaceunits_1_1math.html">units::math</a>;</div>
<div class="line"> </div>
<div class="line">meter_t a = 3_m;</div>
<div class="line">meter_t b = 4_m;</div>
<div class="line">meter_t <a class="code" href="namespaceunits_1_1constants.html#acfa211a9904208ac580676b5cc42b04a">c</a> = <a class="code" href="group___unit_math.html#gae52f60a9e2a9e7ad1018a846bcf49140">sqrt</a>(pow&lt;2&gt;(a) + pow&lt;2&gt;(b));    <span class="comment">// Pythagorean threorem.</span></div>
<div class="line"> </div>
<div class="line">std::cout &lt;&lt; <a class="code" href="namespaceunits_1_1constants.html#acfa211a9904208ac580676b5cc42b04a">c</a> &lt;&lt; std::endl;                <span class="comment">// prints: &quot;5 m&quot;</span></div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md11"></a>
Unit initialization</h1>
<p>There are several ways to initialize unit values:</p>
<ul>
<li>Explicit initialization</li>
</ul>
<div class="fragment"><div class="line">meter_t distance_m(10); <span class="comment">// Explicit initialization from double</span></div>
<div class="line">meter_t distance(10_m); <span class="comment">// Explicit initialization from unit literal</span></div>
<div class="line">meter_t dist(100_ft);   <span class="comment">// Explicit initialization from unit literal of a different type</span></div>
</div><!-- fragment --><ul>
<li><code>make_unit&lt;...&gt;()</code> factory. The syntax is familiar to <code>boost::units</code> users, and allows explicit reference to the unit type for member variable initialization.</li>
</ul>
<div class="fragment"><div class="line"><span class="keyword">class </span>myClass</div>
<div class="line">{</div>
<div class="line">  <span class="keyword">public</span>:</div>
<div class="line">    </div>
<div class="line">    myClass() : m_speed(<a class="code" href="group___unit_containers.html#ga1acd69ada7a93c35850717e3c1b4d5fc">make_unit</a>&lt;miles_per_hour_t&gt;(100)) {}</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">private</span>:</div>
<div class="line"> </div>
<div class="line">    miles_per_hour_t m_speed;</div>
<div class="line">};</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md12"></a>
Unit tags</h1>
<p>Unit tags are the foundation of the unit library. Unit tags are types which are never instantiated in user code, but which provide the meta-information about different units, including how to convert between them, and how to determine their compatibility for conversion.</p>
<p>All unit tags are defined in namespaces under the <code>units</code> namespace, such as <code><a class="el" href="namespaceunits_1_1length.html" title="namespace for unit types and containers representing length values">units::length</a></code> or <code><a class="el" href="namespaceunits_1_1angle.html" title="namespace for unit types and containers representing angle values">units::angle</a></code>, to avoid name clashes between units of different physical quantities which share the same names (like pounds). SI base units are defined as "categories" in the <code>unit</code> namespace.</p>
<p>Units are defined in terms of</p><ol type="1">
<li>A scale factor relative to a base unit type.</li>
<li>A base unit</li>
<li>[optionally] a scale factor of <code>pi</code></li>
<li>[optionally] a datum translation (such as the +/- 32 required to convert between <code>fahrenheit</code> and <code>celsius</code>)</li>
</ol>
<p>All units have their origin in the Système International (SI) base unit system. A special exception is made for angle units, which are defined in SI as ( m * m^-1), and in this library they are treated as a basic unit type because of their important engineering applications.</p>
<p><em>Example</em>: the definitions of some common length units are:</p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>length</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">using</span> meters = <a class="code" href="structunits_1_1unit.html">units::unit&lt;std::ratio&lt;1&gt;</a>, <a class="code" href="structunits_1_1base__unit.html">units::category::length_unit</a>&gt;;    <span class="comment">// meters are (1) unit of length in the SI system.</span></div>
<div class="line">    <span class="keyword">using</span> feet = <a class="code" href="structunits_1_1unit.html">units::unit&lt;std::ratio&lt;381, 1250&gt;</a>, meters&gt;;                    <span class="comment">// feet are 0.3048 meters.</span></div>
<div class="line">}</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md13"></a>
Unit containers</h1>
<p>Unit containers are the primary classes which will be instantiated in user code. They can be thought of as essentially equivalent to a <code>double</code>, except that they have unit type tags associated with them. They can be used wherever a double would be used to store a dimensioned quantity. Containers are derived from the <code>unit_t</code> class, and have the form <code>[unitname]_t</code>, e.g. <code>meter_t</code> or <code>radian_t</code>.</p>
<p>Unit containers are defined in terms of the units they represent, their underlying type, and an optional non-linear scale (think decibels or Richter scale). For example, <code>meter_t</code> would be defined:</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> meter_t = <a class="code" href="classunits_1_1unit__t.html">units::unit_t&lt;units::length::meter, double, units::linear_scale&gt;</a></div>
</div><!-- fragment --><p>or simply</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> meter_t = <a class="code" href="classunits_1_1unit__t.html">units::unit_t&lt;units::length::meter&gt;</a></div>
</div><!-- fragment --><p>since the underlying type and scale parameters default to <code>double</code> and <code>linear_scale</code> respectively.</p>
<p>Units of compatible types (e.g length units) can be implicitly converted/assigned to one another. Units (with the exception of dimensionless types) cannot be implicitly converted to/from built-in types, such as <code>double</code>.</p>
<p>Units are constructed from built-in types, and the <code>toDouble()</code> method (or <code>operator()</code>) can be used to retrieve a built-in type value. That said, the user should prefer to operate within the unit type-space as much as is practical, and wrappers of most <code>&lt;cmath&gt;</code> functions are provided to enable operating solely in the <code>unit_t</code> domain.</p>
<p>The primary purpose of unit containers is to provide type safety and dimensional analysis for mathematical operations. for instance, the velocity of an object can be calculated:</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> objectVelocity = meter_t(100.0) / second_t(2.0);</div>
</div><!-- fragment --><p>The resulting velocity type will be deduced to be <code>velocity::meters_per_second</code> with a value of 50.0. Additionally, if the return type if specified, the type system will verify that the units are compatible. For example, the following will fail to compile:</p>
<p>``<code>cpp units::velocity::meters_per_second objectVelocity = square_meter_t(100.0) / second_t(2.0); // Error: Unit types are not compatible.</code> </p><div class="fragment"><div class="line">Unit containers can (and should!) be used to perform implicit conversions:</div>
<div class="line"> </div>
<div class="line">```cpp</div>
<div class="line">units::time::second_t a;</div>
<div class="line">units::time::minute_t b(1.0);</div>
<div class="line"> </div>
<div class="line">a = b;  // a == 60.0</div>
</div><!-- fragment --><p>Arithmetic can be performed on unit containers the same way it can for built-in types. However, unlike built-in types, the return value of unit-type arithmetic will be the proper unit to represent the resulting quantity.</p>
<div class="fragment"><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespaceunits_1_1length.html">units::length</a>;</div>
<div class="line"><span class="keyword">using namespace </span><a class="code" href="namespaceunits_1_1area.html">units::area</a>;</div>
<div class="line"> </div>
<div class="line">meter_t a_m(1.0), b_m(2.0), c_m;</div>
<div class="line"><a class="code" href="classunits_1_1unit__t.html">foot_t</a>  a_ft(1.0), b_ft(2.0), c_ft;</div>
<div class="line"> </div>
<div class="line">c_m = a_m + b_m;                            <span class="comment">// OK. c == 3m</span></div>
<div class="line">c_ft = a_m + b_m;                           <span class="comment">// OK. resulting 3m is converted to ft.</span></div>
<div class="line"><span class="keyword">auto</span> result = a_m + b_ft;                   <span class="comment">// OK. result is `meter_t` (left-most unit)</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> result_sm = a_m * b_m;                 <span class="comment">// OK. result_sm is `square_meter_t`.</span></div>
<div class="line"><span class="keyword">auto</span> result_s = a_m / b_m;                  <span class="comment">// OK. result_s is `dimensionless_t`.</span></div>
<div class="line"><span class="keyword">auto</span> result = a_m * b_ft;                   <span class="comment">// OK. result is `square_meter_t` (left-most unit)</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> result = a_m * <a class="code" href="classunits_1_1unit__t.html">square_meter_t</a>(1.0);    <span class="comment">// OK. units can always be multiplied. Result is `cubed&lt;meter_t&gt;`.</span></div>
<div class="line"><span class="keyword">auto</span> result = a_m * scalar_t(1.0);          <span class="comment">// OK. units can always be multiplied. Result is `meter_t`.</span></div>
</div><!-- fragment --><p>Unsupported arithmetic, or improper return types will result in compiler errors:</p>
<div class="fragment"><div class="line">c_m = a_m + 5.0;                            <span class="comment">// Error. can&#39;t add scalars to dimensioned units.</span></div>
<div class="line">c_m = a_m + scalar_t(5.0);                  <span class="comment">// Error. can&#39;t add scalars to dimensioned units.</span></div>
<div class="line"><span class="keyword">auto</span> result = a_m + square_meter_t(1.0);    <span class="comment">// Error. Incompatible units.</span></div>
</div><!-- fragment --><p>By providing explicit return types for unit functions, the compiler can be used to verify the accuracy of the dimensional analysis, and thus avoiding costly errors.</p>
<h1><a class="anchor" id="autotoc_md14"></a>
Unit Literals</h1>
<p>If you are using a compiler which supports user-defined literals (e.g. not Visual Studio 2013), then unit literals can be a convenient way to initialize and work with unit values:</p>
<div class="fragment"><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespaceunits_1_1literals.html">units::literals</a>;</div>
<div class="line"> </div>
<div class="line">meter_t dist    = 10_m;     <span class="comment">// 10 m</span></div>
<div class="line">meter_t dist2   = 1_km;     <span class="comment">// 1000 m</span></div>
</div><!-- fragment --><p>Literals can also be used for any temporary values in calculations, making them more readable:</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> area = <a class="code" href="classunits_1_1unit__t.html">units::length::meter_t</a>(5) * <a class="code" href="classunits_1_1unit__t.html">units::length::meter_t</a>(10); <span class="comment">// without literals</span></div>
<div class="line"><span class="keyword">auto</span> area = 5_m * 10_m;                         <span class="comment">// with literals</span></div>
</div><!-- fragment --><p>All literals* are defined by their SI abbreviation preceded by an underscore, e.g. <code>_m</code> for meter. "Square" units are preceded by <code>_sq</code>, e.g. <code>_sq_m</code> for square meters. Non SI units use their most common abbreviations.</p>
<p>All literals are defined in the <code><a class="el" href="namespaceunits_1_1literals.html" title="namespace for unit literal definitions of all categories.">units::literals</a></code> namespace, and in order to use literals in your code <em><b>you must include the line <code>using <a class="el" href="namespaceunits_1_1literals.html" title="namespace for unit literal definitions of all categories.">units::literals</a></code></b></em> (since there is no way to put a namespace on an operator).</p>
<p><em>* with the exception of <code>Teslas</code>, which use <code>_Te</code> for compatibility with MSVC compilers.</em></p>
<h1><a class="anchor" id="autotoc_md15"></a>
&lt;tt&gt;&lt;cmath&gt;&lt;/tt&gt; Functions</h1>
<p>The <code>units</code> library include type-safe unit_t container wrappers for almost all of the <code>&lt;cmath&gt;</code> functions, <em>including</em> the c++11 extensions. These functions can be found in the <code><a class="el" href="namespaceunits_1_1math.html" title="namespace for unit-enabled versions of the &lt;cmath&gt; library">units::math</a></code> namespace. The <code>units</code> library versions don't conflict with <code>&lt;cmath&gt;</code>, and it's possible to use both libraries in the same code.</p>
<p>The overloaded functions ensure that only the proper unit types are accepted into the functions, and that the return value type matches the expected units, all without needing to result to the type-unsafe <code>toDouble()</code> member.</p>
<p>In <em>rare</em> cases, the overload resolution for a given type may be ambiguous. If so, simply prepend the function with the fully-qualified <code><a class="el" href="namespaceunits_1_1math.html" title="namespace for unit-enabled versions of the &lt;cmath&gt; library">units::math</a></code> prefix, e.g.</p>
<div class="fragment"><div class="line">meter_t x(2.0);</div>
<div class="line">meter_t y(3.0);</div>
<div class="line">square_meter_t z(1.0);</div>
<div class="line">square_meter_t result;</div>
<div class="line"> </div>
<div class="line">result = <a class="code" href="group___unit_math.html#ga738302bf7a7758eac487800e6ca84316">fma</a>(x, y, z);                                              <span class="comment">// Error: ambiguous</span></div>
<div class="line"><span class="keywordtype">double</span> result = <a class="code" href="group___unit_math.html#ga738302bf7a7758eac487800e6ca84316">fma</a>(x.toDouble(), y.toDouble(), z.toDouble());      <span class="comment">// Warning: Unsafe!</span></div>
<div class="line">result = <a class="code" href="group___unit_math.html#ga738302bf7a7758eac487800e6ca84316">math::fma</a>(x, y, z);                                        <span class="comment">// OK.</span></div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md16"></a>
Exponentials and Square Roots</h1>
<p>Many functions require units to be raised to some power. This can be accomplished using the <code><a class="el" href="namespaceunits_1_1math.html#a8bc48cef3fdfae35910a4bbe5011abcd" title="computes the value of value raised to the power">units::math::pow</a></code> function:</p>
<div class="fragment"><div class="line">square_meter_t m2 = units::math::pow&lt;2&gt;(meter_t(5.0));  <span class="comment">// m2 == 25.0</span></div>
</div><!-- fragment --><p>The only constraint is that the exponential power (given in the template argument) must be known at compile time, so that the type system can deduce the output type. This differs from the <code>&lt;cmath&gt; pow</code> implementation, which takes exponent values at runtime.</p>
<p>Square roots are also provided with the <code><a class="el" href="group___unit_math.html#gae52f60a9e2a9e7ad1018a846bcf49140" title="computes the square root of value">units::math::sqrt</a></code> function. Due to the nature of the <code>sqrt</code> operation, the units library can often provide exact conversions for square root operations, but <em>not in every case</em>. The rest of the time, the <code>sqrt</code> unit will be a <em>rational_approximation</em> of the real value. These are guaranteed to be accurate to at least 10 decimal places.</p>
<div class="fragment"><div class="line">meter_t m = <a class="code" href="group___unit_math.html#gae52f60a9e2a9e7ad1018a846bcf49140">units::math::sqrt</a>(square_meter_t(4.0));     <span class="comment">// m == 2.0</span></div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md17"></a>
Removing type safety</h1>
<p>When interfacing with APIs, libraries, and frameworks which aren't <code>unit</code> enabled, it may be necessary (if regrettable) to remove the type-safety of a unit container and expose its underlying type. This is possible using the <code>unit_cast</code> function, or the <code>to&lt;&gt;</code> member function.</p>
<div class="fragment"><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespaceunits.html">units</a>;</div>
<div class="line"><span class="keyword">using namespace </span><a class="code" href="namespaceunits_1_1length.html">units::length</a>;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Get double value from a unit container (double is the default underlying type of the units library)</span></div>
<div class="line">meter_t dist(10);</div>
<div class="line"><span class="keywordtype">double</span> dval = unit_cast&lt;double&gt;(dist);</div>
<div class="line"><span class="keywordtype">double</span> dval2 = dist.to&lt;<span class="keywordtype">double</span>&gt;();</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Get integer value (potentially narrowing, be careful!)</span></div>
<div class="line"><span class="keywordtype">int</span> ival = unit_cast&lt;int&gt;(dist);</div>
<div class="line"><span class="keywordtype">int</span> ival2 = dist.to&lt;<span class="keywordtype">int</span>&gt;();</div>
</div><!-- fragment --><p>Both functions produce the same results, the choice of syntax is simply a user preference.</p>
<p>To determine the underlying type of the unit container, the (verbose) trait <code>units::traits::unit_t_traits&lt;decltype(dist)&gt;::underlying_type</code> could be used.</p>
<h1><a class="anchor" id="autotoc_md18"></a>
Efficiency</h1>
<p>Complex, recursively-defined conversions are performed in just 5 instructions: </p><pre class="fragment">    year_t twoYears(2.0);
    week_t twoYearsInWeeks = twoYears;
00007FF7BDB57FF6  xorps       xmm9,xmm9  
00007FF7BDB57FFA  cvtsi2sd    xmm9,rax  
00007FF7BDB57FFF  mulsd       xmm9,mmword ptr [__real@4000000000000000 (07FF7BDBB31A0h)]  
00007FF7BDB58008  divsd       xmm9,mmword ptr [__real@401c000000000000 (07FF7BDBB33C0h)]  
00007FF7BDB58011  movsd       mmword ptr [rbp+6Fh],xmm9  
    EXPECT_EQ(week_t(104.286), twoYearsInWeeks);
00007FF7BDB58017  ...
</pre><p>In the library, the year to week conversion is defined in terms of <code>years -&gt; days -&gt; hours -&gt; minutes -&gt; seconds -&gt; minutes -&gt; hours -&gt; days -&gt; weeks</code> but the total conversion ratio is computed at compile-time and the math is optimized to two floating-point operations.</p>
<p>Unit conversions between equivalent types are optimized away completely, and generate <em>no machine code</em>.</p>
<h1><a class="anchor" id="autotoc_md19"></a>
Pure Compile-time Unit Manipulation</h1>
<p>In many cases, unit equations are used to determine derived values from a set of values which are known at compile-time. In these situations, it would be optimal to pre-compute the derived values <em>at compile time</em>, thus generating no machine code and incurring no run-time penalty.</p>
<p>The <code>unit_value_t</code> class is the mechanism in the units library to perform compile-time arithmetic. The <code>unit_value_t</code> class functions exactly the same way as <code>std::ratio</code>, but with an associated unit tag and the ensuing type safety.</p>
<p>For a simple example, let's define a right triangle whose hypotenuse is the sum of the squares of its side (a Pythagorean triple)</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>RightTriangle</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">using</span> a = unit_value_t&lt;meters, 3&gt;;</div>
<div class="line">    <span class="keyword">using</span> b = unit_value_t&lt;meters, 4&gt;;</div>
<div class="line">    <span class="keyword">using</span> <a class="code" href="namespaceunits_1_1constants.html#acfa211a9904208ac580676b5cc42b04a">c</a> = unit_value_sqrt&lt;unit_value_add&lt;unit_value_power&lt;a, 2&gt;, unit_value_power&lt;b, 2&gt;&gt;&gt;;</div>
<div class="line">};</div>
</div><!-- fragment --><p>The definition above is perfectly efficient, as it generates <em>no run-time code</em> whatsoever, and still provides all the type safety of unit containers. The values of <code>a</code>, <code>b</code>, and <code>c</code> can be accessed at runtime using the static <code>value()</code> method of <code>unit_value_t</code></p>
<p>``<code>cpp auto a = RightTriangle::a::value(); // a is</code>meter_t(3)<code> auto b = RightTriangle::b::value(); // b is</code>meter_t(4)<code> auto c = RightTriangle::c::value(); // c is</code>meter_t(5)<code> </code>``</p>
<p>The available compile-time operations are:</p>
<ul>
<li><code><a class="el" href="structunits_1_1unit__value__add.html" title="adds two unit_value_t types at compile-time">units::unit_value_add</a></code></li>
<li><code><a class="el" href="structunits_1_1unit__value__subtract.html" title="subtracts two unit_value_t types at compile-time">units::unit_value_subtract</a></code></li>
<li><code><a class="el" href="structunits_1_1unit__value__multiply.html" title="multiplies two unit_value_t types at compile-time">units::unit_value_multiply</a></code></li>
<li><code><a class="el" href="structunits_1_1unit__value__divide.html" title="divides two unit_value_t types at compile-time">units::unit_value_divide</a></code></li>
<li><code><a class="el" href="structunits_1_1unit__value__power.html" title="raises unit_value_to a power at compile-time">units::unit_value_power</a></code></li>
<li><code><a class="el" href="structunits_1_1unit__value__sqrt.html" title="calculates square root of unit_value_t at compile-time">units::unit_value_sqrt</a></code></li>
</ul>
<h1><a class="anchor" id="autotoc_md20"></a>
Conversion without unit containers</h1>
<p>The preferred method of conversion is implicitly though the use of unit containers, however unit conversion can be accomplished using <code><a class="el" href="group___conversion.html#gaa03816ee32bb44ddbd6bc866ef89b231" title="converts a value from one type to another.">units::convert</a></code> for arithmetic types:</p>
<div class="fragment"><div class="line"><span class="keywordtype">double</span> val_in = convert&lt;feet, inches&gt;(1.0); <span class="comment">// val_in == 12.0</span></div>
</div><!-- fragment --><p>For type-safe conversion, prefer implicit conversion via unit_t type containers..</p>
<h1><a class="anchor" id="autotoc_md21"></a>
Namespaces</h1>
<p>Unit tags and containers are split into separate namespaces to avoid conflicting unit names which represent different physical quantities.</p>
<p>Unit tag and <code>unit_t</code> container definitions are defined in the following namespaces:</p><ul>
<li><a class="el" href="namespaceunits_1_1length.html" title="namespace for unit types and containers representing length values">units::length</a></li>
<li><a class="el" href="namespaceunits_1_1mass.html" title="namespace for unit types and containers representing mass values">units::mass</a></li>
<li><a class="el" href="namespaceunits_1_1time.html" title="namespace for unit types and containers representing time values">units::time</a></li>
<li><a class="el" href="namespaceunits_1_1angle.html" title="namespace for unit types and containers representing angle values">units::angle</a> (plane)</li>
<li><a class="el" href="namespaceunits_1_1current.html" title="namespace for unit types and containers representing current values">units::current</a></li>
<li><a class="el" href="namespaceunits_1_1temperature.html" title="namespace for unit types and containers representing temperature values">units::temperature</a></li>
<li><a class="el" href="namespaceunits_1_1substance.html" title="namespace for unit types and containers representing substance values">units::substance</a> (amount of, i.e. moles)</li>
<li><a class="el" href="namespaceunits_1_1luminous__intensity.html" title="namespace for unit types and containers representing luminous_intensity values">units::luminous_intensity</a></li>
<li><a class="el" href="namespaceunits_1_1solid__angle.html" title="namespace for unit types and containers representing solid_angle values">units::solid_angle</a></li>
<li><a class="el" href="namespaceunits_1_1frequency.html" title="namespace for unit types and containers representing frequency values">units::frequency</a></li>
<li><a class="el" href="namespaceunits_1_1velocity.html" title="namespace for unit types and containers representing velocity values">units::velocity</a></li>
<li><a class="el" href="namespaceunits_1_1angular__velocity.html" title="namespace for unit types and containers representing angular velocity values">units::angular_velocity</a></li>
<li><a class="el" href="namespaceunits_1_1acceleration.html" title="namespace for unit types and containers representing acceleration values">units::acceleration</a></li>
<li><a class="el" href="namespaceunits_1_1force.html" title="namespace for unit types and containers representing force values">units::force</a></li>
<li><a class="el" href="namespaceunits_1_1pressure.html" title="namespace for unit types and containers representing pressure values">units::pressure</a></li>
<li><a class="el" href="namespaceunits_1_1charge.html" title="namespace for unit types and containers representing charge values">units::charge</a></li>
<li><a class="el" href="namespaceunits_1_1energy.html" title="namespace for unit types and containers representing energy values">units::energy</a></li>
<li><a class="el" href="namespaceunits_1_1power.html" title="namespace for unit types and containers representing power values">units::power</a></li>
<li><a class="el" href="namespaceunits_1_1voltage.html" title="namespace for unit types and containers representing voltage values">units::voltage</a></li>
<li><a class="el" href="namespaceunits_1_1capacitance.html" title="namespace for unit types and containers representing capacitance values">units::capacitance</a></li>
<li><a class="el" href="namespaceunits_1_1impedance.html" title="namespace for unit types and containers representing impedance values">units::impedance</a></li>
<li><a class="el" href="namespaceunits_1_1magnetic__flux.html" title="namespace for unit types and containers representing magnetic_flux values">units::magnetic_flux</a></li>
<li><a class="el" href="namespaceunits_1_1magnetic__field__strength.html" title="namespace for unit types and containers representing magnetic_field_strength values">units::magnetic_field_strength</a></li>
<li><a class="el" href="namespaceunits_1_1inductance.html" title="namespace for unit types and containers representing inductance values">units::inductance</a></li>
<li><a class="el" href="namespaceunits_1_1luminous__flux.html" title="namespace for unit types and containers representing luminous_flux values">units::luminous_flux</a></li>
<li><a class="el" href="namespaceunits_1_1illuminance.html" title="namespace for unit types and containers representing illuminance values">units::illuminance</a></li>
<li><a class="el" href="namespaceunits_1_1radiation.html" title="namespace for unit types and containers representing radiation values">units::radiation</a></li>
<li><a class="el" href="namespaceunits_1_1torque.html" title="namespace for unit types and containers representing torque values">units::torque</a></li>
<li><a class="el" href="namespaceunits_1_1area.html" title="namespace for unit types and containers representing area values">units::area</a></li>
<li><a class="el" href="namespaceunits_1_1volume.html" title="namespace for unit types and containers representing volume values">units::volume</a></li>
<li><a class="el" href="namespaceunits_1_1density.html" title="namespace for unit types and containers representing density values">units::density</a></li>
<li><a class="el" href="namespaceunits_1_1concentration.html" title="namespace for unit types and containers representing concentration values">units::concentration</a></li>
<li><a class="el" href="namespaceunits_1_1data.html" title="namespace for unit types and containers representing data values">units::data</a></li>
<li><a class="el" href="namespaceunits_1_1data__transfer__rate.html" title="namespace for unit types and containers representing data values">units::data_transfer_rate</a></li>
<li><a class="el" href="namespaceunits_1_1constants.html" title="namespace for physical constants like PI and Avogadro&#39;s Number.">units::constants</a> (scalar and non-scalar physical constants like Avogadro's number)</li>
</ul>
<p>Literal values for unit containers are defined in the <code>literals</code> namespace</p><ul>
<li><a class="el" href="namespaceunits_1_1literals.html" title="namespace for unit literal definitions of all categories.">units::literals</a></li>
</ul>
<p>Mathematical operations like <code>sin</code>, <code>log</code>, <code>floor</code>, etc are defined in the following namespaces:</p><ul>
<li><a class="el" href="namespaceunits_1_1math.html" title="namespace for unit-enabled versions of the &lt;cmath&gt; library">units::math</a></li>
</ul>
<p>Type traits that you can use to test unit types are defined in the following namespaces:</p><ul>
<li><a class="el" href="namespaceunits_1_1traits.html" title="namespace representing type traits which can access the properties of types provided by the units lib...">units::traits</a></li>
</ul>
<h1><a class="anchor" id="autotoc_md22"></a>
Defining new units</h1>
<p>The units library strives to provide built-in types for every conceivable unit, and before defining your own units you should double-check the namespaces to make sure it's not already included. That said, if you need to roll your own units, the library is extensible by design.</p>
<p>Defining new units is simple, as they can be recursively defined as ratio of previously-defined units in a way that mimics natural language and is highly readable:</p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>time</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">using</span> seconds = <a class="code" href="structunits_1_1unit.html">units::unit&lt;std::ratio&lt;1&gt;</a>,   <a class="code" href="structunits_1_1base__unit.html">units::category::time_unit</a>&gt;;</div>
<div class="line">    <span class="keyword">using</span> minutes = <a class="code" href="structunits_1_1unit.html">units::unit&lt;std::ratio&lt;60&gt;</a>,  seconds&gt;;</div>
<div class="line">    <span class="keyword">using</span> hours   = <a class="code" href="structunits_1_1unit.html">units::unit&lt;std::ratio&lt;60&gt;</a>,  minutes&gt;;</div>
<div class="line">    <span class="keyword">using</span> days    = <a class="code" href="structunits_1_1unit.html">units::unit&lt;std::ratio&lt;24&gt;</a>,  hours&gt;;</div>
<div class="line">    <span class="keyword">using</span> weeks   = <a class="code" href="structunits_1_1unit.html">units::unit&lt;std::ratio&lt;7&gt;</a>,   days&gt;;</div>
<div class="line">    <span class="keyword">using</span> years   = <a class="code" href="structunits_1_1unit.html">units::unit&lt;std::ratio&lt;365&gt;</a>, days&gt;;</div>
<div class="line">}</div>
</div><!-- fragment --><p>Units are defined in the form: <code>using [unit] = unit&lt;std::ratio&lt;[number of base units per unit]&gt;, [base unit]&gt;;</code>, where:</p><ul>
<li>the <code>[unit]</code> is what you are defining.</li>
<li>the <code>[base unit]</code> is the unit that <code>[unit]</code> will be defined in terms of, and</li>
<li>the <code>[number of base units per unit]</code> is the conversion ratio between the two, expressed as a <code>std::ratio</code> type.</li>
</ul>
<p>Compound units are defined in a similar manner, with additional helper functions for polynomials: </p><pre class="fragment">using acceleration = compound_unit&lt;meters, inverse&lt;squared&lt;seconds&gt;&gt;&gt;;      // (m / s^2)
</pre><p>The available helpers are:</p><ul>
<li><code><a class="el" href="group___unit_manipulators.html#ga18b87c9f4576fb72ddc0b2a516a42d41" title="represents the inverse unit type of class U.">units::inverse</a>&lt;...&gt;</code> (inverts the unit, e.g. meters becomes meters^-1, or 1 / meters)</li>
<li><code><a class="el" href="group___unit_manipulators.html#ga38048bc5246636a5eb0007262475dc38" title="represents the unit type of class U squared">units::squared</a>&lt;...&gt;</code> (squares the unit, e.g. meters becomes meters^2)</li>
<li><code><a class="el" href="group___unit_manipulators.html#ga4278ee8cb796f22534570134325a4d52" title="represents the type of class U cubed.">units::cubed</a>&lt;...&gt;</code> (cubes the unit, e.g. meters becomes meters^3)</li>
<li><code><a class="el" href="group___unit_manipulators.html#gad6fb385c468a9f9956d23ebc7c38523a" title="represents the square root of type class U.">units::square_root</a>&lt;...&gt;</code> (takes the square root of the unit, e.g meters^2 becomes meters)</li>
<li><code><a class="el" href="group___unit_manipulators.html#gaae513fa68478da5ffc6dd1b739da560f" title="Represents the type of class U with the metric &#39;atto&#39; prefix appended.">units::atto</a>&lt;...&gt;</code> through <code><a class="el" href="group___unit_manipulators.html#gace72ca1410a8c171eafe012f152e8926" title="Represents the type of class U with the metric &#39;exa&#39; prefix appended.">units::exa</a>&lt;...&gt;</code> metric prefixes</li>
</ul>
<h1><a class="anchor" id="autotoc_md23"></a>
Unit definition macros</h1>
<p>Version <code>2.1.0</code> of the units library simplifies the task of adding new units by introducing a set of macros for unit definitions:</p>
<ul>
<li><p class="startli"><code><a class="el" href="units_8h.html#a39906c4d2537c6d904d8d44ffb6a4dec" title="Macro for generating the boiler-plate code needed for a new unit.">UNIT_ADD(namespaceName, nameSingular, namePlural, abbreviation, definition)</a></code></p>
<p class="startli">This macro adds a single new unit to the given namespace, as well as a literal definition and <code>cout</code> support based on the given <code>abbreviation</code>. e.g.</p>
</li>
</ul>
<div class="fragment"><div class="line"><a class="code" href="units_8h.html#a39906c4d2537c6d904d8d44ffb6a4dec">UNIT_ADD</a>(length, foot, feet, ft, unit&lt;std::ratio&lt;381, 1250&gt;, meters&gt;)</div>
</div><!-- fragment --><p>Would create the <code>units::length::feet</code> tag, the <code>units::length::foot_t</code> container type, and the <code>_ft</code> literal.</p>
<ul>
<li><p class="startli"><code><a class="el" href="units_8h.html#afefa09c81bf9352744e7e31164a07d2e" title="Macro for generating the boiler-plate code needed for a new unit, including its metric prefixes from ...">UNIT_ADD_WITH_METRIC_PREFIXES(namespaceName, nameSingular, namePlural, abbreviation, definition)</a></code></p>
<p class="startli">This macro has the same functionality as <code>UNIT_ADD</code>, but additionally adds unit types with all metric prefixes from <code>femto</code> to <code>peta</code> (smaller and larger prefixes mostly result in arithmetic overflow).</p>
</li>
<li><p class="startli"><code><a class="el" href="units_8h.html#acb409344e80b38f8ab8d1dc72a599623" title="Macro for generating the boiler-plate code needed for a new unit with a non-default underlying type.">UNIT_ADD_WITH_CUSTOM_TYPE(namespaceName, nameSingular, namePlural, abbreviation, underlyingType, definition)</a></code></p>
<p class="startli">This macro has the same functionality as <code>UNIT_ADD</code>, but additionally adds an <code>underlyingType</code> parameter, which can be used to create units with integral, or other underlying types. The library default underlying type is <code>double</code>.</p>
</li>
<li><p class="startli"><code><a class="el" href="units_8h.html#aacbc20cfef3586d1c51b51c998679b99" title="Macro to create decibel container and literals for an existing unit type.">UNIT_ADD_DECIBEL(namespaceName, nameSingular, abbreviation)</a></code></p>
<p class="startli">Adds the decibel representation for a previously-defined unit. e.g.</p>
</li>
</ul>
<div class="fragment"><div class="line"><a class="code" href="units_8h.html#aacbc20cfef3586d1c51b51c998679b99">UNIT_ADD_DECIBEL</a>(power, watt, dBW)</div>
</div><!-- fragment --><p>Adds the <code>dBW_t</code> container, and the <code>_dBW</code> literal.</p>
<ul>
<li><p class="startli"><code><a class="el" href="units_8h.html#aa0b0ec340728bbef5aeab07641a61948" title="Macro to create the is_category_unit type trait.">UNIT_ADD_CATEGORY_TRAIT(unitCategory, baseUnit)</a></code></p>
<p class="startli">This macro creates a type-trait to check whether a unit is of a certain category, e.g. length. This is only necessary if defining new categories of units which are not included in <code><a class="el" href="units_8h.html" title="Complete implementation of units - a compile-time, header-only, unit conversion library built on c++1...">units.h</a></code> at all. e.g.</p>
</li>
</ul>
<div class="fragment"><div class="line"><a class="code" href="units_8h.html#aa0b0ec340728bbef5aeab07641a61948">UNIT_ADD_CATEGORY_TRAIT</a>(length, meter)</div>
</div><!-- fragment --><p>Adds the <code><a class="el" href="structunits_1_1traits_1_1is__length__unit.html">units::traits::is_length_unit</a></code> trait.</p>
<h1><a class="anchor" id="autotoc_md24"></a>
Unit Type Traits</h1>
<p>The units library provides a comprehensive set of type-traits, which can be used in templated user code to enforce that the unit types have certain properties.</p>
<p>For example, let's say you want to write a function that validates that the square footage of an office (given in any units), meets the minimum size required by local ordinance.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Units&gt;</div>
<div class="line"><span class="keywordtype">bool</span> isMinimumSize(Units x)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">return</span> x &gt;= square_feet_t(80.0);</div>
<div class="line">}</div>
</div><!-- fragment --><p>This function will fail to compile if <code>Units</code> is not a unit of area (since incompatible unit types are not comparable), but it will produce a series difficult-to-understand template errors. Type traits could be used to make the error message more friendly:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Units&gt;</div>
<div class="line"><span class="keywordtype">bool</span> isMinimumSize(Units x)</div>
<div class="line">{</div>
<div class="line">    static_assert(<a class="code" href="structunits_1_1traits_1_1is__area__unit.html">units::traits::is_area_unit&lt;Units&gt;::value</a>, <span class="stringliteral">&quot;Input value x must represent an area quantity.&quot;</span>);</div>
<div class="line">    <span class="keywordflow">return</span> x &gt;= square_feet_t(80.0);</div>
<div class="line">}</div>
</div><!-- fragment --><p>See the <code><a class="el" href="namespaceunits_1_1traits.html" title="namespace representing type traits which can access the properties of types provided by the units lib...">units::traits</a></code> namespace for a list of all the supported traits.</p>
<h1><a class="anchor" id="autotoc_md25"></a>
Changing the underlying type of &lt;tt&gt;unit_t&lt;/tt&gt;</h1>
<p>The default underlying type for all unit containers is <code>double</code>. However, this can be overridden by providing a definition for <code>UNIT_LIB_DEFAULT_TYPE</code>, e.g.</p>
<div class="fragment"><div class="line"><span class="comment">// Use 64-bit integers as the underlying unit type</span></div>
<div class="line"><span class="preprocessor">#define UNIT_LIB_DEFAULT_TYPE int64_t</span></div>
<div class="line"><span class="preprocessor">#include &lt;units.h&gt;</span></div>
</div><!-- fragment --><p>**_NOTE:_ changing the underlying type may result in unexpected behavior.** Unit conversion makes heavy use of division, which may make integral types unsuitable except for niche embedded applications. Using excessively large types may increase the number of arithmetic overflow errors.</p>
<h1><a class="anchor" id="autotoc_md26"></a>
Disabling IOStream</h1>
<p>For some embedded applications, it may be <a href="https://github.com/nholthaus/units/issues/32">desirable to remove all references to <code>&lt;iostream&gt;</code> in order to reduce compiled binary size and RAM requirements</a>. There are two ways to accomplish this:</p>
<ol type="1">
<li>If you are copy/pasting <code><a class="el" href="units_8h.html" title="Complete implementation of units - a compile-time, header-only, unit conversion library built on c++1...">units.h</a></code> into your project include directory, then simply define <code>UNIT_LIB_DISABLE_IOSTREAM</code> before including the header.</li>
</ol>
<div class="fragment"><div class="line"><span class="preprocessor">#define UNIT_LIB_DISABLE_IOSTREAM</span></div>
<div class="line"><span class="preprocessor">#include &lt;units.h&gt;</span></div>
</div><!-- fragment --><ol type="1">
<li>If you are including <code>units</code> in your project as a <code>CMake</code> target (using <code>add_subdirectory</code>), then all you need to do is set the <code>DISABLE_IOSTREAM</code> cache option, either using the cmake-gui, or by adding the option to the cmake command line during configuration:</li>
</ol>
<div class="fragment"><div class="line">cmake -DDISABLE_IOSTREAM=ON -DBUILD_TESTS=OFF ..</div>
<div class="line">cmake --build . --config Release</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md27"></a>
Enabling a subset of units to improve compilation time</h1>
<p>If you know that you only need a subset of the unit namespaces for your application, you can dramatically improve compilation time by disabling the default definitions, and then only opting-in to the namespaces you want. For example:</p>
<div class="fragment"><div class="line"><span class="comment">// Only use length and time</span></div>
<div class="line"><span class="preprocessor">#define DISABLE_PREDEFINED_UNITS</span></div>
<div class="line"><span class="preprocessor">#define ENABLE_PREDEFINED_LENGTH_UNITS</span></div>
<div class="line"><span class="preprocessor">#define ENABLE_PREDEFINED_TIME_UNITS</span></div>
</div><!-- fragment --><p>The generic algorithm is</p><ol type="1">
<li>disable the pre-defined units using <code>#define DISABLE_PREDEFINED_UNITS</code></li>
<li>opt-in to the namespaces you want using <code>#define ENABLE_PREDEFINED_&lt;namepsace name&gt;_UNITS</code></li>
</ol>
<p>Additionally, for <code>CMake</code> users, there are equivalently-named cmake options defined which will automatically include the preprocessor definitions in your project.</p>
<h1><a class="anchor" id="autotoc_md28"></a>
Macro clashes</h1>
<p>With certain compilers, it is possible that system header files like <code>&lt;ctype.h&gt;</code> will define macros which conflict with the unit literals, which use SI abbreviations. In these cases, it is general safe and advisable to <code>#undef</code> the offending macros.</p>
<h2><a class="anchor" id="autotoc_md29"></a>
Windows macros</h2>
<p><code>_T</code> is known to conflict, but is hardcoded into the compiler and can't be disabled. For this reason, <code>Tesla</code> units use the <code>_Te</code> abbreviation.</p>
<p>The following macros may need to be undefined on the Windows platform to use <code>units</code>:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#undef pascal</span></div>
<div class="line"><span class="preprocessor">#include &lt;units.h&gt;</span></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md30"></a>
ARM macros</h2>
<p>The following macros may need to be undefined on the ARM platform to use <code><a class="el" href="namespaceunits_1_1literals.html" title="namespace for unit literal definitions of all categories.">units::literals</a></code>:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#undef _U</span></div>
<div class="line"><span class="preprocessor">#undef _L</span></div>
<div class="line"><span class="preprocessor">#undef _N</span></div>
<div class="line"><span class="preprocessor">#undef _S</span></div>
<div class="line"><span class="preprocessor">#undef _P</span></div>
<div class="line"><span class="preprocessor">#undef _C</span></div>
<div class="line"><span class="preprocessor">#undef _X</span></div>
<div class="line"><span class="preprocessor">#undef _B</span></div>
<div class="line"><span class="preprocessor">#define UNIT_LIB_DISABLE_IOSTREAM // it&#39;s prudent to disable IOStream on embedded platforms as well.</span></div>
<div class="line"><span class="preprocessor">#include &lt;units.h&gt;</span></div>
</div><!-- fragment --><p>It's best to undefine macros on an as-needed basis.</p>
<h1><a class="anchor" id="autotoc_md31"></a>
CMake Instructions</h1>
<p>There are several ways to incorporate <code><a class="el" href="units_8h.html" title="Complete implementation of units - a compile-time, header-only, unit conversion library built on c++1...">units.h</a></code> into your project. The simplest is to just copy <code><a class="el" href="units_8h.html" title="Complete implementation of units - a compile-time, header-only, unit conversion library built on c++1...">include/units.h</a></code> into your project include directory (which the licensing allows you to do). However, you'll have to properly set up the necessary compilation flags for C++14 (<code>-std=c++14</code> on gcc).</p>
<p>However, if you are already using CMake as your build system, the recommended way to include <code>units</code> is to copy the entire <code>units</code> project as a subdirectory within your own top-level project folder. Then, in your CMakeLists.txt file add</p>
<div class="fragment"><div class="line">add_subdirectory(units)</div>
<div class="line"> </div>
<div class="line">add_executable(${PROJECT_NAME} main.cpp)</div>
<div class="line">target_link_libraries(${PROJECT_NAME} units)</div>
</div><!-- fragment --><p>Also, if you are distributing headers that depends on <a class="el" href="units_8h.html" title="Complete implementation of units - a compile-time, header-only, unit conversion library built on c++1...">units.h</a>, you shoud consider using cmake's <code>find_package</code> to check if the header is installed on the user's system: </p><pre class="fragment">```cmake
find_package(units)

add_library(${PROJECT_NAME} my_lib.cpp)
target_link_libraries(${PROJECT_NAME} units::units)
```
</pre><p>The include path properties are part of the <code>units</code> target, so adding it as a subdirectory and linking against it is all you need to do, no need to worry about additional include directories.</p>
<p>If you don't care about the unit tests, you can minimize compile time by invoking CMake with the following option:</p>
<div class="fragment"><div class="line">cmake -DBUILD_TESTS=OFF ..</div>
<div class="line">cmake -build .</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md32"></a>
Build Instructions</h1>
<p>The library itself consists of a single header <a href="include/units.h">units.h</a>, and can be included into your project without being built.</p>
<p>The unit tests and documentation can be built with CMake. A doxygen installation is required to generate the documentation, and a Tex install is needed if pdf documentation is desired.</p>
<p>To build the tests:</p>
<h2><a class="anchor" id="autotoc_md33"></a>
Windows</h2>
<ol type="1">
<li>Ensure <a href="https://cmake.org/download/"><code>cmake</code></a> is installed, and that the <code>bin</code> directory is in your <code>PATH%</code> variable, and that a compiler like <a href="https://www.visualstudio.com/post-download-vs?sku=community&amp;clcid=0x409&amp;downloadrename=true#"><code>Visual Studio 2015 Community Edition</code></a> is installed.</li>
<li>clone the repository or download the <code>.zip</code> package.</li>
<li>Open a <code>cmd</code> terminal and navigate to the source directory.</li>
<li>Type the following commands:<ul>
<li><code>md build</code></li>
<li><code>cd build</code></li>
<li><code>cmake -Wno-dev ..</code></li>
<li><code>cmake --build . --config Release</code></li>
</ul>
</li>
<li>The tests will be created in an executable called <code>unitLibTest.exe</code> in the folder <code>build/unitTests/Release</code>.</li>
</ol>
<h2><a class="anchor" id="autotoc_md34"></a>
Linux</h2>
<ol type="1">
<li>Ensure you are using cmake 3.2 or later. You can verify this with <code>cmake --version</code>.</li>
<li>Ensure you are using gcc version 4.9 or greater. You can verify this with <code>gcc --version</code>.</li>
<li>clone the repository or download the <code>.tar.gz</code> package.</li>
<li>Open a terminal and navigate to the source directory.</li>
<li>Type the following commands:<ul>
<li><code>mkdir build</code></li>
<li><code>cd build</code></li>
<li><code>cmake -Wno-dev ..</code></li>
<li><code>cmake --build . --config Release</code></li>
</ul>
</li>
<li>The tests will be created in an executable called <code>unitLibTest</code> in the folder <code>build/unitTests</code>.</li>
</ol>
<h1><a class="anchor" id="autotoc_md35"></a>
Previous Releases</h1>
<ul>
<li><a href="https://github.com/nholthaus/units/releases/tag/v2.0.3"><code>v2.0.3</code></a> <br  />
<ul>
<li><code>unit_t</code> types are now trivial types.</li>
<li><code>unit_t</code> types support the unary minus (negation) operator.</li>
<li>Compile-time unit arithmetic via <code>unit_value_t</code>.</li>
<li>Unit-enabled ports of most <code>&lt;cmath&gt;</code> functions, including c++11 extensions.</li>
<li>Square-root manipulators for <code>unit</code>, <code>unit_t</code>, and <code>unit_value_t</code>.</li>
<li>Improved documentation.</li>
</ul>
</li>
<li><a href="https://github.com/nholthaus/units/releases/tag/v1.3.0"><code>v1.3.0</code></a> <br  />
<ul>
<li>Adds ostream support.</li>
<li>bug fixes.</li>
</ul>
</li>
<li><a href="https://github.com/nholthaus/units/releases/tag/v1.2.2"><code>v1.2.2</code></a> <br  />
<ul>
<li>Bug fixes (#1) and namespace cleanup.</li>
</ul>
</li>
<li><a href="https://github.com/nholthaus/units/releases/tag/v1.2.0"><code>v1.2.0</code></a> <br  />
<ul>
<li>Adds angular velocity units.</li>
</ul>
</li>
<li><a href="https://github.com/nholthaus/units/releases/tag/v1.1.1"><code>v1.1.1</code></a> <br  />
<ul>
<li>Adds Doxygen and additional type traits.</li>
</ul>
</li>
<li><a href="https://github.com/nholthaus/units/releases/tag/v1.0.0"><code>v1.0.0</code></a> <br  />
<ul>
<li>Initial release. </li>
</ul>
</li>
</ul>
</div></div><!-- PageDoc -->
</div><!-- contents -->
<div class="ttc" id="anamespaceunits_1_1literals_html"><div class="ttname"><a href="namespaceunits_1_1literals.html">units::literals</a></div><div class="ttdoc">namespace for unit literal definitions of all categories.</div></div>
<div class="ttc" id="aunits_8h_html_aa0b0ec340728bbef5aeab07641a61948"><div class="ttname"><a href="units_8h.html#aa0b0ec340728bbef5aeab07641a61948">UNIT_ADD_CATEGORY_TRAIT</a></div><div class="ttdeci">#define UNIT_ADD_CATEGORY_TRAIT(unitCategory)</div><div class="ttdoc">Macro to create the is_category_unit type trait.</div><div class="ttdef"><b>Definition:</b> units.h:358</div></div>
<div class="ttc" id="aunits_8h_html_aacbc20cfef3586d1c51b51c998679b99"><div class="ttname"><a href="units_8h.html#aacbc20cfef3586d1c51b51c998679b99">UNIT_ADD_DECIBEL</a></div><div class="ttdeci">#define UNIT_ADD_DECIBEL(namespaceName, nameSingular, abbreviation)</div><div class="ttdoc">Macro to create decibel container and literals for an existing unit type.</div><div class="ttdef"><b>Definition:</b> units.h:309</div></div>
<div class="ttc" id="aclassunits_1_1unit__t_html"><div class="ttname"><a href="classunits_1_1unit__t.html">units::unit_t</a></div><div class="ttdoc">Container for values which represent quantities of a given unit.</div><div class="ttdef"><b>Definition:</b> units.h:1889</div></div>
<div class="ttc" id="anamespaceunits_1_1velocity_html"><div class="ttname"><a href="namespaceunits_1_1velocity.html">units::velocity</a></div><div class="ttdoc">namespace for unit types and containers representing velocity values</div></div>
<div class="ttc" id="aunits_8h_html_a39906c4d2537c6d904d8d44ffb6a4dec"><div class="ttname"><a href="units_8h.html#a39906c4d2537c6d904d8d44ffb6a4dec">UNIT_ADD</a></div><div class="ttdeci">#define UNIT_ADD(namespaceName, nameSingular, namePlural, abbreviation,...)</div><div class="ttdoc">Macro for generating the boiler-plate code needed for a new unit.</div><div class="ttdef"><b>Definition:</b> units.h:267</div></div>
<div class="ttc" id="anamespaceunits_1_1length_html"><div class="ttname"><a href="namespaceunits_1_1length.html">units::length</a></div><div class="ttdoc">namespace for unit types and containers representing length values</div></div>
<div class="ttc" id="anamespaceunits_1_1constants_html_acfa211a9904208ac580676b5cc42b04a"><div class="ttname"><a href="namespaceunits_1_1constants.html#acfa211a9904208ac580676b5cc42b04a">units::constants::c</a></div><div class="ttdeci">static constexpr const velocity::meters_per_second_t c(299792458.0)</div><div class="ttdoc">Speed of light in vacuum.</div></div>
<div class="ttc" id="anamespaceunits_1_1area_html"><div class="ttname"><a href="namespaceunits_1_1area.html">units::area</a></div><div class="ttdoc">namespace for unit types and containers representing area values</div></div>
<div class="ttc" id="agroup___unit_math_html_gae52f60a9e2a9e7ad1018a846bcf49140"><div class="ttname"><a href="group___unit_math.html#gae52f60a9e2a9e7ad1018a846bcf49140">units::math::sqrt</a></div><div class="ttdeci">auto sqrt(const UnitType &amp;value) noexcept -&gt; unit_t&lt; square_root&lt; typename units::traits::unit_t_traits&lt; UnitType &gt;::unit_type &gt;, typename units::traits::unit_t_traits&lt; UnitType &gt;::underlying_type, linear_scale &gt;</div><div class="ttdoc">computes the square root of value</div><div class="ttdef"><b>Definition:</b> units.h:4570</div></div>
<div class="ttc" id="astructunits_1_1base__unit_html"><div class="ttname"><a href="structunits_1_1base__unit.html">units::base_unit</a></div><div class="ttdoc">Class representing SI base unit types.</div><div class="ttdef"><b>Definition:</b> units.h:728</div></div>
<div class="ttc" id="aunits_8h_html"><div class="ttname"><a href="units_8h.html">units.h</a></div><div class="ttdoc">Complete implementation of units - a compile-time, header-only, unit conversion library built on c++1...</div></div>
<div class="ttc" id="anamespaceunits_html"><div class="ttname"><a href="namespaceunits.html">units</a></div><div class="ttdoc">Unit Conversion Library namespace.</div><div class="ttdef"><b>Definition:</b> units.h:92</div></div>
<div class="ttc" id="astructunits_1_1traits_1_1is__area__unit_html"><div class="ttname"><a href="structunits_1_1traits_1_1is__area__unit.html">units::traits::is_area_unit</a></div><div class="ttdef"><b>Definition:</b> units.h:3974</div></div>
<div class="ttc" id="agroup___unit_math_html_ga738302bf7a7758eac487800e6ca84316"><div class="ttname"><a href="group___unit_math.html#ga738302bf7a7758eac487800e6ca84316">units::math::fma</a></div><div class="ttdeci">auto fma(const UnitTypeLhs x, const UnitMultiply y, const UnitAdd z) noexcept -&gt; decltype(x *y)</div><div class="ttdoc">Multiply-add.</div><div class="ttdef"><b>Definition:</b> units.h:4789</div></div>
<div class="ttc" id="astructunits_1_1unit_html"><div class="ttname"><a href="structunits_1_1unit.html">units::unit</a></div><div class="ttdoc">Type representing an arbitrary unit.</div><div class="ttdef"><b>Definition:</b> units.h:853</div></div>
<div class="ttc" id="anamespaceunits_1_1math_html"><div class="ttname"><a href="namespaceunits_1_1math.html">units::math</a></div><div class="ttdoc">namespace for unit-enabled versions of the &lt;cmath&gt; library</div><div class="ttdef"><b>Definition:</b> units.h:2750</div></div>
<div class="ttc" id="anamespaceunits_1_1time_html"><div class="ttname"><a href="namespaceunits_1_1time.html">units::time</a></div><div class="ttdoc">namespace for unit types and containers representing time values</div></div>
<div class="ttc" id="agroup___unit_containers_html_ga1acd69ada7a93c35850717e3c1b4d5fc"><div class="ttname"><a href="group___unit_containers.html#ga1acd69ada7a93c35850717e3c1b4d5fc">units::make_unit</a></div><div class="ttdeci">constexpr UnitType make_unit(const T value) noexcept</div><div class="ttdoc">Constructs a unit container from an arithmetic type.</div><div class="ttdef"><b>Definition:</b> units.h:2181</div></div>
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sat Oct 3 2020 11:16:57 for Unit Conversion and Dimensional Analysis Library by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
